//====== Copyright © 1996-2005, Valve Corporation, All rights reserved. =======
//
// Purpose: General game definition file (.fgd) 
//
// This is the Mapbase version of the base FGD.
// Much of this content only works in Mapbase.
//
//=============================================================================

@mapsize(-16384, 16384)




@AutoVisGroup = "Entities"
[
    "Cubemaps"
    [
        "env_cubemap"
        "parallax_obb"
    ]
    "Soundscapes"
    [
        "env_soundscape"
        "env_soundscape_proxy"
        "env_soundscape_triggerable"
        "trigger_soundscape"
    ] 
]


//-------------------------------------------------------------------------
//
// Base Classes
//
//-------------------------------------------------------------------------

@BaseClass = Angles
[ 
	angles(angle) : "Pitch Yaw Roll (Y Z X)" : "0 0 0" : "This entity's orientation in the world. Pitch is rotation around the Y axis, " +
		"yaw is the rotation around the Z axis, roll is the rotation around the X axis."
		
	input SetLocalAngles(vector) : "Set this entity's angles in local space, relative to its parent if one exists. Otherwise relative to the world."
	input SetAbsAngles(vector) : "Set this entity's angles, always relative to the world origin."
]

@BaseClass = Origin
[ 
	origin(origin) : "Origin (X Y Z)" : : "The position of this entity's center in the world. Rotating entities typically rotate around their origin."
]

// Designed to be used on both NPCs and entities deriving from Studiomodel.
@BaseClass = StudiomodelBase
[
	lightingorigin(target_destination) : "Lighting Origin" : "" : "Select an entity to specify a location to sample lighting from, instead of using this entity's origin."

	// Inputs
	input Skin(integer) : "Changes the model skin to the specified number."
	input SetModel(string) : "Sets this entity's model. Must include 'models/' as well as the extension."
	input BecomeRagdoll(void) : "This entity will instantly become a ragdoll with ZERO force (just go limp). OnDeath, OnHalfHealth, etc. outputs will **NOT** BE FIRED."
	input CreateSeparateRagdoll(void) : "Creates a separate serverside ragdoll at this entity's origin."
	input CreateSeparateRagdollClient(void) : "Creates a separate clientside ragdoll at this entity's origin."
	input SetLightingOrigin(target_destination) : "Sets this entity's lighting origin." // Was this really not in the FGD before?
	input SetPoseParameter(string) : "Sets the specified pose parameter to the specified value (e.g. ''aim_yaw 45'')."
	
	// Outputs
	output OnIgnite(void) : "Fires when this object catches fire."
	output OnServerRagdoll(ehandle) : "Fires when this object becomes/creates a serverside ragdoll. Passes the ragdoll."
]

@BaseClass base(StudiomodelBase) = Studiomodel
[
	model(studio) : "World Model"
	skin(integer) : "Skin" : 0 : "Some models have multiple versions of their textures, called skins. Set this to a number other than 0 to use that skin instead of the default."
	modelscale(float) : "Model Scale" : "1.0" : "A multiplier for the size of the model."
	SetBodyGroup(integer) : "Bodygroup" : : "Sets this model's bodygroup (from 0 - n). You can do things like put headcrabs on zombie ragdolls by using '1' here, but it's probably best not to mess with it if you don't know what it is."

	disableshadows(choices) : "Disable Shadows" : 0 : "Used to disable dynamic shadows on this entity." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	disableflashlight(choices) : "Disable flashlight" : 0 : "Used to disable flashlight/env_projectedtexture lighting and shadows on this entity." =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input DisableShadow(void) : "Turns shadow off."
	input EnableShadow(void) : "Turns shadow on."
	input DisableReceivingFlashlight(void) : "This object will not recieve light or shadows from projected textures (flashlights)."
	input EnableReceivingFlashlight(void) : "This object may recieve light or shadows from projected textures (flashlights)."
	input AlternativeSorting(bool) : "Used to attempt to fix sorting problems when rendering. True activates, false deactivates"
	input SetModelScale(string) : "Takes two values separated by a space. The first is the target model scale. The second value is the number of seconds the change in scale will be spread over."
	input SetBodyGroup(integer) : "Sets this model's body group (from 0 - n). You'd better know what you are doing!"
]

@BaseClass = BasePlat
[
 	input Toggle(void) : "Toggles the platform's state."
	input GoUp(void) : "Tells the platform to go up."
	input GoDown(void) : "Tells the platform to go down."
]

@BaseClass = Targetname 
[ 
	targetname(target_source) : "Name" : : "The name that other entities refer to this entity by."
	
	vscripts(string) : "Entity Scripts" : "" : "Name(s) of script files that are executed after all entities have spawned."
	thinkfunction(string) : "Script think function" : "" : "Name of a function in this entity's script scope which will be called automatically."

	input RunScriptFile(string) : "Execute a game script file from disk"
	input RunScriptCode(string) : "Execute a string of script source code"
	input RunScriptCodeQuotable(string) : "Execute a string of script source code which converts double apostrophes ('') to quotation marks for strings"
	input CallScriptFunction(string) : "Call a named function from this entity's Activation Script"
	input ClearScriptScope(void) : "Clears this entity's script scope"
	
	
	// Inputs
	input Kill(void) : "Removes this entity from the world."
	input KillHierarchy(void) : "Removes this entity and all its children from the world."
	input KillIfNotVisible(void) : "Removes this entity if it is not in a player's viewcone."
	input KillWhenNotVisible(float) : "Removes this entity when it is not in a player's viewcone. You can pass a time for when this should start."
	input AddOutput(string) : "Adds an entity I/O connection or a keyvalue to this entity. Format: '<output name> <targetname>:<inputname>:<parameter>:<delay>:<max times to fire (-1 == infinite)>'. You could also use it on regular keyvalues: '<key name> <key value>'. Very dangerous, use with care."
	input ChangeVariable(string) : "Similar to AddOutput, except it changes an internal variable similar to logic_datadesc_accessor instead. Very dangerous, use with care."
	input FireUser1(void) : "Causes this entity's OnUser1 output to be fired."
	input FireUser2(void) : "Causes this entity's OnUser2 output to be fired."
	input FireUser3(void) : "Causes this entity's OnUser3 output to be fired."
	input FireUser4(void) : "Causes this entity's OnUser4 output to be fired."
	
	// Mapbase -- New User I
	input PassUser1(string) : "Causes this entity's OutUser1 output to be fired. Can pass any parameter."
	input PassUser2(string) : "Causes this entity's OutUser2 output to be fired. Can pass any parameter."
	input PassUser3(string) : "Causes this entity's OutUser3 output to be fired. Can pass any parameter."
	input PassUser4(string) : "Causes this entity's OutUser4 output to be fired. Can pass any parameter."
	
	input FireRandomUser(void) : "Fires OnUser1, OnUser2, OnUser3, or OnUser4 with a 25% chance of each."
	input PassRandomUser(string) : "Fires OutUser1, OutUser2, OutUser3, or OutUser4 with a 25% chance of each. Can pass any parameter."
	
	// Mapbase -- BaseEntity I/O
	input FireOutput(string) : "Fires the named output on this entity. Format: '<output name>:<activator>:<caller>:<parameter>:<delay>' (OnDeath:hl3cardgame:gaben). Everything beyond the output name is optional."
	input RemoveOutput(string) : "Removes all instances of the named output on this entity. Wildcards are supported, meaning you could just pass '*' to wipe all outputs from this entity."
	input AcceptInput(string) : "Fires the named input on this entity. Format: '<input name>:<parameter>:<activator>:<caller>:<output ID>' (SetTarget:cheese). Everything beyond the input name is optional. Mind the fact this is arranged differently from FireOutput, having the parameter right after the input name."
	input CancelPending(void) : "Cancels any events fired by this entity that are currently pending in the I/O event queue."
	
	input SetLocalOrigin(vector) : "Sets this entity's origin in local space, relative to its parent if one exists. Otherwise relative to the world."
	input SetAbsOrigin(vector) : "Sets this entity's origin in the map, always relative to the world origin."
	input SetLocalVelocity(vector) : "Sets this entity's current velocity."
	input SetLocalAngularVelocity(vector) : "Sets this entity's current angular velocity."
	
	input AddSpawnFlags(integer) : "Adds spawnflag(s) to this entity. Many spawnflags have their respective numbers suffixed in this FGD."
	input RemoveSpawnFlags(integer) : "Removes spawnflag(s) from this entity. Many spawnflags have their respective numbers suffixed in this FGD."
	
	input AddSolidFlags(integer) : "Adds solid flags to this entity."
	input RemoveSolidFlags(integer) : "Removes solid flags from this entity."
	
	input SetHealth(integer) : "Sets this entity's health."
	input AddHealth(integer) : "Adds to this entity's health."
	input RemoveHealth(integer) : "Removes from this entity's health."
	
	input SetMaxHealth(integer) : "Sets this entity's max health."
	
	input SetEntityName(target_destination) : "Sets this entity's name that other entities should refer to it by."
	
	input SetTarget(target_destination) : "Sets this entity's target. This is specific to certain entities, particularly logic entities that involve a target."
	input SetOwnerEntity(target_destination) : "Sets this entity's owner entity. This has nothing to do with parenting and has more to do with collision and kill credits."
	
	input SetThinkNull(void) : "Sets this entity's general think function to null. Behavior varies from entity to entity.."
	
	input Use(void) : "More or less replicates the player interacting with an entity. (+USE)"
	input Touch(target_destination) : "Simulates this entity touching the specified entity."
	
	output OnKilled(void) : "Fires when this entity is removed with the 'Kill' input."

	// Outputs	
	output OnUser1(void) : "Fires in response to FireUser1 input."
	output OnUser2(void) : "Fires in response to FireUser2 input."
	output OnUser3(void) : "Fires in response to FireUser3 input."
	output OnUser4(void) : "Fires in response to FireUser4 input."
	
	// Mapbase -- New User O
	output OutUser1(string) : "Fires in response to PassUser1 input. Can pass any parameter."
	output OutUser2(string) : "Fires in response to PassUser2 input. Can pass any parameter."
	output OutUser3(string) : "Fires in response to PassUser3 input. Can pass any parameter."
	output OutUser4(string) : "Fires in response to PassUser4 input. Can pass any parameter."
]

@BaseClass = Parentname
[ 
	parentname(target_destination) : "Parent" : : "The name of this entity's parent in the movement hierarchy. Entities with parents move with their parent. Use the format ''<parent name>, <attachment>'' to parent to a specific attachment point."

	// Inputs
	input SetParent(target_destination) : "Changes the entity's parent in the movement hierarchy."
	input SetParentAttachment(string) : "Change this entity to attach to a specific attachment point on its parent. Entities must be parented before being sent this input. The parameter passed in should be the name of the attachment."
	input SetParentAttachmentMaintainOffset(string) : "Change this entity to attach to a specific attachment point on it's parent. Entities must be parented before being sent this input. The parameter passed in should be the name of the attachment. The entity will maintain it's position relative to the parent at the time it is attached."
	input ClearParent(void) : "Removes this entity from the the movement hierarchy, leaving it free to move independently."
	
	input FreeChildren(void) : "Unparents all entities parented to this entity in a movement hierarchy."
]

@BaseClass = BaseBrush
[
	// Inputs
	input SetTextureIndex(integer) : "Used by HL1Port. Sets the brush texture index. Use a material_modify_control entity instead."
	input IncrementTextureIndex(void) : "Used by HL1Port. Increments the brush texture index. Use a material_modify_control entity instead."
]

@BaseClass = EnableDisable
[
	StartDisabled(choices) : "Start Disabled" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input Enable(void) : "Enables this entity."
	input Disable(void) : "Disables this entity."
]

@BaseClass = RenderFxChoices
[
	renderfx(choices) :"Render FX" : 0 =
	[
		0: "Normal"
		1: "Slow Pulse"
		2: "Fast Pulse"
		3: "Slow Wide Pulse"
		4: "Fast Wide Pulse"
		9: "Slow Strobe"
		10: "Fast Strobe"
		11: "Faster Strobe"
		12: "Slow Flicker"
		13: "Fast Flicker"
		5: "Slow Fade Away"
		6: "Fast Fade Away"
		7: "Slow Become Solid"
		8: "Fast Become Solid"
		14: "Constant Glow"
		15: "Distort"
		16: "Hologram (Distort + fade)"
		23: "Cull By Distance (TEST)"
		24: "Spotlight FX"
		26: "Fade Near"
	]
]

@BaseClass = Shadow
[
	disableshadows(choices) : "Disable shadows" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	input DisableShadow(void) : "Turns shadow off."
	input EnableShadow(void) : "Turns shadow on."
]

@BaseClass base(RenderFxChoices) = RenderFields 
[
	rendermode(choices) : "Render Mode" : 0 : "Used to set a non-standard rendering mode on this entity. See also 'FX Amount' and 'FX Color'. Most of these are only used by sprites." =
	[
		0: "Normal"
		1: "Color"
		2: "Texture"
		3: "Glow"
		4: "Solid"
		5: "Additive"
		7: "Additive Fractional Frame"
		9: "World Space Glow"
		10: "Dont Render"
	]
	renderamt(integer) : "FX Amount (0 - 255)" : 255 : "The FX amount is used by the selected Render Mode."
	rendercolor(color255) : "FX Color (R G B)" : "255 255 255" : "The FX color is used by the selected Render Mode."
	
	viewhideflags(choices) : "View ID nodraw" : 0 : "This keyvalue can control whether an entity should only draw on things like monitors or mirrors, or the opposite. The code for this is { m_iViewHideFlags & (1 << CurrentViewID()) } and supports any combination of view IDs." =
	[
		0 : "[0] Draw normally"
		193 : "[193] Hide in main view (player's eyes)" // VIEW_MAIN + VIEW_INTRO_CAMERA + VIEW_SHADOW_DEPTH_TEXTURE
		36 : "[36] Hide in cameras" // VIEW_MONITOR + VIEW_INTRO_PLAYER
		24 : "[24] Hide in mirrors/water" // VIEW_REFLECTION + VIEW_REFRACTION
		60 : "[60] Hide in cameras and mirrors/water" // VIEW_MONITOR + VIEW_INTRO_PLAYER + VIEW_REFLECTION + VIEW_REFRACTION
		2 : "[2] Hide in 3D skybox" // VIEW_3DSKY
		128 : "[128] Hide projected texture shadows" // VIEW_SHADOW_DEPTH_TEXTURE
	]

	disablereceiveshadows(choices) : "Disable Receiving Shadows" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	
	EFlags(choices) : "EFlags" : 0 : "Special internal entity flags normally only set by the code. Be careful with this keyvalue." =
	[
		131072 : "[131072] Pretend to be in skybox (always transmits to client)"
		33554432 : "[33554432] Don't block NPC LOS"
		134217728 : "[134217728] No dissolve"
		268435456 : "[268435456] No supercharged gravity gun ragdoll"
		1073741824 : "[1073741824] No gravity gun interaction at all"
	]

	input Alpha(integer) : "Sets the sprite's alpha (0 - 255)."
	input Color(color255) : "Sets the sprite's color (R G B)."
	
	input SetRenderMode(integer) : "Sets this entity's render mode."
	input SetRenderFX(integer) : "Sets this entity's render FX."
	input SetViewHideFlags(integer) : "Sets this entity's view ID nodraw flags (takes raw flag combination)."
	input AddEffects(integer) : "Adds an entity effect."
	input RemoveEffects(integer) : "Removes an entity effect."
	input EnableDraw(void) : "Draws an entity if it is not drawn. Equivalent to RemoveEffects > 32."
	input DisableDraw(void) : "Undraws an entity if it is drawn. Equivalent to AddEffects > 32."
	input AddEFlags(integer) : "Adds an entity flag. NOTE: Entity flags are not the spawn flags you see in Hammer. Use AddSpawnFlags to add spawnflags."
	input RemoveEFlags(integer) : "Removes an entity flag. NOTE: Entity flags are not the spawn flags you see in Hammer. Use RemoveSpawnFlags to remove spawnflags."
	
	// This is the closest I could get without putting this in Targetname, as most entities that use collision groups usually use render fields as well
	input SetCollisionGroup(integer) : "Sets this entity's collision group."
]


// Inherit from this to get the ability to only include an object in a range of dx levels.
// NOTE!!: MAKE SURE THAT YOU DON'T USE THIS WITH ANYTHING THAT WILL BREAK SAVE-GAMES SWITCHING
// BETWEEN DXLEVELS!!!!
@BaseClass = DXLevelChoice
[ 
	mindxlevel(choices) : "Minimum DX Level" : 0 = 
	[
		0 : "default (lowest)"
		70 : "dx7"
		80 : "dx8.0 (4600Ti)"
		81 : "dx8.1 (FX5200)"
		90 : "dx9 SM2.0"
		95 : "dx9 SM3.0"
	]
	maxdxlevel(choices) : "Maximum DX Level" : 0 = 
	[
		0 : "default (highest)"
		60 : "dx6"
		70 : "dx7"
		80 : "dx8.0 (4600Ti)"
		81 : "dx8.1 (FX5200)"
		90 : "dx9 SM2.0"
		95 : "dx9 SM3.0"
	]
]

@BaseClass = Inputfilter
[
	InputFilter(choices) : "Input Filter" : 0 : "Used to specify which inputs this entity will accept." =
	[
		0 : "Allow all inputs"
		8 : "Ignore Touch/Untouch"
		16 : "Ignore Use"
		32 : "Ignore All"
	]
]

@BaseClass = Global 
[ 
	globalname(string) : "Global Entity Name" : "" : "Name by which this entity is linked to another entity in a different map. When the player transitions to a new map, entities in the new map with globalnames matching entities in the previous map will have the previous map's state copied over their state."
]

// Base class for env_global
@BaseClass base(Targetname) = EnvGlobal : 
	"An entity to control a global game state, with an optional associated counter, that persists across level transitions."
[
	initialstate(choices) : "Initial State" : 0 =
	[
		0 : "Off"
		1 : "On"
		2 : "Dead"
	]
	
	counter(integer) : "Counter" : 0 : "An integer counter value associated with this global."

	spawnflags(flags) =
	[
		1 : "[1] Set Initial State" : 0
	]

	// Inputs
	input TurnOn(void) : "Set state of global to ON."
	input TurnOff(void) : "Set state of global to OFF."
	input Toggle(void) : "Toggles state of global between ON and OFF."
	input Remove(void) : "Set state of global to DEAD."
	input SetCounter(integer) : "Sets the counter value of this global."
	input AddToCounter(integer) : "Adds to the counter value of this global. Negative numbers subtract."
	input GetCounter(void) : "Causes the Counter output to be fired, passing the current counter value for this global."

	// Outputs
	output OutCounter(integer) : "Fired in response to the GetCounter input, passing the current value of the counter."
]

@BaseClass = DamageFilter
[
	damagefilter(filterclass) : "Damage Filter" : "" : "Name of the filter entity that controls which entities can damage us."
	input SetDamageFilter(target_destination) : "Sets the entity to use as damage filter. Pass in an empty string to clear the damage filter."
]

@BaseClass = ResponseContext
[
	// Inputs
	input AddContext(string) : "Adds a context to this entity's list of response contexts. The format should be 'key:value'."
	input RemoveContext(string) : "Remove a context from this entity's list of response contexts. The name should match the 'key' of a previously added context."
	input ClearContext(void) : "Removes all contexts in this entity's list of response contexts."

	// Pre-defined contexts at server startup time (set by mapper)
	ResponseContext(string) : "Response Contexts" : "" : "Response system context(s) for this entity. Format should be: 'key:value,key2:value2,etc'. When this entity speaks, the list of keys & values will be passed to the response rules system."
]

@BaseClass base(Targetname, DamageFilter, Shadow) = Breakable
[
	ExplodeDamage(float) : "Explosion Damage" : 0 : "If non-zero, when this entity breaks it will create an explosion that causes the specified amount of damage. See also 'Explosion Radius'."
	ExplodeRadius(float) : "Explosion Radius" : 0 : "If non-zero, when this entity breaks it will create an explosion with a radius of the specified amount. See also 'Explosion Damage'."
	PerformanceMode(choices) : "Performance Mode" : 0 : "Used to limit the amount of gibs produced when this entity breaks, for performance reasons." =
	[
		0 : "Normal"
		1 : "No Gibs"
		2 : "Full Gibs on All Platforms"
		3 : "Reduced gibs"
	]
	
	BreakModelMessage(string) : "Break Model Message" : "" : "If set, will use this break model message instead of the normal break behavior."

	// Inputs
	input Break(void) : "Breaks the breakable."
	input SetHealth(integer) : "Sets a new value for the breakable's health. If the breakable's health reaches zero it will break."
	input AddHealth(integer) : "Adds health to the breakable. If the breakable's health reaches zero it will break."
	input RemoveHealth(integer) : "Removes health from the breakable. If the breakable's health reaches zero it will break."
	input EnablePhyscannonPickup(void) : "Makes the breakable able to picked up by the physcannon."
	input DisablePhyscannonPickup(void) : "Makes the breakable not able to picked up by the physcannon."
	input SetMass(float) : "Set mass of this object."

	// Outputs	
	output OnBreak(void) : "Fired when this breakable breaks."
	output OnTakeDamage(void) : "Fired each time this breakable takes any damage."
	output OnHealthChanged(float) : "Fired when the health of this breakable changes, passing the new value of health as a percentage of max health, from [0..1]."
	output OnPhysCannonDetach(void) : "Fired when the physcannon has ripped this breakable off of the wall. Only fired if ACT_PHYSCANNON_DETACH is defined in the model this breakable is using."
	output OnPhysCannonAnimatePreStarted(void) : "Fired when this prop starts playing the Pre physcannon-pull activity, caused by the player trying to grab this prop with the physcannon. Only fired if the ACT_PHYSCANNON_ANIMATE_PRE activity is defined in the model this breakable is using."
	output OnPhysCannonAnimatePullStarted(void) : "Fired when this prop starts playing the physcannon-pull activity, caused by the player trying to grab this prop with the physcannon. Only fired if the ACT_PHYSCANNON_ANIMATE activity is defined in the model this breakable is using. If the prop has Pre pull anim, this will be fired after the Pre anim has finished playing."
	output OnPhysCannonPullAnimFinished(void) : "Fired when this prop has finished playing the physcannon-pull activity, caused by the player trying to grab this prop with the physcannon. Only fired if the ACT_PHYSCANNON_ANIMATE activity is defined in the model this breakable is using. If the prop has Pre & Post pull anims, this will be fired after the Post anim has finished playing."
	output OnPhysCannonAnimatePostStarted(void) : "Fired when this prop starts playing the Post physcannon-pull activity. Only fired if the ACT_PHYSCANNON_ANIMATE_POST activity is defined in the model this breakable is using."
]

@BaseClass base(Breakable, Parentname, Global) = BreakableBrush
[
	spawnflags(flags) =
	[
		1 : "[1] Only Break on Trigger" : 0
		2 : "[2] Break on Touch" : 0
		4 : "[4] Break on Pressure" : 0
		512: "[512] Break immediately on Physics" : 0
		1024: "[1024] Don't take physics damage" : 0
		2048: "[2048] Don't allow bullet penetration": 0
	]

	propdata(choices) : "Prop Data" : 0 : "Set to the best approximation of the size and material of this entity's brushes. If set, it will override this entity's health and damage taken from various weapons. See the propdata.txt file in the scripts directory of your MOD to get a detailed list of what each entry specifies." =
	[
		0 : "None"
		1 : "Wooden.Tiny"
		2 : "Wooden.Small"
		3 : "Wooden.Medium"
		4 : "Wooden.Large"
		5 : "Wooden.Huge"
		6 : "Metal.Small"
		7 : "Metal.Medium"
		8 : "Metal.Large"
		9 : "Cardboard.Small"
		10 : "Cardboard.Medium"
		11 : "Cardboard.Large"
		12 : "Stone.Small"
		13 : "Stone.Medium"
		14 : "Stone.Large"
		15 : "Stone.Huge"
		16 : "Glass.Small"
		17 : "Plastic.Small"
		18 : "Plastic.Medium"
		19 : "Plastic.Large"
		20 : "Pottery.Small"
		21 : "Pottery.Medium"
		22 : "Pottery.Large"
		23 : "Pottery.Huge"
		24 : "Glass.Window"
	]

	health(integer) : "Strength" : 1 : "Number of points of damage to take before breaking. 0 means don't break."
	material(choices) :"Material Type" : 0 : "Set to the material type of the brush. Used to decide what sounds to make when damaged, and what gibs to produce when broken." =
	[
		0: "Glass"
		1: "Wood"
		2: "Metal"		
		3: "Flesh"
		4: "CinderBlock"
		5: "Ceiling Tile"
		6: "Computer"
		7: "Unbreakable Glass"
		8: "Rocks"
		// 9: "Web(defunct)"
		10: "None"
	]
	explosion(choices) : "Gibs Direction" : 0 : "Used to decide which direction to throw gibs when broken." =
	[
		0: "Random"
		1: "Relative to Attack"
		2: "Use Precise Gib Dir"
	]

	gibdir(angle) : "Precise Gib Direction" : "0 0 0" : "Specifies the direction to throw gibs when this breakable breaks. Be sure to select Use Precise Gib Dir in the Gibs Direction field!"

	nodamageforces(choices) : "Damaging it Doesn't Push It" : 0 : "Used to determine whether or not damage should cause the brush to move." =
	[
		0: "No"
		1: "Yes"
	]

	// Inputs
	input EnableDamageForces(void) : "Damaging the entity applies physics forces to it."
	input DisableDamageForces(void) : "Damaging the entity does *not* apply physics forces to it."

	gibmodel(string) : "Gib Model" : "" : "Used by HL1Port to specify a custom gib model to break into, overriding the 'Material Type'."
	spawnobject(choices) : "Spawn On Break" : 0 : "When broken, an entity of the selected type will be created." =
	[
		1:	"item_battery"				
		2:	"item_healthkit"			
		3:	"item_ammo_pistol"			
		4:	"item_ammo_pistol_large"	
		5:	"item_ammo_smg1"			
		6:	"item_ammo_smg1_large"	
		7:	"item_ammo_ar2"			
		8:	"item_ammo_ar2_large"	
		9:	"item_box_buckshot"		
		10:	"item_flare_round"			
		11:	"item_box_flare_rounds"		
		12:	"item_ml_grenade"		
		13:	"item_smg1_grenade"			
		14:	"item_box_sniper_rounds"	
		15:	"unused1"			
		16:	"weapon_stunstick"		
		17:	"weapon_ar1"				
		18:	"weapon_ar2"			
		19:	"unused2"				
		20:	"weapon_ml"					
		21:	"weapon_smg1"				
		22:	"weapon_smg2"				
		23:	"weapon_slam"				
		24:	"weapon_shotgun"			
		25:	"weapon_molotov"
		26:	"item_dynamic_resupply"							
	]
	explodemagnitude(integer) : "Explode Magnitude" : 0 : "If non-zero, when this entity breaks it will create an explosion that causes the specified amount of damage."
	pressuredelay(float) : "Pressure Delay" : 0 : "Delay, in seconds, after 'broken' by pressure before breaking apart (allows for sound to play before breaking apart)."
]

@BaseClass base(Breakable) = BreakableProp
[
	spawnflags(flags) =
	[
		16 : "[16] Break on Touch" : 0
		32 : "[32] Break on Pressure" : 0
	]
	pressuredelay(float) : "Pressure Delay" : 0 : "Delay, in seconds, after 'broken' by pressure before breaking apart (allows for sound to play before breaking apart)."
	
	// Inputs
	input SetInteraction(integer) : "Adds an interaction to this entity."
	input RemoveInteraction(integer) : "Removes an interaction from this entity."
]

// Fields shared by both NPCs and players.
@BaseClass = CombatCharacterFields
[
	input HolsterWeapon(void) : "Forces the NPC/player to holster their weapon. Ignored if the NPC is scripting, if the NPC's weapon is already holstered, or if the NPC doesn't use weapons."
	input HolsterAndDestroyWeapon(void) : "Identical to HolsterWeapon, except the weapon is destroyed once it has been holstered and concealed."
	input UnholsterWeapon(string) : "Forces the NPC/player to draw their weapon. Ignored if the NPC is scripting, if the NPC's weapon is already drawn, or if the NPC doesn't use weapons. You can specify to unholster a specific weapon if they have it in their inventory."
	input SwitchToWeapon(string) : "Causes the NPC/player to instantly switch to the specified weapon. If they do not have the specified weapon in their inventory, it will be created."

	input PickupWeaponInstant(target_destination) : "Instantly picks up the specified weapon. This refers to a weapon entity in the world, not a weapon classname."
	input SetRelationship(target_destination) : "Changes this NPC/player's relationship with another entity or class. Format: <entityname/classname> <D_HT/D_FR/D_LI/D_NU> <priority>"
	input SetBloodColor(integer) : "Changes this entity's blood color based on the internal enum in shareddefs.h."
	
	output OnWeaponEquip(void) : "Fires when this NPC/player acquires a weapon through any means, including spawn equipment. Passes the weapon as the activator."
	output OnWeaponDrop(void) : "Fires when this NPC/player drops a weapon, including when they die."
	
	output OnKilledNPC(ehandle) : "Fires when we kill a NPC. Passes the victim."
	output OnKilledPlayer(ehandle) : "Fires when we kill a player. Passes the killed player." 
	output OnHealthChanged(float) : "Fired when the health of this entity changes, passing the new value of health as a percentage of max health, from [0..1]."
]

@BaseClass base(Targetname, Parentname, Angles, RenderFields, DamageFilter, ResponseContext, Shadow, CombatCharacterFields, StudiomodelBase) color(0 200 200) = BaseNPC
[
	target(target_destination) : "Target Path Corner" : : "If set, the name of a path corner entity that this NPC will walk to, after spawning."
	squadname(String) : "Squad Name" : : "NPCs that are in the same squad (i.e. have matching squad names) will share information about enemies, take turns attacking and covering each other, etc. Squads work differently from NPC to NPC and some don't support them by default."
	hintgroup(String) : "Hint Group" : "" : "Hint groups are used by NPCs to restrict their hint searching to a subset of the map's hint nodes. Only hint nodes with matching hint group names will be considered by this NPC."
	hintlimiting(choices) : "Hint Limit Nav" : 0 : "Limits NPC to using its specified hint group for navigation requests, but does not limit local navigation." =
	[
		0 : "No"
		1 : "Yes"
	]

	spawnflags(Flags) = 
	[
		1 : "[1] Wait Till Seen (No sensing until player sees me)" : 0
		2 : "[2] Gag (No IDLE sounds until angry)" : 0
		4 : "[4] Fall to ground (unchecked means *teleport* to ground)" : 1
		8 : "[8] Drop Healthkit (drops health vial on death)" : 0
		16 : "[16] Efficient - Don't acquire enemies or avoid obstacles" : 0
		128 : "[128] Wait For Script" : 0
		256 : "[256] Long Visibility/Shoot" : 0
		512 : "[512] Fade Corpse" : 1
		1024 : "[1024] Think outside PVS (allows AI to stay active outside of combat and PVS)" : 0
		2048 : "[2048] Template NPC (used by npc_maker, will not spawn; NOT used by point_template)" : 0
		4096 : "[4096] Do alternate collision/player avoidance (largely obsolete, use Start/StopScripting)" : 0
		8192 : "[8192] Don't drop weapons" : 0
		16384 : "[16384] Ignore player push (dont give way to player)" : 0
	]

	//initialidle(string) : "Initial Idle Activity" :: "Activity the NPC should use to idle until becomes alert"
	sleepstate(choices) : "Sleep State" : 0 : "Holds the NPC in stasis until specified condition. See also 'Wake Radius' and 'Wake Squad'." =
	[
		0 : "None"
		1 : "Waiting for threat"
		2 : "Waiting for PVS"
		3 : "Waiting for input, ignore PVS"
		4 : "Auto PVS"
		5 : "Auto PVS after PVS"
	]

	wakeradius(float) : "Wake Radius" : 0 : "Auto-wake if player within this distance"
	wakesquad(choices) : "Wake Squad" : 0 : "Wake all of the NPCs squadmates if the NPC is woken" =
	[
		0 : "No"
		1 : "Yes"
	]

	enemyfilter(filterclass) : "Enemy Filter" : "" : "Filter by which to filter potential enemies"
	
	ignoreunseenenemies(choices) : "Ignore unseen enemies" : 0 : "Prefer visible enemies, regardless of distance or relationship priority" = 
	[
		0 : "No"
		1 : "Yes"
	]

	physdamagescale(float) : "Physics Impact Damage Scale" : "1.0" : "Scales damage energy when this character is hit by a physics object. With a value of 0 the NPC will take no damage from physics."
	
	FriendlyFireOverride(choices) : "Friendly fire override" : 2 : "Overrides whether friendly fire is allowed on this NPC or not. 'Disabled' makes this NPC immune to damage from its allies. 'Enabled' makes this NPC vulnerable to damage from its allies, including players. 'Default' uses the NPC's settings and won't change anything." = 
	[
		0 : "Disabled"
		1 : "Enabled"
		2 : "Default (No override)"
	]
	
	SetDynamicInteractions(choices) : "Dynamic interactions enabled" : 2 : "Episodic only. Enables or disables dynamic interactions on this NPC, if it has them. If set to Default, only dynamic interactions from the original episodes (Alyx, vorts, etc.) will be enabled. If set to Yes, dynamic interactions introduced with Mapbase will be enabled as well. If set to No, this NPC will never perform dynamic interactions." = 
	[
		0 : "No"
		1 : "Yes"
		2 : "Default (No override)"
	]
	
	SetProficiencyOverride(choices) : "Proficiency override" : -1 : "Overrides this NPC's weapon proficiency." = 
	[
		-1 : "Default (No override)"
		0 : "Poor"
		1 : "Average"
		2 : "Good"
		3 : "Very Good"
		4 : "Perfect"
	]
	
	SetForceServerRagdoll(choices) : "Force server ragdoll" : 0 : "Forces this NPC to turn into a serverside prop_ragdoll instead of a clientside ragdoll when it dies." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	SpawnWithStartScripting(choices) : "Spawn with StartScripting" : 0 : "Spawns the NPC in the StartScripting state." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	BaseSpeedModifier(float) : "Speed Modifier" : "1.0" : "Multiplies how far a NPC travels while moving. Does not affect the animation itself."

	// Outputs
	output OnDamaged(void) : "Fired when this NPC takes damage."
	output OnDeath(void) : "Fired when this NPC is killed." 
	output OnHalfHealth(void) : "Fired when this NPC reaches half of its maximum health."
	output OnHearWorld(void) : "Fired when this NPC hears a sound (other than combat or the player)."
	output OnHearPlayer(void) : "Fired when this NPC hears the player."
	output OnHearCombat(void) : "Fired when this NPC hears combat sounds."
	output OnFoundEnemy(string) : "Fired when this NPC establishes line of sight to its enemy (outputs entity)."
	output OnLostEnemyLOS(void) : "Fired when this NPC loses line of sight to its enemy."
	output OnLostEnemy(void) : "Fired when this NPC loses its enemy. Usually due to the enemy being killed/removed, or because this NPC has selected a newer, more dangerous enemy."
	output OnFoundPlayer(string) : "Fired when this NPC establishes line of sight to its enemy, and that enemy is a player (outputs player entity)."
	output OnLostPlayerLOS(void) : "Fired when this NPC loses line of sight to its enemy, and that enemy is a player."
	output OnLostPlayer(void) : "Fired when this NPC loses its enemy, and that enemy was a player. Usually due to the enemy being killed/removed, or because this NPC has selected a newer, more dangerous enemy."
	output OnDamagedByPlayer(void) : "Fired when this NPC is hurt by a player."
	output OnDamagedByPlayerSquad(void) : "Fired when this NPC is hurt by a player OR by one of the player's squadmates."
	output OnDenyCommanderUse(void) : "Fired when this NPC has refused to join the player's squad."
	output OnSleep(void) : "Fired when this NPC enters a sleep state."
	output OnWake(void) : "Fired when this NPC comes out of a sleep state."
	output OnHolsterWeapon(string) : "Fired when the NPC holsters a weapon. Passes the weapon."
	output OnUnholsterWeapon(string) : "Fired when the NPC unholsters a weapon. Passes the weapon."
	output OnForcedInteractionStarted(void) : "Fired when the NPC starts a forced interaction."
	output OnForcedInteractionAborted(void) : "Fired when the NPC aborts a forced interaction for some reason (target NPC died, couldn't be pathed to, etc)"
	output OnForcedInteractionFinished(void) : "Fired when the NPC successfully finishes a forced interaction."
	output OnItemPickup(void) : "Fires when a NPC picks up an item, e.g. a citizen picking up a health kit or a scripted item picked up in response to PickupItem."
	output OnStateChange(integer) : "Fires when a NPC's state changes, outputting the new state. (1 = Idle, 2 = Alert, 3 = Combat...)"

	// Inputs
	input SetEnemyFilter(target_destination) : "Changes this NPC's enemy filter to the named filter."
	input SetHealth(integer) : "Set this NPC's health."
	input SetHealthFraction(float) : "Sets the NPC's health as a fraction of its max health."
	input SetBodyGroup(integer) : "HACK: Sets this NPC's body group (from 0 - n). You'd better know what you are doing!"
	input physdamagescale(float) : "Sets the value that scales damage energy when this character is hit by a physics object. NOTE: 0 means this feature is disabled for backwards compatibility."
	input Ignite(void) : "Ignite, burst into flames"
	input IgniteLifetime(float) : "Ignite, with a parameter lifetime."
	input IgniteNumHitboxFires(integer) : "Ignite, with a parameter number of hitbox fires."
	input IgniteHitboxFireScale(float) : "Ignite, with a parameter hitbox fire scale."
	input Break(void) : "Break, smash into pieces"
	input StartScripting(void) : "Enter scripting state. In this state, NPCs ignore a variety of stimulus that would make them break out of their scripts: They ignore danger sounds, ignore +USE, don't idle speak or respond to other NPC's idle speech, and so on."
	input StopScripting(void) : "Exit scripting state."
	input SetSquad(string) : "Set the name of this NPC's squad. It will be removed from any existing squad automatically. Leaving the parameter blank will remove the NPC from any existing squad."
	input Wake(void) : "Wakes up the NPC if it is sleeping."
	input ForgetEntity(target_destination) : "Clears out the NPC's knowledge of a named entity."
	input GagEnable(void) : "Turn on the NPC Gag flag. NPC won't speak outside of choreographed scenes."
	input GagDisable(void) : "Turn off the NPC Gag flag."
	input IgnoreDangerSounds(float) : "Ignore danger sounds for the specified number of seconds."
	input ForceInteractionWithNPC(target_destination) : "Force the NPC to use a dynamic interaction with another NPC. Parameter format: <target NPC name> <dynamic interaction name>"
	input UpdateEnemyMemory(target_destination) : "Update (or Create) this NPC's memory of an enemy and its location"
	
	input SetMoveType(integer) : "Sets this NPC's movetype."
	input AddCapabilities(integer) : "Adds capabilities to this NPC."
	input RemoveCapabilities(integer) : "Removes capabilities from this NPC."
	input SetCondition(integer) : "Sets a condition. Can use a condition's string ID or its integer."
	input RemoveCondition(integer) : "Removes a condition. Can use a condition's string ID or its integer."
	
	input GiveWeapon(string) : "Gives the NPC a weapon of the specified class name. They will drop their current weapon if it is not holstered."
	input GiveWeaponHolstered(string) : "Puts the weapon of the specified class name in the NPC's inventory. If they do not have a weapon equipped, they will unholster it when given the 'UnholsterWeapon' input or when they see an enemy."
	input DropWeapon(string) : "Forces the NPC to drop its current weapon in front of it. No animation will play."
	input ChangeWeapon(string) : "Causes the NPC to change to the specified weapon. They will holster their current weapon and unholster the specified weapon, creating it if they don't already have it."
	input PickupWeapon(target_destination) : "Causes the NPC to seek and pick up the specified weapon."
	input PickupItem(target_destination) : "Causes the NPC to seek and pick up the specified item."
	
	input SetFriendlyFire(integer) : "Overrides our friendly fire. 0 = No friendly fire, 1 = Friendly fire enabled, 2 = Default (No override)"
	input SetDynamicInteractions(integer) : "Sets whether we could use dynamic interactions. 0 = Disabled, 1 = Enabled, 2 = Default."
	input SetProficiencyOverride(integer) : "Sets our weapon's proficiency. Use integer."
	input SetForceServerRagdoll(bool) : "Sets whether we should be a serverside ragdoll when we die."
	
	input SetThinkNPC(float) : "Sets this entity's general think function to CallNPCThink. This is only necessary if it was disabled by SetThinkNull before."
	
	input SetDistLook(float) : "Manually sets this NPC's sight distance. Pass '0' to reset."
	input SetDistTooFar(float) : "Manually sets the distance in which NPCs will consider a target too far to attack. Pass '0' to reset."
	
	input SetSpeedModifier(float) : "Set a float value to multiply movement animation speed."
	
	input SetHintGroup(string) : "Sets this NPC's hint group."
]

@PointClass base(Targetname, Parentname, Angles) iconsprite("editor/info_target.vmt") = info_npc_spawn_destination : 
	"NPC Spawn Destination. (Consult npc_template_maker help for more info)"
[
	ReuseDelay(float) : "Reuse Delay" : 1 : "After an NPC is spawned at this destination, the delay before this destination is eligible for selection again."
	RenameNPC(string) : "New NPC Name" : "" : "If an NPC spawns at this destination, change that NPC's targetname to this."

	// Outputs
	output OnSpawnNPC(void) : "Fired when an NPC spawns at this destination."
]

@BaseClass base(Targetname, Angles, EnableDisable) iconsprite("editor/npc_maker.vmt") color(0 0 255) = BaseNPCMaker
[
	StartDisabled(choices) : "Start Disabled" : 1 =
	[
		0 : "No"
		1 : "Yes"
	]

	spawnflags(Flags) = 
	[
		// Only in npc__maker, npc_template_maker uses flag from template NPC
		16 : "[16] Fade Corpse" : 0
		32 : "[32] Infinite Children" : 0
		64 : "[64] Do Not Drop" : 0
		128 : "[128] Don't Spawn While Visible" : 0
	]

	MaxNPCCount(integer) : "Num. of NPCs" : 1 : "Number of NPCs that will spawn before this spawner is exhausted."
	SpawnFrequency(string) : "Frequency" : "5" : "How often (in seconds) a new NPC will be spawned. If set to -1, a new NPC will be made when the last NPC dies."
	MaxLiveChildren(integer) : "Max Live NPCs" : 5 : "Maximum number of live children allowed at any one time (new ones will not be made until one dies). If set to -1, no limit is applied."
	
	// Outputs
	output OnSpawnNPC(ehandle) : "Fired when an NPC is spawned. The activator is the NPC, and the parameter is a pointer to the NPC." 
	output OnAllSpawned(void) : "Fired when the spawned is exhausted (all children have been spawned)."
	output OnAllSpawnedDead(void) : "Fired when the spawner is exhausted (all children have been spawned) and all spawned children have died."
	output OnAllLiveChildrenDead(void) : "Fired when all spawned children have died. This does not mean the spawned is exhausted, so a new child may be spawned any time after this (unless the maker is disabled)."

	// Inputs
	input Spawn(void) : "Spawns an NPC."
	input Toggle(void) : "Toggles the spawner enabled/disabled state."
	input Enable(void) : "Enables the spawner."
	input Disable(void) : "Disables the spawner."
	input AddMaxChildren(integer) : "Adds to the number of NPCs that can spawn before the spawner is exhausted. If an exhausted spawner is given some children to spawn, it still wont begin spawning until it is re-enabled with the Enable input."
	input SetMaxChildren(integer) : "Sets the number of NPCs that can spawn before the spawner is exhausted. If an exhausted spawner is given some children to spawn, it still won't begin spawning until it is re-enabled with the Enable input."
	input SetMaxLiveChildren(integer) : "Sets the maximum number of NPCs that can be alive at any one time from this spawner."
	input SetSpawnFrequency(float) : "Sets how often (in seconds) a new NPC will be spawned."
]

@PointClass base(BaseNPCMaker) iconsprite("editor/npc_maker.vmt") sphere(Radius) sphere(MinSpawnDistance) = npc_template_maker : 
	"An entity that creates NPCs. The NPCs it creates are clones of a template NPC. NPCs are spawned around this maker's origin, or at specified destination points."
[
	spawnflags(Flags) = 
	[
		256 : "[256] Always use radius spawn" : 0
		512 : "[512] Don't preload template models" : 0
	]

	TemplateName(target_destination) : "Name of template NPC" : "" : "Template NPC that this maker should be creating clones of."

	Radius(float) : "Radius" : 256 : "Radius around this maker within which NPCs are to be placed. Spawned NPCs will try and find empty space within this radius to spawn."

	DestinationGroup(target_destination) : "Name of Destination Group" : : "If you'd like spawned NPCs to be created at an info_npc_spawn_destination entity, enter the name of that entity here. If you have more than one destination entity by that name, the Destination Criteria will be used to select one from the group."
	CriterionVisibility(Choices) : "Dest. Criterion: Visible to player?" : 2 : "Should the NPC try to spawn at a destination that the player can see? Only applicable if a Destination Group is being used." =
	[
		0 : "Yes"
		1 : "No"
		2 : "Don't Care"
	]
	CriterionDistance(Choices) : "Dest. Criterion: Distance to player?" : 2 : "Should the NPC try to spawn nearest to or farthest from the player's current location? Only applicable if a Destination Group is being used." =
	[
		0 : "Nearest"
		1 : "Farthest"
		2 : "Don't Care"
	]

	MinSpawnDistance(integer) : "Minimum spawn distance from player" : 0 : "The spawn destination node distance to the player will have to be further or equal than this value."

	//Inputs
	input SpawnNPCInRadius(void) : "Spawn an NPC somewhere within the maker's radius."
	input SpawnNPCInLine(void) : "Spawn an NPC somewhere within a line behind the maker."
	input SpawnMultiple(integer) : "Spawn multiple NPCs (uses destination group, else radius)."
	input ChangeDestinationGroup(target_destination) : "Switch to a different set of Destination entities."
	input SetMinimumSpawnDistance(integer) : "Set the minimum spawn distance from player to destination node."
]

@BaseClass base( BaseNPC ) = BaseHelicopter
[
	InitialSpeed(string) : "Initial Speed" : "0" : "Sets the helicopter's desired speed that it should try to reach as soon as it's spawned."
	target(target_destination) : "Target path_track" : : "(Optional) The name of a path_track entity that this NPC will fly to after spawning."
	
	AllowAnyDamage(Choices) : "Allows any damage" : 0 : "Allows this NPC to take any amount of any type of damage, including bullet or melee damage. This is supposed to allow this NPC to be taken down in a previously impossible way and should be used with an actual damage filter." =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input MoveTopSpeed(void) : "The helicopter will immediately move at top speed toward its current goal, or in its current orientation if it's on top of its goal."
	input MoveSpecifiedSpeed(float): "The helicopter will immediately move at the specified speed (you provide this as parameter override in units per second) towards its current goal."
	input ChangePathCorner(target_destination) : "Tell the helicopter to move to a path corner on a new path."
	input SelfDestruct(void) : "Self Destruct."
	input Activate(void) : "Activate. Use to wake up a helicopter that spawned with the 'Await Input' spawnflag on."
	input SetTrack(target_destination) : "Set a track for the helicopter to adhere to. The helicopter will do nothing if he's on the same path, and will move to the closest point on the specified track if he's on a different path."
	input FlyToSpecificTrackViaPath(target_destination) : "The helicopter will first fly to the closest point on the path if he's on a different path. Then he'll fly along the path to the specified track point."
	input StartPatrol(void) : "Start patrolling back and forth along the current track."
	input StopPatrol(void) : "Stop patrolling back and forth along the track. This will cause the helicopter to come to rest at the track which he's currently flying toward."
	input ChooseFarthestPathPoint(void) : "When tracking an enemy, choose the point on the path furthest from the enemy, but still in firing range."
	input ChooseNearestPathPoint(void) : "When tracking an enemy, choose the point on the path nearest from the enemy."
	input StartBreakableMovement(void) : "The helicopter is now allowed to disobey direct commands to go to particular points if he senses an enemy. He will move to the closest point (or farthest point, if ChooseFarthestPathPoint is used), on the path if he senses an enemy."
	input StopBreakableMovement(void) : "The helicopter can not disobey direct commands. He will continue to fly along his patrol path or to his specified target even if he senses an enemy."

	spawnflags(Flags) =
	[
		// AWAIT INPUT will make the helicopter spawn disabled, awaiting 
		// the "Activate" input to start acting.
		32 : "[32] No Rotorwash" : 0
		64 : "[64] Await Input" : 0
	]
]

@NPCClass base(BaseHelicopter, Studiomodel) studioprop() = npc_helicopter_custom : "A custom helicopter. It can't attack. Aww..."
[
	model(studio) : "World Model" : "models/combine_helicopter.mdl" : "Should probably still have the right attachments."

	MaxSpeed(float) : "Max Speed" : "1056" : "The helicopter's maximum speed."
	//MaxFiringSpeed(float) : "Max Firing Speed" : "" : "The helicopter's maximum firing speed...you know, if it could DO THAT!"
	
	Acceleration(float) : "Acceleration" : "5.0" : "The helicopter's acceleration rate."
	
	RotorSound(sound) : "Rotor Sound" : "NPC_AttackHelicopter.Rotors" : "The helicopter's looping rotor sound. Supports Game Sounds and direct filenames."
	RotorBlast(sound) : "Rotor Blast" : "NPC_AttackHelicopter.RotorBlast" : "The helicopter's rotor blast sound, which plays when the helicopter is pushing away physics objects under it. Supports Game Sounds and direct filenames."
]

@BaseClass color(0 255 0) = PlayerClass []

@BaseClass color(180 10 180) = Light
[
	_light(color255) : "Brightness" : "255 255 255 200"
	_lightHDR(color255) : "BrightnessHDR" : "-1 -1 -1 1"
	_lightscaleHDR(float) : "BrightnessScaleHDR" : "1" : "Amount to scale the light by when compiling for HDR."
	style(Choices) : "Appearance" : 0 =
	[
		0 : "Normal"
		10: "Fluorescent flicker"
		2 : "Slow, strong pulse"
		11: "Slow pulse, noblack"
		5 : "Gentle pulse"
		1 : "Flicker A"
		6 : "Flicker B"
		3 : "Candle A"
		7 : "Candle B"
		8 : "Candle C"
		4 : "Fast strobe"
		9 : "Slow strobe"
	]
	pattern(string) : "Custom Appearance" : "" : "Set a custom pattern of light brightness for this light. Pattern format is a string of characters, where 'a' is total darkness, 'z' fully bright. i.e. 'aaggnnttzz' would be a steppy fade in from dark to light."
	_constant_attn(string)	: "Constant" : "0"
	_linear_attn(string)	: "Linear" : "0"
	_quadratic_attn(string)	: "Quadratic" : "1"
	_fifty_percent_distance(string) : "50 percent falloff distance" : "0": "Distance at which brightness should fall off to 50%. If set, overrides linear constant and quadratic paramaters."
	_zero_percent_distance(string) : "0 percent falloff distance" : "0": "Distance at which brightness should fall off to negligible (1/256)%. Must set _fifty_percent_distance to use."
	_hardfalloff(integer) : "Hard falloff" : 0 : "If set, causes lights to fall to exactly zero beyond the zero percent distance. May cause unrealistic lightijng if not used carefully."
	// Inputs
	input TurnOn(void) : "Turn the light on."
	input TurnOff(void) : "The the light off."
	input Toggle(void) : "Toggle the light's current state."
	input SetPattern(string) : "Set a custom pattern of light brightness for this light. Pattern format is a string of characters, where 'a' is total darkness, 'z' fully bright. i.e. 'aaggnnttzz' would be a steppy fade in from dark to light."
	input FadeToPattern(string) : "Fades from first value in old pattern, to first value in the new given pattern. Pattern format is a string of characters, where 'a' is total darkness, 'z' fully bright. i.e. 'aaggnnttzz' would be a steppy fade in from dark to light."
]

@BaseClass = Node 
[
	nodeid(integer) readonly : "Node ID"
]

@BaseClass base(Node) = HintNode 
[
	spawnflags(flags) = 
	[
		65536: "[65536] Allow jump up" : 0
	]
	
	hinttype(choices) : "Hint" : 0 = 
	[
		  0 : "None"

		  2: "World: Window"
		 12: "World: Act Busy Hint"
		 13: "World: Visually Interesting"
		 14: "World: Visually Interesting (Don't aim at)"
		 15: "World: Inhibit Combine Mines within 15 feet"
		 16: "World: Visually Interesting (Stealth mode)"

		100: "Crouch Cover Medium"
		101: "Crouch Cover Low"
		//102: "Waste Scanner Spawn"
		103: "Entrance / Exit Pinch"
//		104: "Guard Point"
		105: "Enemy Disadvantage Point"
		//106: "Health Kit"

		400: "Antlion: Burrow Point"
		401: "Antlion: Thumper Flee Point"

		450: "Headcrab: Burrow Point"
		451: "Headcrab: Exit Pod Point"

		//500: "Roller: Patrol Point"
		//501: "Roller: Cleanup Spot"

		700: "Crow: Fly to point"
		701: "Crow: Perch point"

		900: "Follower: Wait point"
		901: "Override jump permission"
		902: "Player squad transition point"
		903: "NPC exit point"
		904: "Strider node"

		950: "Player Ally: Push away destination"
		951: "Player Ally: Fear withdrawal destination"

		1000: "HL1 World: Machinery"
		1001: "HL1 World: Blinking Light"
		1002: "HL1 World: Human Blood"
		1003: "HL1 World: Alien Blood"
	
//		1100: "CS Hostage: Escape Point"

		10000: "Mapbase - Custom Cover (Use hint activity)"
	]

	hintactivity(string) : "Hint Activity" : "" : "Activity associated with this hint node. Various parts of the NPC AI play this activity at times. i.e. Actbusy nodes will play this activity when an NPC acts busy on the node."

	nodeFOV(choices) : "Node FOV" : 180 : "Imagine this node requires that an NPC be in the node's field of view in order to use this hint." =
	[
		45 : "45 Degrees"
		90 : "90 Degrees"
		180 : "180 Degrees"
		360 : "360 Degrees"
	]

	// Does not inherit from EnableDisable, as node itself will
	// use that.  This is enabling/disabling of the hint only
	StartHintDisabled(choices) : "Start Hint Disabled" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	Group(string) : "Hint Group" : "" : "If specified, gives the hint a specific group name. NPCs may refuse to use hint nodes that don't match their hint group. Also useful for hints that need to be logically grouped together. Wildcards are supported."

    TargetNode(node_dest) : "Target node" : -1 : "The node ID of an associated target node, if any. This can be used if the hint node acts as a path_corner, or for overriding jumping permission."

	radius(integer) : "Radius" : 0 : "How close an NPC must be to consider this hint. 0 means infinite."
	
	hintweight(float) : "Hint Weight" : "1.0" : "Multiplies the hint's importance, giving it a specific priority over closer hints or nodes."
	
	IgnoreFacing(choices) : "Ignore Facing" : 2 : "Don't pay attention to the facing of the node. May not apply to a given hint type." =
	[
		0 : "No"
		1 : "Yes"
		2 : "Default"
	]

	MinimumState(choices) : "Minimum State" : 1 : "Require an NPC have a minimum state to use the hint." =
	[
		1 : "Idle"
		2 : "Alert"
		3 : "Combat"
	]

	MaximumState(choices) : "Maximum State" : 3 : "Require an NPC have a maximum state to use the hint." =
	[
		1 : "Idle"
		2 : "Alert"
		3 : "Combat"
	]

	// Inputs
	input EnableHint(void) : "Enable hint."
	input DisableHint(void) : "Disable hint."
	
	input SetHintGroup(string) : "Sets this hint's group."
]

@BaseClass base(Targetname, Parentname, Origin, EnableDisable, Global) = TriggerOnce
[
	spawnflags(flags) = 
	[
		1: "[1] Clients" : 1
		2: "[2] NPCs" : 0
		4: "[4] Pushables": 0
		8: "[8] Physics Objects" : 0
		8192: "[8192] Items (weapons, items, projectiles)" : 0
		16: "[16] Only player ally NPCs" : 0
		32: "[32] Only clients in vehicles" : 0
		64: "[64] Everything (not including physics debris)" : 0
		512: "[512] Only clients *not* in vehicles" : 0
		1024: "[1024] Physics debris" : 0
		2048: "[2048] Only NPCs in vehicles (respects player ally flag)" : 0
		4096: "[4096] Disallow Bots" : 0
	]

	filtername(filterclass) : "Filter Name" : : "Filter to use to see if activator triggers me. See filter_activator_name for more explanation."

	// Inputs
	input Toggle(void) : "Toggles this trigger between enabled and disabled states."

	// Outputs
	output OnStartTouch(void) : "Fired when an entity starts touching this trigger. The touching entity must pass this trigger's filters to cause this output to fire."
]

@BaseClass base(Targetname, Parentname, Origin, EnableDisable, TriggerOnce) = Trigger
[
	// Inputs
	input TouchTest(void) : "Tests if the trigger is being touched and fires an output based on whether the value is true or false." 
	 
	// Outputs
	output OnTouching(void) : "Fired when the TestTouch input is true (something is touching the trigger.)"
	output OnNotTouching(void) : "Fired when the TestTouch input is not true (nothing is touching the trigger.)"

	output OnStartTouchAll(void) : "Fired when an entity starts touching this trigger, and no other entities are touching it. Only entities that passed this trigger's filters are considered."
	output OnEndTouch(void) : "Fired when an entity stops touching this trigger. Only entities that passed this trigger's filters will cause this output to fire."
	output OnEndTouchAll(void) : "Fires when an entity stops touching this trigger, and no other entities are touching it. Only entities that passed this trigger's filters are considered."
]

@BaseClass = worldbase
[
	message(string) : "Map Description / Title" : : "A description/title for your map. This is not used in the code, but it's saved in the VMF and can be used for metadata purposes."
	skyname(string) : "SkyBox Texture Name" : "sky_day01_01"
	chaptertitle(string) : "Chapter/Savegame Title" : "" : "A ''chapter'' title that this map should identify with. Outside of Mapbase, this is used to make the chapter title appear onscreen when the level starts, but now it can change the message seen in the save/load menus, can be seen in Discord RPC, and the onscreen message behavior is now disabled by default (doesn't affect existing maps) through the ''Display Chapter Title Message'' keyvalue."
	chaptertitlenomessage(choices) : "Display Chapter Title Message" : 1 : "Controls whether the Chapter Title Message should show up in a generated env_message when the map loads or whether it should only be used for savegame comments and RPC. This would normally be set to ''Yes'' outside of Mapbase." = 
	[	
		0 : "Yes"
		1 : "No"
	]
	newunit(choices) : "New Level Unit" : 0 : "Used to clear out savegame data of previous levels to keep the savegame size as small as possible. Only set it to Yes if the player cannot return to any previous levels." = 
	[
		0 : "No, keep current"
		1 : "Yes, clear previous levels"
	]
	maxoccludeearea(float) : "Max occludee area" : "0" : "[Used on PC] Prevents occlusion testing for entities that take up more than X% of the screen." 
	minoccluderarea(float) : "Min occluder area" : "0" : "[Used on PC] Prevents occluders from being used if they take up less than X% of the screen." 
	maxoccludeearea_x360(float) : "Max occludee area (Xbox)" : "0" : "[Used on 360] Prevents occlusion testing for entities that take up more than X% of the screen." 
	minoccluderarea_x360(float) : "Min occluder area (Xbox)" : "0" : "[Used on 360] Prevents occluders from being used if they take up less than X% of the screen." 
	maxpropscreenwidth(float) : "Start Fade Pixels" : -1 : "Number of pixels wide at which all props in the level start to fade (<0 = use fademaxdist). This number is ignored if the prop has a specific fade distance specified."
	minpropscreenwidth(float) : "End Fade Pixels" : 0 : "Minimum number of pixels wide at which the prop is visible (0 = don't fade out). This number is ignored if the prop has a specific fade distance specified."
	detailvbsp(string) : "Detail.vbsp file" : "detail.vbsp" : "Detail.vbsp file to use for emitting detail props (found in directory <root>/modname)"
	detailmaterial(string) : "Detail material file" : "detail/detailsprites" : "Material for detail sprites to use for drawing detail props"
	vscriptlanguage(choices) : "VScript language (Server)" : 0 : "Sets the script language this map should use for entity scripts on the server." =
	[	
		-1 : "None (Disable VScript)"
		0 : "Default (Squirrel)"
		//1 : "GameMonkey (Unsupported)"
		2 : "Squirrel"
		//3 : "Lua (Unsupported)"
		//4 : "Python (Unsupported)"
	]
	vscriptlanguage_client(choices) : "VScript language (Client)" : -2 : "Sets the script language this map should use for entity scripts on the client." =
	[	
		-2 : "Use Server language"
		-1 : "None (Disable VScript)"
		0 : "Default (Squirrel)"
		//1 : "GameMonkey (Unsupported)"
		2 : "Squirrel"
		//3 : "Lua (Unsupported)"
		//4 : "Python (Unsupported)"
	]
	startdark(choices) : "Level Fade In" : 0 =
	[	
		0 : "No"
		1 : "Yes"
	]
	gametitle(choices) : "Display Game Title" : 0 : "Game Title that appears onscreen when this level starts." = 
	[	
		0 : "No"
		1 : "Yes"
	]
	coldworld(choices) : "World is cold" : 0 =
	[	
		0 : "No"
		1 : "Yes"
	]
	
	// Inputs
	input SetChapterTitle(string) : "Sets the chapter title this map should identify with."
]


//-------------------------------------------------------------------------
//
// World
//
//-------------------------------------------------------------------------

@SolidClass base(Targetname, worldbase, ResponseContext) = worldspawn : 
	"This is the world entity. Each map can only contain one, and it's automatically created for you."
[
]

@PointClass base(Targetname, Parentname) iconsprite("editor/ambient_generic.vmt") sphere(radius) = ambient_generic : "Universal ambient sound. Use it to play and control a single sound."
[
	message(sound) : "Sound Name" : "" : "Name of the GameSound entry for the sound to play. Also supports direct .wav filenames."
	health(integer) : "Volume" : 10 : "Sound volume, expressed as a range from 0 to 10, where 10 is the loudest."
	preset(choices) :"Dynamic Presets" : 0 =						// NEEDHELP
	[
		0: "None"
		1: "Huge Machine"
		2: "Big Machine"
		3: "Machine"
		4: "Slow Fade in"  
		5: "Fade in"
		6: "Quick Fade in"
		7: "Slow Pulse"
		8: "Pulse"
		9: "Quick pulse"
		10: "Slow Oscillator"
		11: "Oscillator"
		12: "Quick Oscillator"
		13: "Grunge pitch"
		14: "Very low pitch"
		15: "Low pitch"
		16: "High pitch"
		17: "Very high pitch"
		18: "Screaming pitch"
		19: "Oscillate spinup/down"
		20: "Pulse spinup/down"
		21: "Random pitch"
		22: "Random pitch fast"
		23: "Incremental Spinup"
		24: "Alien"
		25: "Bizzare"
		26: "Planet X"
		27: "Haunted"
	]
	volstart(integer) : "Start Volume" : 0							// NEEDHELP
	fadeinsecs(integer) : "Fade in time in seconds (0-100)" : 0		// NEEDHELP
	fadeoutsecs(integer) : "Fade out time in seconds (0-100)" : 0	// NEEDHELP
	pitch(integer) : "Pitch" : 100 : "Sound pitch, expressed as a range from 1 to 255, where 100 is the sound's default pitch."
	pitchstart(integer) : "Start Pitch" : 100						// NEEDHELP
	spinup(integer) : "Spin up time (0-100)" : 0					// NEEDHELP
	spindown(integer) : "Spin down time (0-100)" : 0				// NEEDHELP
	lfotype(integer) : "LFO type 0)off 1)sqr 2)tri 3)rnd" : 0		// NEEDHELP
	lforate(integer) : "LFO rate (0-1000)" : 0						// NEEDHELP
	lfomodpitch(integer) : "LFO mod pitch (0-100)" : 0				// NEEDHELP
	lfomodvol(integer) : "LFO mod vol (0-100)" : 0					// NEEDHELP
	cspinup(integer) : "Incremental Spinup Count" : 0				// NEEDHELP
	radius(string) : "Max Audible Distance" : "1250" : "Maximum distance at which this sound is audible."
	spawnflags(flags) =
	[
		1 : "[1] Play everywhere" : 0
		16 : "[16] Start Silent": 1
		32 : "[32] Is NOT Looped": 1
	]
	soundflags(choices) :"Sound Flags" : 0 : "Additional options for your sound." =
	[
		0: "None"
		128: "[128] Pause when game is paused"
		256: "[256] Ignore phonemes (no lip-syncing)"
		1024: "[1024] Don't overwrite existing sound on channel (untested)"
	]
	SourceEntityName(target_destination) : "SourceEntityName" : : "If an entity is specified, sound will come from this named entity instead of the location of ambient_generic."

	// Inputs
	input Pitch(integer) : "Sets the sound pitch, expressed as a range from 1 to 255, where 100 is the sound's default pitch."
	input PlaySound(void) : "Starts the sound."
	input StopSound(void) : "Stops the sound if it is playing."
	input ToggleSound(void) : "Toggles the sound between playing and stopping."
	input Volume(integer) : "Sets the sound volume, expressed as a range from 0 to 10, where 10 is the loudest."
	input FadeIn(integer) : "Fades the sound up to full volume over a specified number of seconds, with a range from 0 to 100 seconds."
	input FadeOut(integer) : "Fades the sound to silence over a specified number of seconds, with a range from 0 to 100 seconds."
	input SetSound(string) : "Sets the sound this ambient_generic should play."
	
	output OnSoundFinished(void) : "Fires when the sound finishes playing. NOTE: This sound should be set to pause when the game is paused."
]

@SolidClass base(Targetname, Parentname, RenderFields) sphere(DisappearDist) sphere(DisappearMaxDist) = func_lod : 
	"Brush-built model that fades out over a specified distance. Useful for creating world detail that doesn't need to be drawn far away, for performance reasons."
[
	DisappearDist(integer)    : "Disappear Distance" : 2000 : "Distance at which these brushes should start to fade out."
	DisappearMaxDist(integer)    : "Maximum Disappear Distance" : 0 : "If specified, this would be distance at which these brushes should fade out completely. If 0, it will combine the regular disappear distance with the value stored in the 'lod_TransitionDist' convar, which is 800 by default."
	Solid(choices) : "Solid" : 0 : "Set whether or not these brushes should collide with other entities." =
	[
		0: "Solid"
		1: "Nonsolid"
	]
]

@PointClass base(Targetname) frustum(FOV,4,250,250 250 250,-1) = env_zoom : 
	"An entity that can be used to control the player's FOV. Useful for scenes where the player's view is being controlled, or player-usable binoculars/telescopes, etc."
[
	Rate(float) : "Seconds to reach target" : "1.0" : "Amount of time it should take to reach the specified FOV."
	FOV(integer) : "Target FOV" : 75 : "FOV that this entity should set the player's FOV to when active."

	// Inputs
	input Zoom(void) : "Start controlling the player's FOV."
	input UnZoom(void) : "Stop controlling the player's FOV."
	input UnZoomWithRate(void) : "Stop controlling the player's FOV and returns to the original FOV with the same rate it used to reach it."
	input SetZoomRate(float) : "Sets the amount of time it should take to reach the specified FOV."

	spawnflags(flags) =
	[
		1: "[1] Allow Suit Zoom" : 0
	]
]

@PointClass base(Targetname) = env_screenoverlay: 
	"An entity that can display and control a set of screen overlays, to be displayed over the player's view. Useful for view effects like drunkenness, or teleporter afterimages, etc."
[
	OverlayIndex(integer) : "Overlay Index" : -1 : "If this value is set to a number between 0 and 9, this overlay will use one of Mapbase's indexed overlay slots. Overlays in different slots will display on the screen at the same time."
	
	OverlayName1(material) : "Overlay Name 1" : "" : "Name of the first overlay material to display."
	OverlayTime1(float) : "Overlay Duration 1" : "1.0" : "Amount of time that the first overlay should be displayed for, after which it will begin showing the second overlay."
	OverlayName2(material) : "Overlay Name 2" : "" : "Name of the second overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime2(float) : "Overlay Duration 2" : "1.0" : "Amount of time that the second overlay should be displayed for, after which it will begin showing the third overlay."
	OverlayName3(material) : "Overlay Name 3" : "" : "Name of the third overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime3(float) : "Overlay Duration 3" : "1.0" : "Amount of time that the third overlay should be displayed for, after which it will begin showing the fourth overlay."
	OverlayName4(material) : "Overlay Name 4" : "" : "Name of the fourth overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime4(float) : "Overlay Duration 4" : "1.0" : "Amount of time that the fourth overlay should be displayed for, after which it will begin showing the fifth overlay."
	OverlayName5(material) : "Overlay Name 5" : "" : "Name of the fifth overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime5(float) : "Overlay Duration 5" : "1.0" : "Amount of time that the fifth overlay should be displayed for, after which it will begin showing the sixth overlay."
	OverlayName6(material) : "Overlay Name 6" : "" : "Name of the sixth overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime6(float) : "Overlay Duration 6" : "1.0" : "Amount of time that the sixth overlay should be displayed for, after which it will begin showing the seventh overlay."
	OverlayName7(material) : "Overlay Name 7" : "" : "Name of the seventh overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime7(float) : "Overlay Duration 7" : "1.0" : "Amount of time that the seventh overlay should be displayed for, after which it will begin showing the eighth overlay."
	OverlayName8(material) : "Overlay Name 8" : "" : "Name of the eighth overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime8(float) : "Overlay Duration 8" : "1.0" : "Amount of time that the eighth overlay should be displayed for, after which it will begin showing the ninth overlay."
	OverlayName9(material) : "Overlay Name 9" : "" : "Name of the ninth overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime9(float) : "Overlay Duration 9" : "1.0" : "Amount of time that the ninth overlay should be displayed for, after which it will begin showing the tenth overlay."
	OverlayName10(material) : "Overlay Name 10" : "" : "Name of the tenth overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime10(float) : "Overlay Duration 10" : "1.0" : "Amount of time that the tenth overlay should be displayed for, after which this entity will stop displaying overlays."

	// Inputs
	input	StartOverlays(void) : "Start displaying the first overlay."
	input	StopOverlays(void) : "Stop displaying any overlays."
	input	SwitchOverlay(float) : "Switch to displaying a specific overlay. Pass in the desired overlay number in the parameter."
]

@PointClass base(Targetname) = env_screeneffect :
	"Allows screenspace effects to be played on the player's view."
[
	type(choices) : "Effect Type" : 0 : "Which effect to use." =
	[
		0 : "Advisor Stun"
		1 : "Intro Blur"
		2 : "Groggy Vision"
	]

	// Inputs
	input	StartEffect(float) : "Start the effect with the duration in seconds as the passed parameter."
	input   StopEffect(float) : "Stop the effect."
]

@PointClass base(Targetname) = env_texturetoggle : 
	"An entity that allows you to change the textures on other brush-built entities."
[
	target(target_destination) : "Target Brush(es)." 

	// Inputs
	input	IncrementTextureIndex(void) : "Increments target brush's current texture frame by one."
	input	SetTextureIndex(integer) : "Sets target brush's texture frame to the specified index."
]

@PointClass base(Targetname, Angles) = env_splash : 
	"An entity that creates a splash effect at its origin. If the 'find water surface' spawnflag is set, it will instead trace down below itself to find the water surface on which to create splashes."
[
	scale(float) : "Scale of the splash" : "8.0"

	// Inputs
	input Splash(void) : "Create a splash effect."

	spawnflags(flags) =
	[
		1: "[1] Automatically find water surface (place entity above water)" : 0
		2: "[2] Diminish with depth (diminished completely in 10 feet of water)" : 1
	]
]

@PointClass base(Parentname) color(180 10 180) = env_particlelight : 
	"An entity that can be used to light the smoke particles emitted by env_smokestack entities. Does not light any other particle types."
[
	Color(color255) : "Color" : "255 0 0" : "Color emitted by this light." 
	Intensity(integer) : "Intensity" : 5000

	directional(choices) : "Directional" : 0 : "If this is specified, then this light will use the bump map on the particles. Each particle system can have one ambient and one directional light." =
	[
		0 : "No"
		1 : "Yes"
	]

	PSName(target_destination) : "Particle System Entity" : "" : "Set this to the name of the env_smokestack that you want this light to affect."
]

@PointClass base(Targetname, Angles) color(255 0 0) = env_sun : 
	"An entity to control & draw a sun effect in the sky."
[
	target(target_destination) : "Viewer entity" : : "Name of an entity used to determine where the sun is in the skybox. The sun should be lined up on a line from this entity to the env_sun entity."
	
	use_angles(choices) : "UseAngles" : 0 : "The old way to orient env_sun is to point it at a target. The new way is to specify the angles. If you use the new way, set this property to YES." = 
	[
		0 : "No"
		1 : "Yes"
	]

	pitch(integer) : "Pitch" : 0

	rendercolor(color255) : "Sun Color (R G B)" : "100 80 80"
	overlaycolor(color255) : "Overlay Color (R G B)" : "0 0 0" : "A value of 0 0 0 will act the old way."
	
	size(integer) : "Size" : 16
	overlaysize(integer) : "Overlay Size" : -1 : "A value of -1 means the overlay will act the old way."
	
	material(sprite) : "Material Name" : "sprites/light_glow02_add_noz" : "Material of the inner glow."
	overlaymaterial(sprite) : "Overlay Material Name" : "sprites/light_glow02_add_noz" : "Material of the overlay glow."

	HDRColorScale(float) : "HDR color scale." : "1.0" : "float value to multiply sprite color by when running in HDR mode."

	// Inputs
	input TurnOn(void) : "Enable sun rendering."
	input TurnOff(void) : "Disable sun rendering."
	input SetColor(color255) : "Change the sun's color. Format: <Red 0-255> <Green 0-255> <Blue 0-255>"
]

@PointClass base(Targetname) = game_ragdoll_manager : 
	"An entity to control the number of ragdolls in the world, for performance reasons." 
[
	MaxRagdollCount(integer) : "Max Ragdoll Count" : -1 : "Sets the max number of ragdolls that can be in the world at a time (if they are flagged to fade). Set to -1 if you want to use the default value (g_ragdoll_maxcount)."
	MaxRagdollCountDX8(integer) : "Max Ragdoll Count DX8" : -1 : "Sets the max number of ragdolls that can be in the world at a time on DX8 hardware (if they are flagged to fade). Set to -1 if you want to use the 'Max Ragdoll Count' value."

	SaveImportant(choices) : "Save Important Ragdolls" : 0 : "Should the ragdoll manager make sure ally ragdolls aren't deleted?" = 
	[
		0 : "No"
		1 : "Yes"
	]
	
	// Inputs
	input SetMaxRagdollCount(integer) : "Set the Max Ragdoll Count."
	input SetMaxRagdollCountDX8(integer) : "Set the Max Ragdoll Count on DX8 hardware."
]

@PointClass base(Targetname) = game_gib_manager : "An entity to control the number of gibs in the world, for performance reasons." 
[
	maxpieces(integer)	: "Max Gib Count" : -1 : "Sets the max number of gib that can be spawned at a time. (-1=no limit)"
	maxpiecesdx8(integer)	: "Max Gib Count On DX8" : -1 : "Sets the max number of gib that can be spawned at a time under DX8. (-1=use Max Gib Count setting)"
	allownewgibs(choices)	: "Allow New Gibs To Spawn" : 0 : "If true, when the max gib count is reached, oldest gibs are removed as new gibs spawn. If false, new gibs will not be spawned once the gib limit is reached." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	input SetMaxPieces(integer)	: "Set the max gib count."
	input SetMaxPiecesDX8(integer)	: "Set the max gib count under DX8."
]

@PointClass base(Parentname, Targetname, Angles, EnableDisable) color(255 128 0) studio("models/editor/axis_helper_thick.mdl") sphere(MinDist) sphere(MaxDist) sphere(OuterMaxDist) sphere(GlowProxySize) = env_lightglow : 
	"An entity that puts an additive glow in the world, mostly used over light sources."
[
	rendercolor(color255) : "Color (R G B)" : "255 255 255"
	VerticalGlowSize(integer) : "Vertical Size" : 30
	HorizontalGlowSize(integer) : "Horizontal Size" : 30
	MinDist(integer) : "Minimum Distance" : 500 : "The distance at which this effect will be fully translucent."
	MaxDist(integer) : "Maximum Distance" : 2000 : "The distance at which this effect will be at full intensity."
	OuterMaxDist(integer) : "Outer Maximum Distance" : 0 : "If larger than the maximum distance, this is the length at which the glow will fade completely out, between the span of the maximum distance and this length."
	GlowProxySize(float) : "Glow Proxy Geometry Size" : "2.0" : "Size of the glow to be rendered for visibility testing. Must be larger than the distance from the sprite center to empty space. So if this glow is inside geometry (like a light bulb), set this value to be bigger than the bulb's radius. Any time a sphere of this radius would be visible (poking through any nearby geometry), the glow will be rendered."
	HDRColorScale(float) : "HDR color scale." : "1.0" : "float value to multiply sprite color by when running in HDR mode."

	// Inputs
	input Color(color255) : "Change the render color of the glow. Format: <Red 0-255> <Green 0-255> <Blue 0-255>"

	spawnflags(flags) =
	[
		1: "[1] Visible only from front" : 0
	]
]

@PointClass base(Targetname, Parentname, Angles) color(255 255 255) = env_smokestack : 
	"An entity that spits out a constant stream of smoke. See particlezoo.vmf for sample usage. You can place up to two env_particlelight entities near the smoke stack to add ambient light to its particles."
[
	//targetname(target_source) : "Name" : : "The name that other entities refer to this entity by."

	InitialState(choices) : "Initial State" : 0 = 
	[
		0 : "Off"
		1 : "On"
	]

	BaseSpread(integer) : "Spread at the base" : 20 : "Amount of random spread in the origins of the smoke particles when they're spawned."
	SpreadSpeed(integer) : "Spread Speed" : 15 : "Amount of random spread in the velocity of the smoke particles after they're spawned."
	Speed(integer) : "Speed" : 30 : "The speed at which the smoke particles move after they're spawned."
	StartSize(integer) : "Particle start size" : 20 : "Size of the smoke particles when they're first emitted."
	EndSize(integer) : "Particle end size" : 30 : "Size of the smoke particles at the point they fade out completely."
	Rate(integer) : "Emission rate" : 20 : "Rate at which to emit smoke particles (i.e. particles to emit per second)."
	JetLength(integer) : "Length of smoke trail" : 180 : "Length of the smokestack. Lifetime of the smoke particles is derived from this & particle speed."
	WindAngle(integer) : "Wind X/Y Angle" : 0 : "This specifies the wind direction. It is an angle in the XY plane. WindSpeed specifies the strength of the wind."
	WindSpeed(integer) : "Wind Speed" : 0 : "The strength of the wind."
	SmokeMaterial(string) : "Particle material" : "particle/SmokeStack.vmt" : "Material of the smoke particles emitted by this stack."
	twist(integer) : "Twist" : 0 : "The amount, in degrees per second, that the smoke particles twist around the origin."
	roll(float)			: "Roll Speed": 0 : "Amount of roll in degrees per second."
	
	rendercolor(color255) : "Base Color (R G B)" : "255 255 255"

	renderamt(integer) : "Translucency" : 255
	
	// Inputs
	input TurnOn(void) : "Turn on the smokestack."
	input TurnOff(void) : "Turn off the smokestack."
	input Toggle(void) : "Toggles the smokestack between on and off state."
	input JetLength(integer): "Set the length of the smoke trail."
	input Rate(integer) : "Set the rate at which to emit smoke particles (particles per second)."
	input Speed(integer) : "Set the speed at which the smoke particles move after they're spawned."
	input SpreadSpeed(integer) : "Set the amount of random spread in the velocity of the smoke particles after they're spawned."
]

@PointClass base(Targetname) iconsprite("editor/env_fade") = env_fade : 
	"An entity that controls screen fades."
[
	spawnflags(flags) =
	[
		1: "[1] Fade From" : 0
		2: "[2] Modulate" : 0
		4: "[4] Triggering player only" : 0
		8: "[8] Stay Out" : 0
		16: "[16] Don't purge other active fades" : 0
	]
	duration(string) : "Duration (seconds)" : "2" : "The time that it will take to fade the screen in or out."
	holdtime(string) : "Hold Fade (seconds)" : "0" : "The time to hold the faded in/out state."
	renderamt(integer) : "Fade Alpha" : 255 : "Alpha of the fade, where 0 = fully transparent and 255 = fully opaque." 
	rendercolor(color255) : "Fade Color (R G B)" : "0 0 0"
	
	// Inputs
	input Fade(void) : "Start the screen fade."

	// Outputs
	output OnBeginFade(void) : "Fired when the fade has begun."
]

@PointClass base(Targetname) = env_player_surface_trigger : 
	"An entity that monitors the material of the surface the player is standing on, and fires outputs whenever it changes to/from a specific material."
[
	gamematerial(choices) : "Game Material to Watch" : "0" : "The material to watch. When the player stands on/off this material, this entity's outputs will be fired." =
	[
		0 : "None (player's in the air)"
		67 : "Concrete"
		77 : "Metal"
		68 : "Dirt"
		86 : "Vent"
		71 : "Grate"
		84 : "Tile"
		83 : "Slosh"
		87 : "Wood"
		80 : "Computer"
		89 : "Glass"
		70 : "Flesh"
		73 : "Clip"
		79 : "Foliage"
		78 : "Sand"
	]
	
	// Inputs
	input Enable(void) : "Start watching the player's surface."
	input Disable(void) : "Stop watching the player's surface."

	// Outputs
	output OnSurfaceChangedToTarget(void) : "Fired when the player moves onto the specified game material."
	output OnSurfaceChangedFromTarget(void) : "Fired when the player moves off the specified game material."
]

@SolidClass base(Trigger) = trigger_tonemap : "Changes tonemap controllers for players touching the trigger."
[
	TonemapName(target_destination) : "Tonemap Name" : : "The name of the tonemap controller entity associated with this trigger."
]

@PointClass base(Targetname) iconsprite("editor/env_tonemap_controller.vmt") = env_tonemap_controller : 
	"An entity that controls the HDR tonemapping for the player. Think of it as a method of controlling the exposure of the player's eyes."
[
	TonemapScale(float) : "Tonemap Scale" : "-1" : "The tonemap scale. This should be a value between 0 and 2, where 0 is the eyes fully closed, 1 is use the unchanged autoexposure (default), and 2 is the eye fully wide open. -1 = use default" // 1.0
	TonemapRate(float) : "Tonemap Rate" : "-1" : "The rate for auto exposure adjustment. -1 = use default" // 1.0
	AutoExposureMin(float) : "Auto Exposure Minimum" : "-1" : "Sets a custom tonemap auto exposure minimum. -1 = use default" // 0.5
	AutoExposureMax(float) : "Auto Exposure Maximum" : "-1" : "Sets a custom tonemap auto exposure maximum. -1 = use default" // 2.0
	BloomScale(float) : "Bloom Scale" : "-1" : "Sets a custom bloom scale. -1 = use default" // 1.0
	
	spawnflags(flags) =
	[
		1 : "[1] Master (Has priority if multiple env_tonemap_controllers exist)" : 0
	]

	// Inputs
	input SetTonemapScale(float) : "Set the player's tonemap scale. It should be a value between 0 and 2, where 0 is the eyes fully closed, 1 is use the unchanged autoexposure (default), and 2 is the eye fully wide open."
	input BlendTonemapScale(string) : "Blend from the player's current tonemap scale to a new one. The parameter syntax is as follows: <target tonemap scale> <blend duration>. For example: '0.5 10' would blend from the current tonemap scale to 0.5 over a period of 10 seconds. Tonemap scale is a value between 0 and 2, where 0 is the eyes fully closed, 1 is use the unchanged autoexposure (default), and 2 is the eye fully wide open."
	input UseDefaultAutoExposure(void) : "Revert to using the default tonemap auto exposure."
	input UseDefaultBloomScale(void) : "Reverts to using the default bloom scale."
	input SetAutoExposureMin(float) : "Set a custom tonemap auto exposure minimum."
	input SetAutoExposureMax(float) : "Set a custom tonemap auto exposure maximum."
	input SetBloomScale(float) : "Set a custom bloom scale."
	input SetBloomScaleRange(string) : "Sets a range for the bloom scale. First number is the maximum, second number is the minimum."
	input SetTonemapRate(float) : "Set the rate for autoexposure adjustment."
]

@PointClass base(Targetname, Parentname) sweptplayerhull() = func_useableladder : 
	"A Half-Life 2 ladder. Handles player auto mount/unmount, as well as +use to get onto the ladder. \n\n" +
	"See also 'info_ladder_dismount', used to specify ladder auto-dismount points.\n\n" +
	"Note: This entity is non-functional in Counter-Strike: Source. Use func_ladder instead."
[
	spawnflags(flags) =
	[
		1: "[1] Fake Ladder" : 0
	]

	point0(vector) : "Start" : : "Ladder end point."
	point1(vector) : "End" : : "Ladder end point."

	StartDisabled(choices) : "Start Disabled" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input Enable(void) : "Enable this ladder."
	input Disable(void) : "Disable this ladder."
	input ForcePlayerOn(void) : "Forces the player onto this ladder, no matter what."
	input CheckPlayerOn(void) : "Acts like the player just +USEd this ladder, taking distance and obstructions into account."

	output OnPlayerGotOnLadder(void) : "Fired whenever a player gets on this ladder."
	output OnPlayerGotOffLadder(void) : "Fired whenever a player gets off this ladder."
	ladderSurfaceProperties(string) : "Surface properties (optional)"
]

@PointClass base(Targetname, Parentname, Angles) size( -16 -16 0, 16 16 72 ) color(127 127 127) = func_ladderendpoint : 
	"An entity used to specify the endpoints of a ladder. This entity is functional, but has been replaced by the " + 
	"easier-to-use func_useableladder entity. Left in only for backwards-compatibility!\n\n" +
	"To be valid, a full sized player hull traced between the start and end points must not be obstructed at level " + 
	"activation time. The angle determines in which direction the player leaves the ladder if the player presses the " +
	"+jump button.\n\n" +
	"Note: This entity is non-functional in Counter-Strike: Source. In CS:S, use func_ladder instead."
[
	target(target_destination) : "Other" : : "A ladder goes between any two func_ladderendpoints pointing at each other."
	// TODO:  Allow individual ladder end points to be enabled, disabled
	// TODO:  Allow ladder to specify movement speed or a speed scale while on ladder
	// TODO:  Allow specifying radius within with you must be in order to +use to get on the ladder
]

@PointClass base(Parentname) size( -16 -16 0, 16 16 4 ) color(255 128 255)= info_ladder_dismount : 
	"An entity to handle endpoints for multiple ladders that are too close to each other."
[
	target(target_destination) : "LadderName" : : "If multiple ladders are near multiple endpoints, use this to stop them from interfering with each other."
]

@SolidClass = func_ladder : 
	"Ladder. Players will be able to freely along this brush, as if it was a ladder. If you are using a model prop " +
	"for the visual representation of the ladder in the map, apply the toolsinvisibleladder material to the " +
	"func_ladder brush."
[
]

@SolidClass base(Targetname) color(0 128 255) sphere(FadeStartDist) sphere(FadeDist) = func_areaportalwindow : 
	"An entity that can be used to optimize the visibility in a map. If you seal off an area with them, when the viewer moves the specified distance away from them, they will go opaque and the parts inside the area will not be drawn. The 'target' brush model should enclose the func_areaportal window so no parts of it are culled by the window. If you use the optional foreground brush model, then it should enclose the 'target' brush model."
[
	target(target_destination)  : "Rendered Window" : : "The name of a brush model to render as the window."
	FadeStartDist(integer) : "Fade Start Distance" : 128 : "When the viewer is closer than this distance, the alpha is set to 'TranslucencyLimit'."
	FadeDist(integer) : "Fade End Distance"   : 512 : "When the viewer is at this distance, the portal becomes solid and closes off."
	TranslucencyLimit(string) : "Translucency limit"  : "0.2" : "This value limits the translucency of the bmodel and prevents it from becoming invisible when the viewer is right on top of it."
	BackgroundBModel(string) : "Foreground bmodel"   : "" : "(Optional) brush model that is drawn after the fading brush model. This model should have alpha in its textures so you can see through it."
	PortalVersion(integer)	readonly	: "Portal Version"      : 1  : "(Don't change). Differentiates between shipping HL2 maps and maps using new engine features."
	
	// Inputs
	input SetFadeStartDistance(integer) : "Set fade start distance."
	input SetFadeEndDistance(integer) : "Set fade end distance."
]

@SolidClass base(Targetname, RenderFields, Global, Shadow) = func_wall : 
	"Legacy support. Use func_brush instead." 
[
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
]

@SolidClass base(Targetname, EnableDisable) = func_clip_vphysics : 
	"A brush entity that's considered solid to vphysics." 
[
	filtername(filterclass) : "Filter Name" : : "Filter to use to see if activator collides with me. See filter_activator_name for more explanation. Allow means 'Allow to Block' for this entity."
	
	input SetFilter(target_destination) : "Sets the filter used by this entity."
]

@SolidClass base(Targetname, Parentname, EnableDisable) = func_clip_client : 
	"A brush entity that's considered solid to clientside ragdolls and other clientside objects." 
[
	input Toggle(void) : "Toggles this entity."
]

@SolidClass base(Targetname, Parentname, Origin, RenderFields, Global, Inputfilter, EnableDisable, Shadow) = func_brush : 
	"An brush built entity with various features." 
[
	spawnflags(flags) =
	[
		2: "[2] Ignore player +USE" : 1
	]

	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
	Solidity(choices) : "Solidity" : 0 : "Used to control the solidity/collision of these brushes." =
	[
		0 : "Toggle"
		1 : "Never Solid"
		2 : "Always Solid"
	]
	excludednpc(target_name_or_class) : "NPC class excluded from collisions" : "" : "If an NPC classname is specified here, NPCs of that type won't collide with these brushes. In Episodic, you may also specify an individual entity's name."
	invert_exclusion(choices) : "Invert NPC class exclusion" : 0 : "If set, then the excluded NPC class will consider this brush solid, and all other NPC classes will consider it non-solid." =
	[
		0 : "No"
		1 : "Yes"
	]	

	solidbsp(choices) : "Solid BSP" : 0 : "Set this if this brush is in heirarchy with a moving object of some kind, and the player can stand on this brush." =
	[
		0 : "No"
		1 : "Yes"
	]	
	vrad_brush_cast_shadows(choices) : "Shadows" : 0 : "Set this if this brush casts lightmap shadows." =
	[
		0 : "No"
		1 : "Yes"
	]	
	
	input Alpha(integer) : "Sets the brush's alpha value."
	input SetExcluded( target_destination ) : "Change the NPC class excluded from collisions"
	input SetInvert( integer ) : "Set the state of invversion for NPC class exclusion (0 or 1)"
]

//-------------------------------------------------------------------------
//
// A Vgui screen in 3D
//
//-------------------------------------------------------------------------

@BaseClass base(Targetname, Parentname, Angles) = vgui_screen_base
[
	panelname(string) : "Panel Name"
	overlaymaterial(string) : "Overlay Material" : "" : "Name of a material to overlay over the top of the VGUI screen. NOTE: This material must write Z for the VGUI screen to work."
	width(integer) : "Panel Width in World" : 32 : "Width of the panel in units."
	height(integer) : "Panel Height in World" : 32 : "Height of the panel in units."

	// Inputs
	input SetActive(void) : "Make the vgui screen visible."
	input SetInactive(void) : "Make the vgui screen invisible."
]

@PointClass base(vgui_screen_base) size(-4 -4 -4, 4 4 4) = vgui_screen : 
	"A VGUI screen. Useful for in-world monitors." 
[
]

@PointClass base(Targetname, Angles, Parentname) studio("models/editor/axis_helper_thick.mdl") = vgui_slideshow_display : "Slideshow Display"
[
	displaytext(string) : "Display Text" : ""

	directory(string) : "Image Directory (materials/vgui/...)" : "slideshow"

	minslidetime(float) : "Min Slide Time" : "0.5" : "Minimum amount of random time that a slide is displayed."
	maxslidetime(float) : "Max Slide Time" : "0.5" : "Maximum amount of random time that a slide is displayed."

	cycletype(choices) : "Cycle Type" : 0 = 
	[
		0 : "Random"
		1 : "Forward"
		2 : "Backward"
	]

	nolistrepeat(choices) : "No List Repeat" : 0 = 
	[
		0 : "Allow List Repeats"
		1 : "No List Repeats"
	]

	width(integer) : "Panel width" : 256 : "Width of the panel in units."
	height(integer) : "Panel height" : 128 : "Height of the panel in units."

	input Enable(void) : "Make slideshow visible."
	input Disable(void) : "Make slideshow invisible."

	input SetDisplayText(string) : "Sets the display text."

	input RemoveAllSlides(void) : "Removes all slides from slideshow."
	input AddSlides(string) : "Adds slides by keyword."

	input SetMinSlideTime(float) : "Sets min random time between slides."
	input SetMaxSlideTime(float) : "Sets max random time between slides."

	input SetCycleType(integer) : "0 - random, 1 - forward, 2 - backward"
	input SetNoListRepeat(bool) : "Sets if lists can be randomly picked twice in a row."
]


@PointClass base(Targetname, Angles, Parentname) studio("models/editor/axis_helper_thick.mdl") = vgui_movie_display : "Movie Display"
[
	displaytext(string) : "Display Text" : ""
	moviefilename(string) : "Movie Filename" : "media/"
	groupname(string) : "Group Name" : "default"

	looping(choices) : "Loop Movie" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	
	muted(choices) : "Mute Movie" : 1 =
	[
		0 : "No"
		1 : "Yes"
	]

	width(integer) : "Panel width" : 256 : "Width of the panel in units."
	height(integer) : "Panel height" : 128 : "Height of the panel in units."

	input Enable(void) : "Make movie visible."
	input Disable(void) : "Make movie invisible."

	input SetDisplayText(string) : "Sets the display text."
]

//-------------------------------------------------------------------------
//
// Cyclers
//
//-------------------------------------------------------------------------

@PointClass base(Targetname, Parentname, Angles, RenderFxChoices, RenderFields) studio() = cycler : 
	"An entity used to display a model for testing purposes. Shooting it with cycle through the model's animations."
[
	spawnflags(flags) =
	[
		1: "[1] Not Solid" : 0
	]
	model(studio) : "Model"
	skin(integer) : "Skin" : 0 : "Some models have multiple versions of their textures, called skins. Set this to a number other than 0 to use that skin instead of the default."

	sequence(integer) : "Sequence" : 0 : "Default animation sequence for the model to be playing after spawning."

	// Inputs
	input SetSequence(string) : "Sets the cycler's sequence."
]

//-------------------------------------------------------------------------
//
// Environmental effects
//
//-------------------------------------------------------------------------

@BaseClass base(Targetname, Parentname) = gibshooterbase
[
	angles(string) : "Gib Direction (Pitch Yaw Roll)" : "0 0 0" : "The direction the gibs will fly."
	m_iGibs(integer) : "Number of Gibs" : 3 : "Total number of gibs to shoot each time it's activated."
	delay(string) : "Delay between shots" : "0" : "Delay (in seconds) between shooting each gib. If 0, all gibs shoot at once."
	gibangles(string) : "Gib Angles (Pitch Yaw Roll)" : "0 0 0" : "The orientation of the spawned gibs."
	gibanglevelocity(string) : "Max angular velocity" : "0" : "How fast (degrees/sec) the gib pieces should spin. They will spin on x and y axis at between 10% and 100% of this speed."
	m_flVelocity(integer) : "Gib Velocity" : 200 : "Speed of the fired gibs"
	m_flVariance(string) : "Course Variance" : "0.15" : "How much variance in the direction gibs are fired."
	m_flGibLife(string) : "Gib Life" : "4" : "Time in seconds for gibs to live +/- 5%"
	lightingorigin(target_destination) : "Lighting Origin" : "" : "Select an info_lighting to specify a location to sample lighting from for all gibs spawned by this shooter, instead of their own origins."

	spawnflags(Flags) = 
	[
		1 : "[1] Repeatable"  : 0
	]

	// Inputs
	input Shoot(void) : "Force the gibshooter to create and shoot a gib."
]

@PointClass base(Targetname, RenderFxChoices) size(-4 -4 -4, 4 4 4) line(255 255 255, targetname, LightningStart, targetname, LightningEnd) = env_beam : 
	"An entity that creates a visible beam between two points. The points can be attached to entities to make the beam move around."
[
	renderamt(integer) : "Brightness (1 - 255)" : 100
	rendercolor(color255) : "Beam Color (R G B)" : "255 255 255"
	Radius(integer) : "Radius" : 256 : "If the 'Random Strike' spawnflag is set, this radius determines the area within which the endpoints will randomly strike."
	life(string) : "Life (seconds 0 = infinite)" : "1" : "Amount of time before the beam dies. Setting to zero will make the beam stay forever."
	BoltWidth(float) : "Width of beam" : 2 : "Pixel width of the beam."
	NoiseAmplitude(float) : "Amount of noise (0-255)" : 0 : "The amount of noise in the beam. 0 is a perfectly straight beam."
	texture(sprite) : "Sprite Name" : "sprites/laserbeam.spr" : "The material used to draw the beam."
	TextureScroll(integer) : "Texture Scroll Rate (0-100)" : 35 : "Rate at which the beam texture should scroll along the beam."
	framerate(integer) : "Frames per 10 seconds" : 0 : "Framerate at which the beam texture should animate, if it has multiple frames."
	framestart(integer) : "Starting Frame" : 0 : "The frame to start the beam texture on."
	StrikeTime(string) : "Strike again time (secs)" : "1" : "Refire time between random strikes of the beam. Only used if the 'Random Strike' spawnflag is set."
	damage(string) : "Damage / second" : "0" : "How much damage this beam does per second to things it hits when it is continually on, or instantaneously if it strikes. For continuous damage, the value should be greater than 10 or it may not work."
	LightningStart(target_destination) : "Start Entity" : "" : "Entity that the beam starts at."
	LightningEnd(target_destination) : "Ending Entity" : "" : "Entity that the beam ends at."
	decalname(string) : "Decal Name" : "Bigshot" : "Decal to be applied at the end of the beam"
	HDRColorScale(float) : "HDR color scale." : "1.0" : "float value to multiply sprite color by when running in HDR mode."


	spawnflags(flags) = 
	[
		1 : "[1] Start On" : 0
		2 : "[2] Toggle" : 0
		4 : "[4] Random Strike" : 0
		8 : "[8] Ring (non-functional)" : 0
		16: "[16] StartSparks" : 0
		32: "[32] EndSparks" : 0
		64: "[64] Decal End" : 0
		128: "[128] Shade Start" : 0
		256: "[256] Shade End" : 0
		512: "[512] Taper Out" : 0
	]

	TouchType(choices) : "Touch Type (tripwire)" : 0 : "If you want the beam to fire an output when touched by entities, choose the entity type here." =
	[	
		0 : "Not a tripwire"
		1 : "Player Only"
		2 : "NPC Only"
		3 : "Player or NPC"
		4 : "Player or NPC or Physprop"
	]

	filtername(filterclass) : "Filter Name" : : "Filter to use to see if activator triggers me. See filter_activator_name for more explanation."

	// Inputs
	input TurnOn(void) : "Turns the beam on."
	input TurnOff(void) : "Turns the beam off."
	input Toggle(void) : "Toggles the beam between on and off."
	input StrikeOnce(void) : "Causes the beam to strike once. It will stay on for its set Life and then turn off (it will never turn off if Life is set to zero)."
	input Alpha(integer) : "Sets the beam's alpha (0 - 255)."
	input Color(color255) : "Sets the beam's render color (R G B)."
	input ColorRedValue(float) : "Sets the red color channel's value (0 - 255)."
	input ColorGreenValue(float) : "Sets the green color channel's value (0 - 255)."
	input ColorBlueValue(float) : "Sets the blue color channel's value (0 - 255)."
	input Amplitude(float) : "Set the amplitude of beam noise (0 - 255)."
	input ScrollSpeed(float) : "Set the scroll speed in units per second (0 - 100)."
	input Width(float) : "Set the width of the beam, in pixels."
	input Noise(float) : "Set the noise of the beam, in pixels."
	input SetStartEntity(target_destination) : "Sets the start entity."
	input SetEndEntity(target_destination) : "Sets the end entity."

	// Outputs
	output OnTouchedByEntity(void) : "Fired when an entity touches the beam. Only fired if the entity passes the 'Touch Type' choice."
]

@PointClass base(Targetname, Parentname) size(-4 -4 -4, 4 4 4) = env_beverage : 
	"HL1 Legacy: Beverage Dispenser."
[
	health(integer) : "Capacity" : 10 : "Number of cans in the dispenser."
	beveragetype(choices) : "Beverage Type" : 0 = 
	[
		0 : "Coca-Cola"
		1 : "Sprite"
		2 : "Diet Coke"
		3 : "Orange"
		4 : "Surge"
		5 : "Moxie"
		6 : "Random"
	]

	input Activate(void) : "Enable this dispenser."
]

@SolidClass base(Targetname, Parentname, Angles) = env_embers : 
	"An entity used to create a volume in which to spawn fire embers." 
[
	particletype(choices) : "Ember type" : 0 =
	[
		0 : "Normal"
		1 : "Smooth Fade"
		2 : "Pulled"
	]

	density(integer) : "Density (particles per second)" : 50
	lifetime(integer) : "Particle Lifetime (seconds)" : 4
	speed(integer) : "Particle Speed (units per second)" : 32
	rendercolor(color255) : "Ember Color (R G B)" : "255 255 255"	

	spawnflags(Flags) = 
	[
		1 : "[1] Start On"  : 0
		2 : "[2] Toggle" : 0
	]
]

@PointClass base(Targetname, Parentname) size(-16 -16 -16, 16 16 16) = env_funnel : 
	"The suck-in effect from the HL1 Resonance Cascade sequence."
[
	spawnflags(flags) =
	[
		1 : "[1] Reverse (repel particles instead of suck in)" : 0
		2 : "[2] Don't remove after use (allows repeat)" : 0
	]

	//Sprite(sprite) : "Sprite" : "sprites/flare6.vmt" : "The sprite to use for each particle."

	// Inputs
	input Activate(void) : "Activates the effect."
]

@PointClass base(Targetname, Parentname) size(-16 -16 -16, 16 16 16) color(255 0 0) = env_blood : 
	"An entity used to spawn blood effects." 
[
	spraydir(angle) : "Spray Direction (Pitch Yaw Roll)" : "0 0 0" : "The general direction that the blood should spray and the direction to trace to apply the decal."
	color(choices) : "Blood Color" : 0 =
	[
		0 : "Red (Human)"
		1 : "Yellow (Alien)"
	]
	amount(string) : "Amount of blood (damage to simulate)" : "100"
	spawnflags(flags) =
	[
		1: "[1] Random Direction" : 0
		2: "[2] Blood Stream" : 0
		4: "[4] On Player" : 0
		8: "[8] Spray decals" : 0
		// dvs: support these flags
		//16: "[16] Cloud" : 0
		//32: "[32] Drops" : 0
		//64: "[64] Gore" : 0
	]

	// Inputs
	input EmitBlood(void) : "Triggers the blood effect."
]

@SolidClass base(Targetname, Parentname) = env_bubbles : 
	"An entity used to create a volume in which to spawn bubbles." 
[
	density(integer) : "Bubble density" : 2
	frequency(integer) : "Bubble frequency" : 2
	current(integer) : "Speed of Current" : 0 : "The speed of the water current in the volume, used to move the bubbles."
	spawnflags(Flags) = 
	[
		1 : "[1] Start Off"  : 0
	]

	// Inputs
	input Activate(void) : "Activates the bubbles."
	input Deactivate(void) :  "Deactivates the bubbles."
	input Toggle(void) :  "Toggles the bubbles on and off."
	input SetDensity(integer) : "Sets the bubble density."
	input SetFrequency(integer) : "Sets bubble emission rate in bubbles per second."
	input SetCurrent(integer) : "Sets current speed in units per second."
]

@PointClass base(Targetname, Parentname) iconsprite("editor/env_explosion.vmt") sphere(iRadiusOverride) = env_explosion : 
	"An entity that creates an explosion at its origin." 
[
	iMagnitude(Integer) : "Magnitude" : 100 : "The amount of damage done by the explosion."
	// If no radius override, magnitude will determine radius.
	iRadiusOverride(Integer) : "Radius Override" : 0 : "If specified, the radius in which the explosion damages entities. If unspecified, the radius will be based on the magnitude."
	fireballsprite(sprite) : "Fireball Sprite" : "sprites/zerogxplode.spr"
	rendermode(choices) : "Render Mode" : 5 =
	[
		0: "Normal"
		4: "Solid"
		5: "Additive"
	]
	spawnflags(flags) =
	[
		1: "[1] No Damage" : 0
		2: "[2] Repeatable" : 0
		4: "[4] No Fireball" : 0
		8: "[8] No Smoke" : 0
		16: "[16] No Decal" : 0
		32: "[32] No Sparks" : 0
		64: "[64] No Sound" : 0
		128: "[128] Random Orientation" : 0
		256: "[256] No Fireball Smoke" : 0
		512: "[512] No particles" : 0
		1024: "[1024] No DLights" : 0
		2048: "[2048] Don't clamp Min" : 0
		4096: "[4096] Don't clamp Max" : 0
		8192: "[8192] Damage above surface only" : 0
		16384: "[16384] Generic damage" : 0
	]

	ignoredEntity(target_destination) : "Ignored Entity" : : "Do not harm or affect the named entity."

	// Inputs
	input Explode(void) : "Triggers the explosion."
	input SetIgnoredEntity(target_destination) : "Sets the ignored entity."
]

@PointClass base(Targetname, Parentname) color(200 50 0)  size(-8 -8 -8, 8 8 8) = env_smoketrail : 
	"An entity that creates a smoke trail." 
[
	opacity(float) : "Sprite Opacity" : "0.75" : "Opacity of the sprites (range from 0 - 1)."
	spawnrate(float) : "Spawn Rate" : "20" : "Number of particles to emit each second."
	lifetime(float) : "Particle Life Time" : "5.0" : "Number of seconds until each particle dies."
	startcolor(color255) : "Start Color" : "192 192 192" : "Starting color of the emitted particles."
	endcolor(color255) : "End Color" : "160 160 160" : "Ending color of the emitted particles."
	emittime(float) : "Emitter Life Time" : "0" : "Number of seconds until the env_smoketrail stops emitting particles. 0 means never stop emitting particles."
	minspeed(float) : "Minimum Random Speed" : "10" : "Minimum randomly-directed speed to use for emitted particles."
	maxspeed(float) : "Maximum Random Speed" : "20" : "Maximum randomly-directed speed to use for emitted particles."
	mindirectedspeed(float) : "Minimum Directed Speed" : "0" : "Minimum speed along the env_smoketrail's forward direction (x axis) to use for emitted particles."
	maxdirectedspeed(float) : "Maximum Directed Speed" : "0" : "Maximum speed along the env_smoketrail's forward direction (x axis) to use for emitted particles."
	startsize(float) : "Starting particle size" : "15" : "Starting particle size."
	endsize(float) : "Ending particle size" : "50" : "Ending particle size."
	spawnradius(float) : "Spawn radius" : "15" : "Distance from env_smoketrail at which particles are emitted."

	firesprite(sprite) : "Fire Sprite" : "sprites/firetrail.spr"
	smokesprite(sprite) : "Smoke Puff" : "sprites/whitepuff.spr"
]

@PointClass base(Targetname, Parentname) sphere(radius) sphere(inner_radius) sphere(radius) iconsprite("editor/env_physexplosion.vmt") = env_physexplosion : 
	"An entity that creates an explosion at its origin. If the no-damage spawnflag is set, the explosion won't be visible, but will apply force to any physics objects within its radius."
[
	magnitude(string) : "Magnitude" : "100" : "Amount of physics force applied by the explosion."
	radius(string) : "Clamp Radius (0 = auto)" : "0" : "If specified, the radius in which the explosion damages entities. If unspecified, the radius will be based on the magnitude."
	targetentityname(target_destination) : "Limit to Entity" : "" : "If specified, the explosion will only affect the matching entity."

	spawnflags(flags) =
	[
		1 : "[1] No Damage - Only Force" : 1
		2 : "[2] Push players" : 0
		4 : "[4] Push radially - not as a sphere" : 0
		8 : "[8] Test LOS before pushing" : 0
		16 : "[16] Disorient player if pushed" : 0
	]

	inner_radius(float) : "Inner radius" : "0" : "If not zero, the LOS is calculated from a point intersecting this sphere."

	// Inputs
	input Explode(void) : "Triggers the explosion."
	input ExplodeAndRemove(void) : "Triggers the explosion and then removes the entity."
	
	// Outputs
	output OnPushedPlayer(void) : "Fires when the player is pushed by the explosion."
]

@PointClass base(Targetname, Parentname, Angles) line(255 255 255, targetname, directionentityname) iconsprite("editor/env_physexplosion.vmt") = env_physimpact : 
	"An entity that will cause a physics impact on another entity."
[
	//angles(string) : "Pitch Yaw Roll (Y Z X)" : "0 0 0" : "Direction to project the impact."
	magnitude(integer) : "Magnitude" : 100 : "Strength of the impact."
	distance(integer) : "Distance" : 0 : "How far to project the impact (if 0 uses a default value)."
	directionentityname(target_destination) : "Point to Entity" : "" : "If set, 'Distance' and Angle settings are ignored and the direction and distance to the target entity will be used."

	spawnflags(flags) =
	[
		1: "[1] No fall-off" : 0
		2: "[2] Infinite Length" : 0
		4: "[4] Ignore Mass" : 0
		8: "[8] Ignore Surface Normal When Applying Force" : 1
	]

	// Inputs
	input Impact(void) : "Trigger the impact"
]


//  This has been disabled until it can be reimplemented, destroyed, or renamed - jdw
//@PointClass base(Targetname, Parentname) size(-4 -4 -4, 4 4 4) = env_splash : 
//	"Can be used to create either a spash effect or a stream of falling or spurting liquid." +
//	"Will create a splash decal on the collided surface the same color as the liquid"
//[
//	spawnrate(float) : "SpawnRate"  : "10" : "How many particles some out"
//	startcolor(color255) : "StartColor" : "100 100 100" : "Color of particles when the are emitted"
//	endcolor(color255) : "EndColor" : "240 110 0" : "Color that particles approach"
//	speed(float) : "Speed" : 3 : "Averate speed of an emitted particles"
//	speedrange(float) : "SpeedRange" : 1 : "Speed range of an emitted particles"
//	widthmin(float) : "WidthMin" : 2 : "Width of smallest particle emitted"
//	widthmax(float) : "WidthMax" : 8 : "Width of largest particle emitted"
//	noise(float) : "Noise" : "0.1" : "Amount of directional noise in stream"
//	lifetime(float) : "Lifetime" : 5 : "Lifetime of particles (in secs)"
//	numdecals(integer) : "Num Decals" : 1 : "Number of decals used (keep small)"
//	startactive(choices) : "Start On" : 1 =
//	[
//		0 : "No"
//		1 : "Yes"
//	]
//
//	// Inputs
//	input SetSpawnRate(float) : "Sets how many particles come out"
//	input SetSpeed(float) : "Sets speed of emitted particle"
//	input SetNoise(float) : "Sets noise of emitted particle (0-1)"
//	input SetLifetime(float) : "Sets lifetime of emitted particles (in seconds)"
//	input TurnOn(void) : "Turns particles on"
//	input TurnOff(void) : "Turns particles off"
//]

@PointClass base(Targetname, Parentname, EnableDisable) iconsprite("editor/env_fire") color(0 180 0) = env_fire : 
	"An entity that handles a single flame at its origin. The flame causes heat 'damage' to other env_fire entities around it, and will eventually ignite non-flaming env_fire entities nearby, causing the fire to spread."
[
	health(integer) : "Duration" : 30 : "Amount of time the fire will burn."
	firesize(integer) : "Size" : 64 : "Height (in world units) of the flame."
	fireattack(integer) : "Attack" : 4 : "Amount of time the fire takes to grow to full strength."
	firetype(choices) : "Type" : 0 =
	[
		0 : "Natural"
		1 : "Plasma"
	]
	spawnflags(flags) =
	[
		1:	"[1] Infinite Duration" : 0
		2:	"[2] Smokeless" : 0
		4:	"[4] Start On" : 0
		8:	"[8] Start Full" : 0
		16:	"[16] Don't drop" : 0
		32: 	"[32] No glow" : 0
		128: 	"[128] Delete when out" : 0
		256: 	"[256] Visible from above" : 0
	]

	ignitionpoint(float) : "Ignition Point" : 32 : "Amount of heat 'damage' to take before this flame should ignite."
	damagescale(float) : "Damage Scale" : "1.0" : "Multiplier of the burn damage done by the flame."

	// Inputs
	input StartFire(void) : "Start the fire."
	input Extinguish(float) : "Puts out the fire permanently in the number of seconds specified."
	input ExtinguishTemporary(float): "Puts out the fire temporarily in the number of seconds specified."

	// Outputs
	output OnIgnited(void) : "Fires when the fire is first ignited."
	output OnExtinguished(void) : "Fires when the fire is fully extinguished."
]

@PointClass base(Targetname, Parentname) iconsprite("editor/env_firesource") color(255 255 0) sphere(fireradius) = env_firesource : 
	"An entity that provides heat to all nearby env_fire entities. Cannot be extinguished."
[
	spawnflags(flags) =
	[
		1:	"[1] Start On" : 0
	]

	fireradius(float) : "Radius" : 128 : "The radius around this entity in which to provide heat."
	firedamage(float) : "Intensity / Damage" : 10 : "Amount of heat 'damage' to apply to env_fire entities within the radius."

	// Inputs
	input Enable(void) : "Enable fire source."
	input Disable(void) : "Disable fire source."
]

@PointClass base(Targetname, Parentname) size(-4 -4 -4, 4 4 4) color(255 255 0) sphere(fireradius) = env_firesensor : 
	"An entity that detects changes in heat nearby."
[
	spawnflags(flags) =
	[
		1:	"[1] Start On" : 1
		2:	"[2] Accepts flares for heat" : 0
	]

	fireradius(float) : "Radius" : 128 : "The radius around this entity in which to detect heat changes."
	heatlevel(float) : "Heat level" : 32 : "The target heat level to check for. Outputs are fired when the heat moves over this target level (increasing or decreasing)."
	heattime(float) : "Time at level" : 0 : "The amount of time the heat level must spend over the target level before the 'OnHeatLevelStart' output is fired."

	// Inputs
	input Enable(void) : "Enable fire sensor."
	input Disable(void) : "Disable fire sensor."
	output OnHeatLevelStart(void) : "Fires when the heat level has been sustained for the specified length of time."
	output OnHeatLevelEnd(void) : "Fires when the heat level drops below the target level."
]

@PointClass base(Targetname) size(-4 -4 -4, 4 4 4) color(0 180 0) = env_entity_igniter : 
	"An entity that catches a target entity on fire. If the entity is an animating model, it will have sprite flames attached to its skeleton. Otherwise the entity will emit particle flame puffs."
[
	target(target_destination) : "Entity to ignite" : : "Name of the entity to catch on fire."
	lifetime(float) : "Lifetime in seconds" : 10 : "Duration of flames."
	
	// Inputs
	input Ignite(void) : "Ignite the target entity."
]

@PointClass base(Targetname, DXLevelChoice, Angles) iconsprite("editor/fog_controller.vmt") sphere(fogstart) sphere(fogend) color(255 255 255) = env_fog_controller : 
	"An entity that controls the fog and view distance in the map."
[
	// Inputs
	input SetStartDist(float) : "Set the fog start distance."
	input SetEndDist(float) : "Set the fog end distance."
	input TurnOn(void) : "Turn the fog on."
	input TurnOff(void) : "Turn the fog off."
	input SetColor(color255) : "Set the primary fog color."
	input SetColorSecondary(color255) : "Set the secondary fog color."
	input SetFarZ(integer): "Set the far clip plane distance."
	input SetAngles(string) : "Set the angles to use for the secondary fog direction."

	input SetColorLerpTo(color255) : "Set the primary fog color."
	input SetColorSecondaryLerpTo(color255) : "Set the secondary fog color."
	input SetStartDistLerpTo(float) : "Set the fog start distance."
	input SetEndDistLerpTo(float) : "Set the fog end distance."
	input StartFogTransition(void) : "Start fog transition."

	// Starting fog parameters for the level. These are selectable per LOD.	
	fogenable(choices) : "Fog Enable" : 1 : "Determines whether this controller should be enabled by default." =
	[
		0 : "No"
		1 : "Yes"
	]
	fogblend(choices) : "Fog Blend" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	use_angles(choices) : "Use Angles for Fog Dir" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	fogcolor(color255) : "Primary Fog Color" : "255 255 255"
	fogcolor2(color255) : "Secondary Fog Color" : "255 255 255"
	fogdir(string) : "Primary Fog Direction" : "1 0 0"
	fogstart(string) : "Fog Start" : "500.0"
	fogend(string) : "Fog End" : "2000.0"
	fogmaxdensity(float) : "Fog Max Density [0..1]" : "1"

	foglerptime(float) : "Interpolate time" : "0"
	
	farz(string) : "Far Z Clip Plane" : "-1"
	
	spawnflags(flags) =
	[
		1 : "[1] Master (Has priority if multiple env_fog_controllers exist)" : 0
	]
]

@PointClass base(Targetname, Parentname, Angles) studioprop("models/editor/spot_cone.mdl") color(255 255 255) = env_steam : 
	"An entity used to create a jet of steam."
[
	spawnflags(flags) =
	[
		1 : "[1] Emissive" : 0
	]

	InitialState(choices) : "Initial State" : 0 = 
	[
		0 : "Off"
		1 : "On"
	]

	//Type of particle to spew out
	type(choices) : "Particle Type" : 0 =
	[
		0 : "Normal"
		1 : "Heat Wave"
	]

	SpreadSpeed(integer) : "Spread Speed" : 15 : "The amount of random spread in the particle's velocity after they spawn."
	Speed(integer) : "Speed" : 120 : "The default speed at which the particles move after they spawn."
	StartSize(integer) : "Particle start size" : 10 : "The initial size of the particles after they spawn."
	EndSize(integer) : "Particle end size" : 25 : "The size of the particles at the point at which they are removed."
	Rate(integer) : "Emission rate" : 26 : "The rate of particle emission. i.e. particles per second."
	rendercolor(color255) : "Color (R G B)" : "255 255 255"
	JetLength(integer) : "Length of steam jet" : 80 : "The length of the jet determines the lifetime of each particle."
	renderamt(integer) : "Translucency" : 255
	rollspeed(float) : "How fast does the particles spin" : 8
	
	// Inputs
	input TurnOn(void) : "Turns the steam jet on."
	input TurnOff(void) : "Turns the steam jet off."
	input Toggle(void) : "Toggles the steam jet between on and off."
	input JetLength(integer) : "Sets the length of steam jet."
	input Rate(integer) : "Sets the particle emission rate in particles per second."
	input Speed(integer) : "Sets the default speed of the particles in units per second."
	input SpreadSpeed(integer) : "Sets the spread speed in units per second."
]

@PointClass base(Targetname, Parentname, RenderFxChoices) size(-4 -4 -4, 4 4 4) line(255 255 255, targetname, LaserTarget) = env_laser : 
	"An entity that creates a laser beam between itself and a given target."
[
	LaserTarget(target_destination) : "Target of Laser" : : "Name of entity, or entities, to strike at. The target is randomly chosen if there are multiple entities matching the given name."
	renderamt(integer) : "Brightness (1 - 255)" : 100
	rendercolor(color255) : "Beam Color (R G B)" : "255 255 255"
	width(float) : "Width of Beam" : 2 : "The width of the laser beam, in pixels."
	NoiseAmplitude(integer) : "Amount of noise (0-255)" : 0 : "The amount of noise in the beam. 0 is a perfectly straight beam."
	texture(sprite) : "Sprite Name" : "sprites/laserbeam.spr" : "The material used to draw the laser beam."
	EndSprite(sprite) : "End Sprite" : "" : "If specified, this sprite will be drawn at the end of the laser beam."
	TextureScroll(integer) : "Texture Scroll Rate (0-100)" : 35 : "Rate at which the beam texture should scroll along the beam."
	framestart(integer) : "Starting Frame" : 0 : "The frame to start the beam texture on."
	damage(string) : "Damage / second" : "100" : "How much damage this laser does. per second. to things it hits."
	dissolvetype(choices) : "Dissolve Type" : "None" =
	[
		-1 : "None"
		0 : "Energy"
		1 : "Heavy electrical"
		2 : "Light electrical"
	]
	spawnflags(flags) = 
	[
		1 : "[1] Start On" : 0
		16: "[16] StartSparks" : 0
		32: "[32] EndSparks" : 0
		64: "[64] Decal End" : 0
	]

	// Inputs
	input TurnOn(void) : "Turns the laser on."
	input TurnOff(void) : "Turns the laser off."
	input Toggle(void) : "Toggles the laser between on and off."
	input SetTarget(target_destination) : "Sets the laser's target."
	
	// Outputs
	output OnTouchedByEntity(void) : "Fired when an entity touches the laser. Please note this fires for each frame the entity is touching, unlike env_beam."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = env_message : 
	"An entity that draws a text message on player's HUDs."
[
	message(string) : "Message Text"
	spawnflags(flags) =
	[
		1: "[1] Play Once" : 0
		2: "[2] All Clients" : 0
	]
	messagesound(sound) : "Sound Effect" : "" : "When the message is shown, this sound effect will be played, originating from this entity."
	messagevolume(string) : "Volume 0-10" : "10" : "Volume of the sound effect."
	messageattenuation(Choices) : "Sound Radius" : 0 =
	[
		0 : "Small Radius"
		1 : "Medium Radius"
		2 : "Large  Radius"
		3 : "Play Everywhere"
	]
	
	// Inputs
	input ShowMessage(void) : "Shows the message and plays the sound."
	
	// Outputs
	output OnShowMessage(void) : "Fired when the message is activated."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = env_hudhint : 
	"An entity to control the display of HUD hints. HUD hints are used to show the player what key is bound to a particular command."
[
	spawnflags(flags) =
	[
		1: "[1] All Players" : 0
	]

	message(string) : "Hint Text (localized)" : "" : "This should be set to match the desired HUD hint entry in the hl2\resource\valve_english.txt."

	// Inputs
	input ShowHudHint(void) : "Shows the hint message."
	input HideHudHint(void) : "Hides the hint message."
	input SetHudHint(string) : "Sets the hint message."
]

@PointClass sphere(radius) iconsprite("editor/env_shake.vmt") base(Targetname, Parentname) = env_shake : 
	"An entity to control screen shake on players." 
[
	spawnflags(flags) =
	[
		1: "[1] GlobalShake" : 0
		//2: "[2] Disrupt player control" : 0 // doesn't work
		4: "[4] In Air" : 0		// shakes objects even if they are not onground
		8: "[8] Physics" : 0	// shakes physically as well as the camera
		16: "[16] Ropes" : 0		// shakes ropes too.
		32: "[32] DON'T shake view (for shaking ropes or physics only)" : 0
		64: "[64] DON'T Rumble Controller" : 0
	]

	amplitude(float) : "Amplitude (0-16)" : "4" : "The amount of noise in the screen shake. Should be a range between 0 and 16."
	radius(float) : "Effect Radius" : "500" : "The radius around this entity in which to affect players."
	duration(float) : "Duration (seconds)" : "1" : "The length of time in which to shake the player's screens."
	frequency(float) : "Frequency" : "2.5" : "The frequency used to apply the screen shake. Should be a value between 0 and 255, where 0.1 = jerk, and 255.0 = rumble."

	// Inputs
	input Amplitude(string) : "Set the amplitude (0-16)"
	input Frequency(string) : "Set the frequence. Should be a value between 0 and 255, where 0.1 = jerk, and 255.0 = rumble."
	input StartShake(void) : "Start the shake."
	input StopShake(void) : "Stop the shake."
]

@PointClass sphere(radius) size(-4 -4 -4, 4 4 4) base(Targetname, Parentname) = env_viewpunch :
	"Causes a view punch on players." 
[
	spawnflags(flags) =
	[
		1: "[1] Punch all players (ignore radius)" : 0
		2: "[2] Punch players in the air" : 0
	]

	punchangle(angle) : "Punch angles" : "0 0 90" : "The punch angles to apply."
	radius(float) : "Effect Radius" : "500" : "The radius around this entity in which to affect players."

	// Inputs
	input ViewPunch(void) : "Performs the view punch."
]

@PointClass base(Targetname, Parentname) = env_rotorwash_emitter :
	"Creates rotorwash." 
[
	altitude(float) : "Altitude" : "1024" : "Altitude the rotorwash will show up."
]

@PointClass base(gibshooterbase) iconsprite("editor/gibshooter.vmt") = gibshooter : 
	"An entity that shoots out gibs. Style of body part depends on language type."
[
]

@PointClass base(gibshooterbase, RenderFields) iconsprite("editor/env_shooter.vmt") = env_shooter : 
	"An entity that shoots models, or sprites, out of its origin."
[
	shootmodel(studio) : "Model" : "" : "Thing to shoot out. Can be a .mdl or a .vmt."
	shootsounds(choices) :"Material Sound" : -1 =
	[
		-1: "None"
		0: "Glass"
		1: "Wood"
		2: "Metal"
		3: "Flesh"
		4: "Concrete"  
	]
	simulation(choices) :"Simulate" : 0 =
	[
		0: "Point"
		1: "Physics"
		2: "Ragdoll"
	]

	skin(integer) : "Gib Skin" : 0 : "Some models have multiple versions of their textures, called skins. Set this to a number other than 0 to use that skin on all gibs produced by this shooter."

	spawnflags(flags) =
	[
		2 : "[2] On fire" : 0
		4 : "[4] strict remove after lifetime" : 0
	]

	nogibshadows(choices) :"Disable Shadows on Gibs" : 0 =
	[
		0: "No"
		1: "Yes"
	]

	gibgravityscale(float) : "Gib gravity scale" : "1" : "ONLY WORKS FOR POINT GIBS. This field allows you to scale gravity so that gibs fall faster, slower, or not at all."
	
	massoverride(float) : "Mass override" : "0" : "EPISODIC ONLY. Specify an arbitrary mass for the gibs emitted by me."
]

@PointClass base(gibshooterbase, RenderFields) iconsprite("editor/env_shooter.vmt") = env_rotorshooter : 
	"An entity that creates gibs when it's within the influence of a helicopter's rotor wash."
[
	shootmodel(studio) : "Model" : "" : "Thing to shoot out.  Can be a .mdl or a .vmt."
	shootsounds(choices) :"Material Sound" : -1 =
	[
		-1: "None"
		0: "Glass"
		1: "Wood"
		2: "Metal"
		3: "Flesh"
		4: "Concrete"  
	]
	simulation(choices) :"Simulate" : 0 =
	[
		0: "Point"
		1: "Physics"
		2: "Ragdoll"
	]

	skin(integer) : "Gib Skin" : 0 : "Some models have multiple versions of their textures, called skins. Set this to a number other than 0 to use that skin on all gibs produced by this shooter."

	spawnflags(flags) =
	[
		2 : "[2] On fire" : 0
	]

	rotortime(float) : "Time Under Rotor" : "1" : "The average time it has to be under the rotor before it shoots a gib."
	rotortimevariance(float) : "Time variance" : "0.3" : "The random amount to vary the time it has to be under the rotor before it shoots a gib."
]

@PointClass base(Targetname, Parentname, Angles) iconsprite("editor/env_shooter.vmt") = env_break_shooter : 
	"An entity that shoots func_breakable gibs."
[
	angles(angle) : "Gib Direction (Pitch Yaw Roll)" : "0 0 0" : "The direction the gibs will fly."

	model(choices) : "Model" : "WoodChunks" : "Thing(s) to shoot out. The choices only matter when the model type is Breakable Chunks. If a specific model is needed, enter its file path. If a point_template is needed, enter the point_template's name." =
	[
		"WoodChunks" : "WoodChunks"
		"GlassChunks" : "GlassChunks"
		"MetalChunks" : "MetalChunks"
		"ConcreteChunks" : "ConcreteChunks"
		//"ComputerGibs" : "ComputerGibs"
		//"CeilingTile" : "CeilingTile"
		//"FleshGibs" : "FleshGibs"
		//"WebGibs" : "WebGibs"
	]
	
	modeltype(choices) :"Model Type" : 0 : "The type of model to use." =
	[
		0: "Breakable Chunks"
		1: "Specific Model"
		2: "point_template"
	]

	SetCount(integer) : "Gib Count" : 15 : "Number of gibs to create."
	SetDelay(float) : "Delay" : "0.0" : "Delay until gibs are shot."
	SetGibSize(vector) : "Gib Size" : "0 0 0" : "The size of each gib."
	SetGibSpeed(float) : "Gib Speed" : "200" : "The speed of each gib."
	SetRandomization(integer) : "Randomization" : 100 : "The gib direction randomization factor."
	SetLifetime(float) : "Lifetime" : "5" : "The lifetime of each gib."
	SetGibFlags(integer) : "Gib Flags" : 0 : "The flags for each gib."
	
	// Inputs
	input Shoot(void) : "Shoots the gibs."
	
	input SetCount(integer) : "Sets the number of gibs to create."
	input SetDelay(float) : "Sets the delay until gibs are shot."
	input SetGibSize(vector) : "Sets the size of each gib."
	input SetGibSpeed(float) : "Sets the speed of each gib."
	input SetRandomization(integer) : "Sets the gib direction randomization factor."
	input SetLifetime(float) : "Sets the lifetime of each gib."
	input SetGibFlags(integer) : "Sets the flags for each gib."
]

@PointClass base(Targetname,Parentname) sphere(radius) iconsprite("editor/env_soundscape.vmt") = env_soundscape_proxy : 
	"An entity that acts like a soundscape but gets all of its sound parameters from another env_soundscape entity."
[
	MainSoundscapeName(target_destination) : "Soundscape Entity" : "" : "The soundscape to get all sound parameters from."

	radius(integer) : "Radius" : 128					// NEEDHELP: The datadesc doesn't include this entry. Probably not used.
]

@PointClass base(Targetname,Parentname,EnableDisable) sphere(radius) iconsprite("editor/env_soundscape.vmt") line(255 255 255, targetname, position0) line(255 255 255, targetname, position1) line(255 255 255, targetname, position2) line(255 255 255, targetname, position3) line(255 255 255, targetname, position4) line(255 255 255, targetname, position5) line(255 255 255, targetname, position6) line(255 255 255, targetname, position7) = env_soundscape : 
	"An entity to control sound in an area. The active soundscape at any time is the last one that had line-of-sight to the player, and was within the radius."
[
	radius(integer) : "Radius" : 128 : "If set to -1, then the player can hear the soundscape as long as he can see it (regardless of distance to it)."
	soundscape(choices) : "Soundscape" : "Nothing" : "The name of the soundscape to use. Corresponds to an entry in the soundscapes*.txt file in the hl2\scripts directory." =
	[
		"Nothing" : "Nothing"
		"Automatic" : "Automatic"
		"Automatic_Dialog" : "Automatic (dialog)"
		"GenericIndoor" : "Indoor"
		"GenericOutdoor" : "Outdoor"
	]
	position0(target_destination) : "Sound Position 0" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position1(target_destination) : "Sound Position 1" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position2(target_destination) : "Sound Position 2" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position3(target_destination) : "Sound Position 3" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position4(target_destination) : "Sound Position 4" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position5(target_destination) : "Sound Position 5" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position6(target_destination) : "Sound Position 6" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position7(target_destination) : "Sound Position 7" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."

	// Inputs
	input Enable(void) : "Enable the soundscape."
	input Disabled(void) : "Disable the soundscape."
	input ToggleEnabled(void) : "Toggle the soundscape enabled state."

	// Outputs
	output OnPlay(void) : "Fired when this soundscape becomes the active one."
]

@PointClass base(env_soundscape) sphere(radius) iconsprite("editor/env_soundscape.vmt") = env_soundscape_triggerable : 
	"An entity that works like env_soundscape except that it works in conjunction with trigger_soundscape to determine when a player hears it."
[
]

@PointClass base(Targetname, Parentname, Angles) iconsprite("editor/env_spark.vmt") = env_spark : 
	"An entity used to create sparks at its origin." 
[
	MaxDelay(string) : "Max Delay" : "0" : "The longest delay between sparks (in seconds)."
	Magnitude(choices) : "Magnitude" : 1 : "The size of the sparks." =
	[
		1 : "Small"
		2 : "Medium"
		5 : "Large"
		8 : "Huge"
	]

	TrailLength(choices) : "Spark Trail Length" : 1 =
	[
		1 : "Short"
		2 : "Medium"
		3 : "Long"
	]

	spawnflags(flags) =
	[
		64: "[64] Start ON" : 0
		128: "[128] Glow" : 0
		256: "[256] Silent" : 0
		512: "[512] Directional" : 0
	]
	
	// Inputs
	input StartSpark(void) : "Start the spark effect."
	input StopSpark(void) : "Stop the spark effect."
	input ToggleSpark(void) : "Toggle the on/off state of the spark effect."
	input SparkOnce(void) : "Spark once."
]

@PointClass base(Targetname, Parentname, RenderFields,DXLevelChoice) size(-2 -2 -2, 2 2 2) sprite() color(20 140 20) sphere(GlowProxySize) = env_sprite : 
	"An entity that controls the drawing of a sprite in the world." 
[
	framerate(string) : "Framerate" : "10.0" : "Rate at which the sprite should animate, if at all."
	model(sprite) : "Sprite Name" : "sprites/glow01.spr" : "Material of the sprite to be drawn."
	scale(string) : "Scale" : "0.25" : "Scale multiplier of the sprite."
	spawnflags(flags) =
	[
		1: "[1] Start on" : 0
		2: "[2] Play Once" : 0
	]

	GlowProxySize(float) : "Size of Glow Proxy Geometry." : "2.0" : "Size of the glow to be rendered for visibility testing. Must be larger than the distance from the sprite center to empty space.  So if this glow is inside geometry (like a light bulb), set this value to be bigger than the bulb's radius. Any time a sphere of this radius would be visible (poking through any nearby geometry), the glow will be rendered."

	HDRColorScale(float) : "HDR color scale." : "1.0" : "float value to multiply sprite color by when running in HDR mode."
	
	// Inputs
	input ColorRedValue(float) : "Sets the red color channel's value (0 - 255)."
	input ColorGreenValue(float) : "Sets the green color channel's value (0 - 255)."
	input ColorBlueValue(float) : "Sets the blue color channel's value (0 - 255)."
	input SetScale(float) : "Set the sprite's scale (0 - 8.0)."
	input HideSprite(void) : "Hide the sprite. Won't be drawn until the 'ShowSprite' input is received."
	input ShowSprite(void) : "Show the sprite."
	input ToggleSprite(void) : "Toggle the sprite between hidden and shown."
]

@PointClass base(env_sprite, Angles) sphere(GlowProxySize) = env_sprite_oriented :
    "A env_sprite that allows orientation."
[
	framerate(string) : "Framerate" : "10.0" : "Rate at which the sprite should animate, if at all."
	model(sprite) : "Sprite Name" : "sprites/glow01.spr" : "Material of the sprite to be drawn."
	scale(string) : "Scale" : "" : "Scale multiplier of the sprite."
	spawnflags(flags) =
	[
		1: "[1] Start on" : 0
		2: "[2] Play Once" : 0
	]

	GlowProxySize(float) : "Size of Glow Proxy Geometry." : "2.0" : "Size of the glow to be rendered for visibility testing. Must be larger than the distance from the sprite center to empty space.  So if this glow is inside geometry (like a light bulb), set this value to be bigger than the bulb's radius. Any time a sphere of this radius would be visible (poking through any nearby geometry), the glow will be rendered."

	HDRColorScale(float) : "HDR color scale." : "1.0" : "float value to multiply sprite color by when running in HDR mode."
	
	// Inputs
	input ColorRedValue(float) : "Sets the red color channel's value (0 - 255)."
	input ColorGreenValue(float) : "Sets the green color channel's value (0 - 255)."
	input ColorBlueValue(float) : "Sets the blue color channel's value (0 - 255)."
	input SetScale(float) : "Set the sprite's scale (0 - 8.0)."
	input HideSprite(void) : "Hide the sprite. Won't be drawn until the 'ShowSprite' input is received."
	input ShowSprite(void) : "Show the sprite."
	input ToggleSprite(void) : "Toggle the sprite between hidden and shown."
]


@PointClass base(Targetname, Angles) iconsprite("editor/env_wind.vmt") sphere(windradius) sphere(windradiusinner) = env_wind : 
	"An entity to control wind in the map."
[
	//gustsound(sound) : "Gust Sound Filename" : "" : "Sound to be played to simulate the gusting wind."
	minwind(integer) : "Min normal speed" : 20 : "Minimum speed of the wind while idling."
	maxwind(integer) : "Max normal speed" : 50 : "Maximum speed of the wind while idling."

	mingust(integer) : "Min gust speed" : 100 : "Minimum speed of wind gusts."
	maxgust(integer) : "Max gust speed" : 250 : "Maximum speed of wind gusts."

	mingustdelay(integer) : "Min gust delay" : 10 : "Minimum time delay between random gusts."
	maxgustdelay(integer) : "Max gust delay" : 20 : "Maximum time delay between random gusts."

	gustduration(integer) : "Gust Duration" : 5 : "How long will the wind gust for."

	gustdirchange(integer) : "Max gust dir change (degrees)" : 20 : "Maximum amount that the wind's direction changes due to a gust."
	
	treeswayscale(float) : "Tree sway scale" : "1.0" : "The scale at which this env_wind affects $treeSway. Set to 0 to not affect $treeSway. (Only one env_wind should affect $treeSway)"
	
	windradius(float) : "Radius" : "-1" : "The radius in which this env_wind should simulate wind. -1 = everywhere"
	windradiusinner(float) : "Inner Radius" : "0" : "The inner-radius for the env_wind, which enables varying intensities at certain distances. 0 = no inner radius"
	
	output OnGustStart(void) : "Fired when a wind gust begins."
	output OnGustEnd(void) : "Fired when a wind gust ends."
	
	input SetMinWind(float) : "Sets the minimum speed of the wind while idling."
	input SetMaxWind(float) : "Sets the maximum speed of the wind while idling."
	input SetMinGust(float) : "Sets the minimum speed of wind gusts."
	input SetMaxGust(float) : "Sets the maximum speed of wind gusts."
	input SetMinGustDelay(float) : "Sets the minimum time delay between random gusts."
	input SetMaxGustDelay(float) : "Sets the maximum time delay between random gusts."
	input SetGustDirChange(float) : "Sets the maximum amount that the wind's direction changes due to a gust."
	input SetGustDuration(float) : "Sets how long the wind will gust for."
	input SetWindRadius(float) : "Sets the radius in which this env_wind should simulate wind. -1 = everywhere"
	input SetWindRadiusInner(float) : "Sets the inner-radius for the env_wind, which enables varying intensities at certain distances. 0 = no inner radius"
	input SetTreeSwayScale(float) : "Sets the scale at which this env_wind affects $treeSway. Set to 0 to not affect $treeSway."
]

// We can't add a new sprite because the "scale" keyvalue makes it huge
@PointClass base(Targetname, Parentname, Angles) size(-16 -16 -16, 16 16 16) studio("models/editor/axis_helper.mdl") color(0 0 255) = sky_camera : 
	"An entity used to control the 3D Skybox. Its origin is used to determine the 3D Skybox's position relative to the map. Place this entity, in the 3D Skybox, at the point where the origin of the map should be."
[
	parentname(target_destination) : "Parent" : : "The name of the entity to move with. NOTE: sky_camera's position is normally only updated on spawn. Fire the ForceUpdate or StartUpdating inputs to update the sky_camera's position! You might also want to enable Use Angles for Sky."
	
	spawnflags(flags) =
	[
		1: "[1] Master (takes priority if multiple sky_cameras exist)" : 0
		2: "[2] Continuously update position (for moving sky_cameras)" : 0
	]
	
	skycolor(color255) : "Sky Color" : "255 255 255 0" : "Causes the skybox to use a solid color instead of the sky texture specified in worldspawn. Blended alpha is unfortunately not supported, but an alpha of '0' disables the effect and any alpha greater than that (e.g. 255) enables the effect."

	scale(integer) : "3D Skybox scale" : 16 : "Scale of the skybox."
	fogenable(choices) : "Fog Enable" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	fogblend(choices) : "Fog Blend" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	use_angles(choices) : "Use Angles for Fog Dir" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	use_angles_for_sky(choices) : "Use Angles for Sky" : 0 : "Uses angles for actual skybox rotation, as if the world were tilted on this entity's axis." =
	[
		0 : "No"
		1 : "Yes"
	]
	fogcolor(color255) : "Primary Fog Color" : "255 255 255"
	fogcolor2(color255) : "Secondary Fog Color" : "255 255 255"
	fogdir(string) : "Primary Fog Dir" : "1 0 0"
	fogstart(string) : "Fog Start" : "500.0" : "Distance at which the skybox fog should start."
	fogend(string) : "Fog End" : "2000.0" : "Distance at which the skybox fog should be fully opaque."
	fogmaxdensity(float) : "Fog Max Density [0..1]" : "1"
	
	farz(float) : "Far Z Clip Plane" : "0" : "Clips the sky."
	
	// Inputs
	input ForceUpdate(void) : "Forces the 3D skybox to update with this sky_camera's position."
	input StartUpdating(void) : "Begins per-tick skybox updating, which is needed if you want this sky_camera to move."
	input StopUpdating(void) : "Ends per-tick skybox updating if it was enabled before."
	
	input ActivateSkybox(void) : "Makes this sky_camera the active skybox."
	input DeactivateSkybox(void) : "Stops making this sky_camera the active skybox if it is currently the active skybox, which causes the sky to clear."
	
	input SetFogStartDist(float) : "Sets the fog start distance."
	input SetFogEndDist(float) : "Sets the fog end distance."
	input TurnOnFog(void) : "Turns the fog on."
	input TurnOffFog(void) : "Turns the fog off."
	input SetFogColor(color255) : "Sets the primary fog color."
	input SetFogColorSecondary(color255) : "Sets the secondary fog color."
	input SetFarZ(integer): "Sets the far clip plane distance."
	
	input SetSkyColor(color255) : "Sets the sky color."
	
	input CopyFogController(target_destination) : "Copies the target fog controller's exact fog parameters."
	input CopyFogControllerWithScale(target_destination) : "Copies the target fog controller's exact fog parameters."
	
	input SetScale(integer) : "Sets the skybox scale."
]

@BaseClass base(Targetname, ResponseContext) = BaseSpeaker
[
	delaymin(string) : "Min Delay Between Announcements" : "15"
	delaymax(string) : "Max Delay Between Announcements" : "135"
	spawnflags(flags) =
	[
		1: "[1] Start Silent" : 0
		2: "[2] Play Everywhere" : 0
	]
	rulescript(string) : "Context rule script" : "" : "Script file containing rules for playing appropriate sounds."
	concept(string) : "Concept name" : "" : "High level concept name used as primary search key."
	
	target(target_destination) : "Speaker entity" : "" : "All responses, including scenes, will be redirected to this entity if specified. Use the SetTarget input to change mid-game."

	// Inputs
	input TurnOn(void) : "Turn on the random announcements."
	input TurnOff(void) : "Turn off the random announcements."
	input Toggle(void) : "Toggle the random announcements off and on."
	input SetTarget(target_destination) : "Sets the speaker target."
	
	// Outputs
	output OnSpeak(string) : "Fires each time this env_speaker speaks, passing its selected response (scene path, sound name, etc.) as the parameter."
]

//-------------------------------------------------------------------------
//
// Game Entities
//
//-------------------------------------------------------------------------

@PointClass base(Targetname) = game_weapon_manager : 
	"An entity used to limit the number of a particular weapon type in the world. Useful in places where NPCs are spawning rapidly, dying, and dropping weapons." 
[
	weaponname(string) : "Weapon Classname" : "" : "Classname of the weapon type to limit."
	maxpieces(integer) : "Max Allowed in Level"	: 0 : "The maximum amount of the specified weapon type allowed in the world."
	ammomod(float)	   : "Ammo modifier" : 1 : 	"Modifier for ammount of ammo dropped by a weapon."

	// Inputs
	input SetAmmoModifier(float): "Adjust the ammo modifier."
]

@PointClass base(Targetname) iconsprite("editor/game_end.vmt") = game_end : 
	"An entity that ends a game." 
[
	//master(target_destination) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."
	input EndGame(void) : "End the multiplayer game."
	input EndGameSP(string) : "End the SP game. String could be a game-specific context."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = game_player_equip : 
	"An entity that gives equipment to the player who activates it. To use, add new keys to this entity, where each key is the classname of a weapon/item, and the corresponding value is the number of those weapons/items to give to the player who uses this entity. If the 'Use Only' spawnflag isn't set, then players can just touch this entity to get the equipment."
[
	spawnflags(flags) =
	[
		1: "[1] Use Only" : 0
	]
	//master(target_destination) : "Team Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."	
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = game_player_team : 
	"An entity that changes the team of the player who activates it."
[
	spawnflags(flags) =
	[
		1 : "[1] Remove On fire" : 0
		2 : "[2] Kill Player" : 0
		4 : "[4] Gib Player" : 0
	]
	target(target_destination) : "game_team_master to use" 
	//master(target_destination) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."	
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = game_score : 
	"An entity that awards/deducts points from the player who activates it." 
[
	spawnflags(flags) =
	[
		1: "[1] Allow Negative" : 0
		2: "[2] Team Points" : 0
	]

	points(integer) : "Points to add (+/-)" : 1
	//master(target_destination) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."
	
	// Inputs
	input ApplyScore(void) : "Add score to player."
]

@PointClass base(Targetname) iconsprite("editor/game_text.vmt") = game_text : 
	"An entity that displays text on player's screens." 
[
	spawnflags(flags) =
	[
		1: "[1] All Players" : 0
	]

	message(string) : "Message Text" : "" : "Message to display onscreen. Use '/n' for newlines."
	x(string) : "X (0 - 1.0 = left to right) (-1 centers)" : "-1" : "Horizontal position on the player's screens to draw the text. The value should be between 0 and 1, where 0 is the far left of the screen and 1 is the far right. -1 centers the text."
	y(string) : "Y (0 - 1.0 = top to bottom) (-1 centers)" : "-1" : "Vertical position on the player's screens to draw the text. The value should be between 0 and 1, where 0 is the top of the screen and 1 is the bottom. -1 centers the text."
	effect(Choices) : "Text Effect" : 0 =
	[
		0 : "Fade In/Out"
		1 : "Credits"
		2 : "Scan Out"
	]
	color(color255) : "Color1" : "100 100 100"
	color2(color255) : "Color2" : "240 110 0"
	fadein(string) : "Fade in Time (or character scan time)" : "1.5" : "The time it should take for the text to fully fade in."
	fadeout(string) : "Fade Out Time" : "0.5" : "The time it should take for the text to fade out, after the hold time has expired."
	holdtime(string) : "Hold Time" : "1.2" : "The time the text should stay onscreen, after fading in, before it begins to fade out."
	fxtime(string) : "Scan time (scan effect only)" : "0.25" : "If the 'Text Effect' is set to Scan Out, this is the time it should take to scan out all the letters in the text."
	channel(choices) : "Text Channel" : 1 : "You can have up to four individual game_text messages onscreen at once, stored in channels. Select which channel this text should be placed in, which will overwrite any active message already in that channel." =
	[
		0 : "Channel 0 (warning: may be used by some HUD elements)"
		1 : "Channel 1"
		2 : "Channel 2"
		3 : "Channel 3" 
		4 : "Channel 4"
		5 : "Channel 5 (warning: may be used by some HUD elements)"
	]
	master(target_destination) : "Master" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."
	
	autobreak(choices) : "Automatically break lines" : 0 : "Allows text to automatically shift to the next line whenever it can't fit on a player's screen. This accounts for a player's aspect ratio and adds hyphens when necessary." =
	[
		0: "No"
		1: "Yes"
	]

	// Inputs
	input Display(void) : "Display the message text."
	input SetText(string) : "Sets the message text."
]

@PointClass base(Targetname) iconsprite("editor/game_metadata.vmt") = game_metadata : 
	"An entity that provides metadata for things like Discord." 
[
	spawnflags(flags) =
	[
		1: "[1] Update Steam" : 1
		2: "[2] Update Discord" : 1
	]

	SetRPCState(string) : "RPC State" : "" : "Sets the 'state' that should be reported to rich presence clients like Discord. Shows the mod's name from gameinfo.txt by default."
	SetRPCDetails(string) : "RPC Details" : "" : "Sets the 'details' that should be reported to rich presence clients like Discord. Shows the map being played by default."
	
	input SetRPCState(string) : "Sets the RPC state."
	input SetRPCDetails(string) : "Sets the RPC details."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = skybox_swapper : 
	"An entity that swaps skybox textures." 
[
	SkyboxName(string) : "Sky Name" : "" : "The name of the sky texture to change to."
	
	input Trigger(void) : "Causes the current sky texture to change to the one specified in this entity."
]

@PointClass base(Parentname, Angles) size(-2 -2 -2, 2 2 2) = point_enable_motion_fixup : 
	"An entity used to move a motion-disabled prop when it enables motion. Parent this entity to the prop, and when the prop has its motion enabled, it will immediately teleport to the origin of this entity."
[
]

@PointClass base(Targetname, Parentname) size(-8 -8 -8, 8 8 8) sphere(radius) = point_message : 
	"An entity that displays a text message in the world, at its origin."
[
	spawnflags(flags) =
	[
		1: "[1] Start Disabled" : 0
	]

	message(string) : "Entity Message"
	radius(integer) : "Show message radius" : 128 : "Distance the player must be within to see this message."
	developeronly(choices) : "Developer Only?" : 0 : "If set, this message will only be visible when developer mode is on." =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input Enable(void) : "Start displaying the message text, if the player is within the message radius."
	input Disable(void) : "Stop displaying the message text."
	input SetMessage(string) : "Sets the message's text."
]

@PointClass base(point_message) size(-8 -8 -8, 8 8 8) sphere(radius) = point_message_localized : 
	"A variant of point_message that allows localized text and newline to be used."
[
	message(string) : "Localized Entity Message" : : "The message displayed by this entity. Use '/n' for newline."
]

// worldtext()
@PointClass base(Targetname, Parentname, Angles) studio("models/editor/axis_helper_thick.mdl") sphere(textsize) = vgui_text_display : 
	"Displays a VGui text label oriented in the world. Can be considered Mapbase's equivalent of point_worldtext. The panel itself can be displayed with the 'r_vguitext_bg' cvar."
[
	spawnflags(flags) =
	[
		1: "[1] Start Disabled" : 0
	]

	message(string) : "Entity Message" : : "The text to appear on the panel. Has a maximum of 256 characters. If you need more space, use a localization token."
	alignment(choices) : "Text Alignment" : 7 : "The text's alignment in relation to the panel size. With 'South', the text will be centered between the origin and the sphere's left bound relative to the angles the text is facing." =
	[
		0 : "[0] Northwest"
		1 : "[1] North"
		2 : "[2] Northeast"
		3 : "[3] West"
		4 : "[4] Center"
		5 : "[5] East"
		6 : "[6] Southwest"
		7 : "[7] South"
		8 : "[8] Southeast"
	]
	font(string) : "Font" : : "The font to use from resource/ClientScheme.res. A blank value is equivalent to the default font. Not all fonts may function. Commonly defined fonts include 'DefaultSmall' and 'Trebuchet18'/'Trebuchet24'."
	resolution(integer) : "Panel Resolution" : 200 : "The number of pixels available to the text. The higher the resolution is, the smaller the text will be. (NOTE: Changing the resolution with inputs later will scale the screen itself)"
	textsize(float) : "Panel Size" : 100 : "The size of the text panel in the world. This is previewed with a sphere, but it actually extends 'north-west' relative to the direction it's facing. Due to the limited in-editor previewing abilities, it's recommended to use the 'SetPanelSize' input in-game with the 'ent_fire' command to fine-tune this value. Use 'r_vguitext_bg' to display the panel in-game."
	
	renderamt(integer) : "Alpha (0 - 255)" : 255 : "The FX amount is used by the selected Render Mode."
	rendercolor(color255) : "Color" : "255 255 255"

	// Inputs
	input Enable(void) : "Start displaying the message text."
	input Disable(void) : "Stop displaying the message text."
	input Toggle(void) : "Toggle displaying the message text."
	input SetMessage(string) : "Set the message text."
	input SetTextAlignment(integer) : "Set text alignment by enum name."
	input SetResolution(integer) : "Set the resolution. Might affect screen size."
	input SetPanelSize(float) : "Set the text panel size."
]

@PointClass base(Targetname, Parentname, RenderFields, Angles, DXLevelChoice) studio("models/editor/cone_helper.mdl") = point_spotlight : 
	"An entity to draw a spotlight. Will draw a beam when the player views it side on, and a halo when it's facing towards the player. "+
	"Unless the 'No Dynamic Light' spawnflag is checked, it will also create a dynamic light wherever the end of the spotlight rests."
[
	spawnflags(Flags) = 
	[
		1 :  "[1] Start On" : 1
		2 :  "[2] No Dynamic Light" : 1
	]

	spotlightlength(integer) : "Spotlight Length" : 500 : "Length of the spotlight beam."
	spotlightwidth(integer) : "Spotlight Width" : 50 : "Width of the spotlight beam."
	rendercolor(color255) : "Color (R G B)" : "255 255 255"
	HDRColorScale(float) : "HDR color scale." : "1.0" : "float value to multiply sprite color by when running in HDR mode."
	HaloScale(float) : "Halo size scale." : "60" : "float value to determine the size of the halo."
	
	HaloMaterial(sprite) : "Halo material" : "sprites/light_glow03.vmt" : "Material to use for the halo."
	SpotlightMaterial(sprite) : "Spotlight beam material" : "sprites/glow_test02.vmt" : "Material to use for the spotlight's beam."
	
	// Inputs
	input LightOn(void) : "Turn the spotlight on."
	input LightOff(void) : "Turn the spotlight off"
	input LightToggle(void) : "Toggles the spotlight on or off"
	
	// outputs
	output OnLightOn(void) : "Fires when light turns on."
	output OnLightOff(void) : "Fires when light turns off."

]

@PointClass base(Targetname, Parentname) size(-8 -8 -8, 8 8 8) sphere(m_flRadius) = point_tesla : 
	"An entity that creates tesla lightning arcs around its origin."
[
	m_SourceEntityName(target_destination) : "Source Entity" : "" : "If specified, tesla lightning will originate from the specified entity. Otherwise, they originate from this entity."
	m_SoundName(sound) : "Sound Name" : "DoSpark" : "Sound to be played whenever lightning is created."

	texture(sprite) : "Sprite Name" : "sprites/physbeam.vmt" : "Material to use for the tesla lightning beams."

	m_Color(color255) : "Color" : "255 255 255"

	m_flRadius(integer) : "Radius" : 200 : "Radius around the origin to find a point to strike with a tesla lightning beam."

	beamcount_min(integer) : "Min # of Beams" : 6 : "Minimum number of tesla lightning beams to create when creating an arc."
	beamcount_max(integer) : "Max # of Beams" : 8 : "Maximum number of tesla lightning beams to create when creating an arc."
	
	thick_min(string) : "Min Beam Width" : "4" : "Minimum width of the tesla lightning beams."
	thick_max(string) : "Max Beam Width" : "5" : "Maximum width of the tesla lightning beams."
	
	lifetime_min(string) : "Min Time Visible" : "0.3" : "Minimum lifetime of the tesla lightning beams."
	lifetime_max(string) : "Max Time Visible" : "0.3" : "Maximum lifetime of the tesla lightning beams."
	
	interval_min(string) : "Min Time Between Arcs":"0.5" : "Minimum time delay between random arcing."
	interval_max(string) : "Max Time Between Arcs":"2" : "Maximum time delay between random arcing."

	// Inputs
	input TurnOn(void) : "Turn emitter on." 
	input TurnOff(void) : "Turn emitter off."
	input DoSpark(void) : "Force a single arc."
]

@PointClass base(Targetname) iconsprite("editor/clientcommand.vmt") = point_clientcommand : 
	"An entity that issues commands to the client console, as if it was typed in by the player (if activator is a player, or the local player in single player)."
[
	// Inputs
	input Command(string) : "Command to execute."
]

@PointClass base(Targetname) iconsprite("editor/servercommand.vmt") = point_servercommand : 
	"An entity that issues commands to the server console."
[
	// Inputs
	input Command(string) : "Command to execute."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = point_bonusmaps_accessor : 
	"An entity that relays bonus maps changes."
[
	filename(string) : "File Name" : ""
	mapname(string) : "Map Name" : ""

	// Inputs
	input Unlock(void) : "Unlocks the filename/map combination."
	input Complete(void) : "Completes the filename/map combination."
	input Save(void) : "Saves bonus map data."
]

@PointClass base(Targetname) iconsprite("editor/game_ui.vmt") = game_ui : 
	"An entity used to override player input when the player is looking at it."
[
	spawnflags(flags) =
	[
		32 : "[32] Freeze Player" : 1
		64 : "[64] Hide Weapon" : 1
		128 : "[128] +Use Deactivates" : 1
		256 : "[256] Jump Deactivates" : 1
	]
	
	FieldOfView(float) : "FieldOfView" : "-1.0" : "The amount of tolerance in the view checking when determining whether the player's input is still under control. 1.0 = straight ahead, 0.0 = +/- 90 degrees, -1.0 = all directions. If the player isn't within the tolerance, the player regains control."

	// Inputs
	input Deactivate(void) : "Return Player Control."
	input Activate(string) : "Take Player Control."
	
	input GetButtons(void) : "Fires OutButtons with the player's current button flags."

	// Outputs
	output PlayerOn(void) : "Fired whenever this entity starts controlling the player's input."
	output PlayerOff(void) : "Fired whenever this entity stops controlling the player's input."
	
	output OutButtons(integer) : "Outputs the player's current button flags when they are requested by the GetButtons input."
	
	output PressedMoveLeft(void) : "Fired whenever the player presses the moveleft key."
	output PressedMoveRight(void) : "Fired whenever the player presses the moveright key."
	output PressedForward(void) : "Fired whenever the player presses the forward key."
	output PressedBack(void) : "Fired whenever the player presses the backward key."
	output PressedAttack(void) : "Fired whenever the player presses the attack key."
	output PressedAttack2(void) : "Fired whenever the player presses the secondary attack key."
	output PressedAttack3(void) : "Fired whenever the player presses the tertiary attack key."
	output PressedUse(void) : "Fired whenever the player presses the use key."
	output PressedJump(void) : "Fired whenever the player presses the jump key."
	output PressedCrouch(void) : "Fired whenever the player presses the crouch key."
	output PressedSprint(void) : "Fired whenever the player presses the sprint key."
	output PressedReload(void) : "Fired whenever the player presses the reload key."

	output UnpressedMoveLeft(void) : "Fired whenever the player releases the moveleft key."
	output UnpressedMoveRight(void) : "Fired whenever the player releases the moveright key."
	output UnpressedForward(void) : "Fired whenever the player releases the forward key."
	output UnpressedBack(void) : "Fired whenever the player releases the backward key."
	output UnpressedAttack(void) : "Fired whenever the player releases the attack key."
	output UnpressedAttack2(void) : "Fired whenever the player releases the secondary attack key."
	output UnpressedAttack3(void) : "Fired whenever the player releases the tertiary attack key."
	output UnpressedUse(void) : "Fired whenever the player releases the use key."
	output UnpressedJump(void) : "Fired whenever the player releases the jump key."
	output UnpressedCrouch(void) : "Fired whenever the player releases the crouch key."
	output UnpressedSprint(void) : "Fired whenever the player releases the sprint key."
	output UnpressedReload(void) : "Fired whenever the player releases the reload key."

	output XAxis(string) : "An output that fires whenever the X axis of the player's input changes. i.e. -1 when the player has moveleft key down, 1 when the player has moveright key down, and 0 if neither."
	output YAxis(string) : "An output that fires whenever the Y axis of the player's input changes. i.e. -1 when the player has backward key down, 1 when the player has forward key down, and 0 if neither."
	output AttackAxis(string) : "An output that fires whenever the state of the player's attack key changes. i.e. 1 when the player has the attack key down, 0 otherwise."
	output Attack2Axis(string) : "An output that fires whenever the state of the player's secondary attack key changes. i.e. 1 when the player has the secondary attack key down, 0 otherwise."
]

@PointClass base(Targetname) = point_entity_finder :
	"An entity that will find an entity and pass it along as the !Caller with the OutEntity output.  Requires using !Caller as the parameter on the input."
[
	filtername(filterclass) : "Filter Name" : : "Filter to use to narrow set of findable entities. See filter_activator_name for more explanation."
	referencename(target_destination) : "Reference Entity" : "" : "Name of the entity to use when evaluating criteria.  For example, when using 'Nearest', this is the entity that distance will be measured from.  If left blank will use the point_entity_finder."

	Method(choices) : "Search Method" : "0" =
	[
		0 : "Nearest"
		1 : "Farthest"
		2 : "Random"
	]
	
	// Inputs
	input FindEntity(void) : "Find an entity that meets the specified criteria.  Will fire OutEntity if found and pass the entity as !Caller."

	// Outputs
	output OnFoundEntity(void) : "Fired when FindEntity is input and an entity was found. Passes the found entity as !Caller."
]

@PointClass base(Targetname) sphere(radius) = point_advanced_finder :
	"An enhanced entity finder that finds entities that pass a filter and fires OnFoundEntity for each of them."
[
	// 
	// This used to have an actual limit, 64, but now we've moved to a different model that has no limit.
	// "The number of entities that can be found by this finder. 0 = No limit. Cannot exceed 64 when firing mode isn't none or output delay is greater than zero."
	// 
	SearchFilter(filterclass) : "Filter Name" : : "The filter to use that finds what entit(ies) we're looking for."
	SearchPoint(target_destination) : "Search Point" : "" : "This is the entity in which distance and radius is measured from. Leave blank to use the finder itself."
	radius(float) : "Radius" : "0.0" : "The radius in which entities can be found. Leave 0 for infinite."
	NumberOfEntities(integer) : "Max Results" : 0 : "The number of entities that can be found by this finder. 0 = No limit."
	OutputDelay(float) : "Output Delay" : "0.0" : "OnFoundEntity fires once for each entity every X number of seconds. Deleted/killed/removed entities will not be skipped and a chain cannot be canceled, even if the finder is removed. Look into a more manual alternative if you do not want these side effects. Leave 0 for no delay."

	Method(choices) : "Search Method" : "0" =
	[
		-1 : "None (first in ent list)"
		0 : "Nearest"
		1 : "Farthest"
		2 : "Random"
	]
	
	// Inputs
	input BeginSearch(void) : "Begins finding entities with all of the current options."
	input SetSearchFilter(target_destination) : "Sets the search filter."
	input SetSearchPoint(target_destination) : "Sets the search point."
	input SetRadius(float) : "Sets the search radius."
	input SetMaxResults(integer) : "Sets the maximum entities that could be found by this finder."
	input SetOutputDelay(float) : "Sets the delay in between outputs."
	input SetFiringMethod(integer) : "Sets the search method."

	// Outputs
	output OnFoundEntity(ehandle) : "Fires for each entity found, passing it as the parameter and the activator."
	output OnSearchFailed(void) : "Fired when this finder couldn't find any entities."
]

@SolidClass base(Targetname, Parentname) = game_zone_player : 
	"An entity used to count the number of players within a zone."
[
	// Inputs
	input CountPlayersInZone(void) : "Count the number of players in the zone, and fire the corresponding outputs."

	// Outputs
	output OnPlayerInZone(void) : "Fired whenever a count finds a player inside the zone, with the player as the activator."
	output OnPlayerOutZone(void) : "Fired whenever a count finds a player outside the zone, with the player as the activator."
	output PlayersInCount(integer) : "Fired after a count, and contains the number of players found inside the zone."
	output PlayersOutCount(integer) : "Fired after a count, and contains the number of players found outside the zone."
]

//-------------------------------------------------------------------------
//
// Info Entities
//
//-------------------------------------------------------------------------

@PointClass base(Targetname) decal() studio("models/editor/axis_helper_thick.mdl") = infodecal : 
	"An entity that places a decal on the world. If the decal has no target name, it will immediately apply itself when the level is loaded. "+
	"If it has a name specified, it won't apply until it receives the 'Activate' input."
[
	texture(decal)

	LowPriority(choices) : "Low Priority (can be replaced)" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input Activate(void) : "Force the decal to apply itself to the world."
]

// A decal to be applied to a prop or the world using specified origin and orientation and radius, uses an orientation angle and a radius to determine
//  ray to cast for projection
@PointClass base(Angles, Targetname, Parentname) decal() studio("models/editor/axis_helper_thick.mdl") = info_projecteddecal : 
	"An entity that projects a decal onto the world (or props). If the decal has no target name, it will immediately apply itself when "+
	"the level is loaded. If it has a name specified, it won't apply until it receives the 'Activate' input."
[
	texture(decal)
	Distance(float) : "Distance" : 64 : "Distance from the origin to project the decal."

	// Inputs
	input Activate(void) : "Force the decal to apply itself to the world."
]

@PointClass = info_no_dynamic_shadow : 
	"Use this entity to mark surfaces that shouldn't receive dynamic shadows. Useful to apply to walls and floors "+
	"where shadows are drawn improperly, giving away the location of enemies."
[
	sides(sidelist) : "Brush faces"
]

@PointClass base(PlayerClass, Angles) studio("models/editor/playerstart.mdl") = info_player_start :
	"This entity indicates the position and facing direction at which the player will spawn. Any number of "+
	"info_player_start entities may be placed in a map for when working in cordoned-off portions of the map. "+
	"When multiple info_player_start entities are present in a map, set the 'Master' spawnflag on one of them "+
	"to indicate which one should be used when running the entire map."
[
	spawnflags(flags) =
	[
		1: "[1] Master (Has priority if multiple info_player_starts exist)" : 0
	]
]

@PointClass base(Targetname) size(-1 -1 0, 1 1 1) color(80 150 225) studio("models/editor/overlay_helper.mdl") sphere(fademindist) sphere(fademaxdist) overlay() = info_overlay : 
	"An entity that places an overlay on the world." 
[
	material(material) : "Material"
	sides(sidelist) : "Brush faces"
	RenderOrder(integer) : "Render Order" : 0 : "Higher values render after lower values. This value can be 0-3."
	StartU(float) : "U Start" : "0.0"
	EndU(float) : "U End" : "1.0"
	StartV(float) : "V Start" : "0.0"
	EndV(float) : "V End" : "1.0"
	BasisOrigin(Vector) readonly : "Overlay Basis Origin(Read-Only)"
	BasisU(Vector) readonly : "Overlay Basis U(Read-Only)"
	BasisV(Vector) readonly : "Overlay Basis V(Read-Only)"
	BasisNormal(Vector) readonly : "Overlay Basis Normal(Read-Only)"
	uv0(vector) readonly : "Overlay Point 1(Read-Only)"
	uv1(vector) readonly : "Overlay Point 2(Read-Only)"
	uv2(vector) readonly : "Overlay Point 3(Read-Only)"
	uv3(vector) readonly : "Overlay Point 4(Read-Only)"
	fademindist(float) : "Start Fade Dist" : -1 : "Distance at which the overlay starts to fade (<0 = use fademaxdist)."
	fademaxdist(float) : "End Fade Dist" : 0 : "Maximum distance at which the overlay is visible (0 = don't fade out)."
]

@PointClass size(-8 -8 -8, 8 8 8) sidelist(sides) sidelist(sides2) overlay_transition() = info_overlay_transition : "Overlay Transition" 
[
	material(material) : "Material"
	sides(sidelist) : "Brush faces"
	sides2(sidelist) : "Water faces"
	LengthTexcoordStart(float) : "Texcoord Length Start" : "0.0"
	LengthTexcoordEnd(float) : "Texcoord Length End" : "1.0"
	WidthTexcoordStart(float) : "Texcoord Width Start" : "0.0"
	WidthTexcoordEnd(float) : "Texcoord Width End" : "1.0"
	Width1(float) : "Width Land" : "25.0"
	Width2(float) : "Width Water" : "25.0"
	DebugDraw(integer) : "Show Debug" : 0 : "Boolean value (0 or 1)."
]

@PointClass size(-4 -4 -4, 4 4 4) color(0 180 0) = info_intermission : 
    "An entity that defines an intermission spot where dead players will float until they respawn."
[
	target(target_destination) : "Entity to look at" : : "Name of entity that dead players will face while in intermission at this spot."
]

@PointClass base(Targetname) iconsprite("editor/info_landmark") = info_landmark : 
	"An entity that acts as a landmark for transitions to another level. There should be a corresponding info_landmark entity in the next map. Entities will be transitioned to the next level relative to the info_landmark entities."
[
]

@PointClass base(Targetname) color(255 255 255) size(-8 -8 -8, 8 8 8) = info_null : 
	"An entity that's immediately removed on spawning. Useful as a spotlight target."
[
]

@SolidClass base(Targetname) color(255 255 255) = func_null :
	"A brush entity that's immediately removed upon spawning. Useful for invisible brush lights."
[
]

@PointClass base(Targetname, Parentname, Angles) iconsprite("editor/info_target.vmt")  = info_target : 
	"An entity that does nothing. Very useful as a positioning entity for other entities to refer to (i.e. the endpoint of an env_beam)"
[
	spawnflags( Flags ) =
	[
		1 : "[1] Transmit to client" : 0
		2 : "[2] Always transmit to client (ignore PVS)" : 0
	]
]

@PointClass base(Targetname, Parentname, Angles) studio("models/editor/cone_helper.mdl") line(255 255 255, targetname, cpoint1) line(255 255 255, targetname, cpoint2) line(255 255 255, targetname, cpoint3) line(255 255 255, targetname, cpoint4) line(255 255 255, targetname, cpoint5) line(255 255 255, targetname, cpoint6) line(255 255 255, targetname, cpoint7) line(255 255 255, targetname, cpoint8) line(255 255 255, targetname, cpoint9) line(255 255 255, targetname, cpoint10) line(255 255 255, targetname, cpoint11) line(255 255 255, targetname, cpoint12) line(255 255 255, targetname, cpoint13) line(255 255 255, targetname, cpoint14) line(255 255 255, targetname, cpoint15) line(255 255 255, targetname, cpoint16) line(255 255 255, targetname, cpoint17) line(255 255 255, targetname, cpoint18) line(255 255 255, targetname, cpoint19) line(255 255 255, targetname, cpoint20) line(255 255 255, targetname, cpoint21) line(255 255 255, targetname, cpoint22) line(255 255 255, targetname, cpoint23) line(255 255 255, targetname, cpoint24) line(255 255 255, targetname, cpoint25) line(255 255 255, targetname, cpoint26) line(255 255 255, targetname, cpoint27) line(255 255 255, targetname, cpoint28) line(255 255 255, targetname, cpoint29) line(255 255 255, targetname, cpoint30) line(255 255 255, targetname, cpoint31) line(255 255 255, targetname, cpoint32) line(255 255 255, targetname, cpoint33) line(255 255 255, targetname, cpoint34) line(255 255 255, targetname, cpoint35) line(255 255 255, targetname, cpoint36) line(255 255 255, targetname, cpoint37) line(255 255 255, targetname, cpoint38) line(255 255 255, targetname, cpoint39) line(255 255 255, targetname, cpoint40) line(255 255 255, targetname, cpoint41) line(255 255 255, targetname, cpoint42) line(255 255 255, targetname, cpoint43) line(255 255 255, targetname, cpoint44) line(255 255 255, targetname, cpoint45) line(255 255 255, targetname, cpoint46) line(255 255 255, targetname, cpoint47) line(255 255 255, targetname, cpoint48) line(255 255 255, targetname, cpoint49) line(255 255 255, targetname, cpoint50) line(255 255 255, targetname, cpoint51) line(255 255 255, targetname, cpoint52) line(255 255 255, targetname, cpoint53) line(255 255 255, targetname, cpoint54) line(255 255 255, targetname, cpoint55) line(255 255 255, targetname, cpoint56) line(255 255 255, targetname, cpoint57) line(255 255 255, targetname, cpoint58) line(255 255 255, targetname, cpoint59) line(255 255 255, targetname, cpoint60) line(255 255 255, targetname, cpoint61) line(255 255 255, targetname, cpoint62) line(255 255 255, targetname, cpoint63) = info_particle_system : 
	"An entity that spawns a particle system built using the particle editor."
[
	effect_name(string) : "Particle System Name"
	start_active(choices) : "Start Active?" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	flag_as_weather(choices) : "Flag as Weather?" : 0 : "Is this particle system going to be used as a weather effect?" =
	[
		0 : "No"
		1 : "Yes"
	]
	
	cpoint1(target_destination) : "Control Point 1" : : "If set, control point 1 of the effect will be at this entity's location."
	cpoint2(target_destination) : "Control Point 2" : : "If set, control point 2 of the effect will be at this entity's location. If control point 1 is not set, this will be ignored."
	cpoint3(target_destination) : "Control Point 3" : : "If set, control point 3 of the effect will be at this entity's location. If control point 2 is not set, this will be ignored."
	cpoint4(target_destination) : "Control Point 4" : : "If set, control point 4 of the effect will be at this entity's location. If control point 3 is not set, this will be ignored."
	cpoint5(target_destination) : "Control Point 5" : : "If set, control point 5 of the effect will be at this entity's location. If control point 4 is not set, this will be ignored."
	cpoint6(target_destination) : "Control Point 6" : : "If set, control point 6 of the effect will be at this entity's location. If control point 5 is not set, this will be ignored."
	cpoint7(target_destination) : "Control Point 7" : : "If set, control point 7 of the effect will be at this entity's location. If control point 6 is not set, this will be ignored."
	cpoint8(target_destination) : "Control Point 8" : : "If set, control point 8 of the effect will be at this entity's location. If control point 7 is not set, this will be ignored."
	cpoint9(target_destination) : "Control Point 9" : : "If set, control point 9 of the effect will be at this entity's location. If control point 8 is not set, this will be ignored."
	cpoint10(target_destination) : "Control Point 10" : : "If set, control point 10 of the effect will be at this entity's location. If control point 9 is not set, this will be ignored."
	cpoint11(target_destination) : "Control Point 11" : : "If set, control point 11 of the effect will be at this entity's location. If control point 10 is not set, this will be ignored."
	cpoint12(target_destination) : "Control Point 12" : : "If set, control point 12 of the effect will be at this entity's location. If control point 11 is not set, this will be ignored."
	cpoint13(target_destination) : "Control Point 13" : : "If set, control point 13 of the effect will be at this entity's location. If control point 12 is not set, this will be ignored."
	cpoint14(target_destination) : "Control Point 14" : : "If set, control point 14 of the effect will be at this entity's location. If control point 13 is not set, this will be ignored."
	cpoint15(target_destination) : "Control Point 15" : : "If set, control point 15 of the effect will be at this entity's location. If control point 14 is not set, this will be ignored."
	cpoint16(target_destination) : "Control Point 16" : : "If set, control point 16 of the effect will be at this entity's location. If control point 15 is not set, this will be ignored."
	cpoint17(target_destination) : "Control Point 17" : : "If set, control point 17 of the effect will be at this entity's location. If control point 16 is not set, this will be ignored."
	cpoint18(target_destination) : "Control Point 18" : : "If set, control point 18 of the effect will be at this entity's location. If control point 17 is not set, this will be ignored."
	cpoint19(target_destination) : "Control Point 19" : : "If set, control point 19 of the effect will be at this entity's location. If control point 18 is not set, this will be ignored."
	cpoint20(target_destination) : "Control Point 20" : : "If set, control point 20 of the effect will be at this entity's location. If control point 19 is not set, this will be ignored."
	cpoint21(target_destination) : "Control Point 21" : : "If set, control point 21 of the effect will be at this entity's location. If control point 10 is not set, this will be ignored."
	cpoint22(target_destination) : "Control Point 22" : : "If set, control point 22 of the effect will be at this entity's location. If control point 21 is not set, this will be ignored."
	cpoint23(target_destination) : "Control Point 23" : : "If set, control point 23 of the effect will be at this entity's location. If control point 22 is not set, this will be ignored."
	cpoint24(target_destination) : "Control Point 24" : : "If set, control point 24 of the effect will be at this entity's location. If control point 23 is not set, this will be ignored."
	cpoint25(target_destination) : "Control Point 25" : : "If set, control point 25 of the effect will be at this entity's location. If control point 24 is not set, this will be ignored."
	cpoint26(target_destination) : "Control Point 26" : : "If set, control point 26 of the effect will be at this entity's location. If control point 25 is not set, this will be ignored."
	cpoint27(target_destination) : "Control Point 27" : : "If set, control point 27 of the effect will be at this entity's location. If control point 26 is not set, this will be ignored."
	cpoint28(target_destination) : "Control Point 28" : : "If set, control point 28 of the effect will be at this entity's location. If control point 27 is not set, this will be ignored."
	cpoint29(target_destination) : "Control Point 29" : : "If set, control point 29 of the effect will be at this entity's location. If control point 28 is not set, this will be ignored."
	cpoint30(target_destination) : "Control Point 30" : : "If set, control point 30 of the effect will be at this entity's location. If control point 29 is not set, this will be ignored."
	cpoint31(target_destination) : "Control Point 31" : : "If set, control point 31 of the effect will be at this entity's location. If control point 30 is not set, this will be ignored."
	cpoint32(target_destination) : "Control Point 32" : : "If set, control point 32 of the effect will be at this entity's location. If control point 31 is not set, this will be ignored."
	cpoint33(target_destination) : "Control Point 33" : : "If set, control point 33 of the effect will be at this entity's location. If control point 32 is not set, this will be ignored."
	cpoint34(target_destination) : "Control Point 34" : : "If set, control point 34 of the effect will be at this entity's location. If control point 33 is not set, this will be ignored."
	cpoint35(target_destination) : "Control Point 35" : : "If set, control point 35 of the effect will be at this entity's location. If control point 34 is not set, this will be ignored."
	cpoint36(target_destination) : "Control Point 36" : : "If set, control point 36 of the effect will be at this entity's location. If control point 35 is not set, this will be ignored."
	cpoint37(target_destination) : "Control Point 37" : : "If set, control point 37 of the effect will be at this entity's location. If control point 36 is not set, this will be ignored."
	cpoint38(target_destination) : "Control Point 38" : : "If set, control point 38 of the effect will be at this entity's location. If control point 37 is not set, this will be ignored."
	cpoint39(target_destination) : "Control Point 39" : : "If set, control point 39 of the effect will be at this entity's location. If control point 38 is not set, this will be ignored."
	cpoint40(target_destination) : "Control Point 40" : : "If set, control point 40 of the effect will be at this entity's location. If control point 39 is not set, this will be ignored."
	cpoint41(target_destination) : "Control Point 41" : : "If set, control point 41 of the effect will be at this entity's location. If control point 40 is not set, this will be ignored."
	cpoint42(target_destination) : "Control Point 42" : : "If set, control point 42 of the effect will be at this entity's location. If control point 41 is not set, this will be ignored."
	cpoint43(target_destination) : "Control Point 43" : : "If set, control point 43 of the effect will be at this entity's location. If control point 42 is not set, this will be ignored."
	cpoint44(target_destination) : "Control Point 44" : : "If set, control point 44 of the effect will be at this entity's location. If control point 43 is not set, this will be ignored."
	cpoint45(target_destination) : "Control Point 45" : : "If set, control point 45 of the effect will be at this entity's location. If control point 44 is not set, this will be ignored."
	cpoint46(target_destination) : "Control Point 46" : : "If set, control point 46 of the effect will be at this entity's location. If control point 45 is not set, this will be ignored."
	cpoint47(target_destination) : "Control Point 47" : : "If set, control point 47 of the effect will be at this entity's location. If control point 46 is not set, this will be ignored."
	cpoint48(target_destination) : "Control Point 48" : : "If set, control point 48 of the effect will be at this entity's location. If control point 47 is not set, this will be ignored."
	cpoint49(target_destination) : "Control Point 49" : : "If set, control point 49 of the effect will be at this entity's location. If control point 48 is not set, this will be ignored."
	cpoint50(target_destination) : "Control Point 50" : : "If set, control point 50 of the effect will be at this entity's location. If control point 49 is not set, this will be ignored."
	cpoint51(target_destination) : "Control Point 51" : : "If set, control point 51 of the effect will be at this entity's location. If control point 50 is not set, this will be ignored."
	cpoint52(target_destination) : "Control Point 52" : : "If set, control point 52 of the effect will be at this entity's location. If control point 51 is not set, this will be ignored."
	cpoint53(target_destination) : "Control Point 53" : : "If set, control point 53 of the effect will be at this entity's location. If control point 52 is not set, this will be ignored."
	cpoint54(target_destination) : "Control Point 54" : : "If set, control point 54 of the effect will be at this entity's location. If control point 53 is not set, this will be ignored."
	cpoint55(target_destination) : "Control Point 55" : : "If set, control point 55 of the effect will be at this entity's location. If control point 54 is not set, this will be ignored."
	cpoint56(target_destination) : "Control Point 56" : : "If set, control point 56 of the effect will be at this entity's location. If control point 55 is not set, this will be ignored."
	cpoint57(target_destination) : "Control Point 57" : : "If set, control point 57 of the effect will be at this entity's location. If control point 56 is not set, this will be ignored."
	cpoint58(target_destination) : "Control Point 58" : : "If set, control point 58 of the effect will be at this entity's location. If control point 57 is not set, this will be ignored."
	cpoint59(target_destination) : "Control Point 59" : : "If set, control point 59 of the effect will be at this entity's location. If control point 58 is not set, this will be ignored."
	cpoint60(target_destination) : "Control Point 60" : : "If set, control point 60 of the effect will be at this entity's location. If control point 59 is not set, this will be ignored."
	cpoint61(target_destination) : "Control Point 61" : : "If set, control point 61 of the effect will be at this entity's location. If control point 60 is not set, this will be ignored."
	cpoint62(target_destination) : "Control Point 62" : : "If set, control point 62 of the effect will be at this entity's location. If control point 61 is not set, this will be ignored."
	cpoint63(target_destination) : "Control Point 63" : : "If set, control point 63 of the effect will be at this entity's location. If control point 62 is not set, this will be ignored."
	
	cpoint1_parent(integer) : "Control Point 1's Parent" : 0 : "If set and nonzero, control point 1 of the effect will use this point for its parent."
	cpoint2_parent(integer) : "Control Point 2's Parent" : 0 : "If set and nonzero, control point 2 of the effect will use this point for its parent."
	cpoint3_parent(integer) : "Control Point 3's Parent" : 0 : "If set and nonzero, control point 3 of the effect will use this point for its parent."
	cpoint4_parent(integer) : "Control Point 4's Parent" : 0 : "If set and nonzero, control point 4 of the effect will use this point for its parent."
	cpoint5_parent(integer) : "Control Point 5's Parent" : 0 : "If set and nonzero, control point 5 of the effect will use this point for its parent."
	cpoint6_parent(integer) : "Control Point 6's Parent" : 0 : "If set and nonzero, control point 6 of the effect will use this point for its parent."
	cpoint7_parent(integer) : "Control Point 7's Parent" : 0 : "If set and nonzero, control point 7 of the effect will use this point for its parent."

	// Inputs
	input Start(void) : "Tells the particle system to start emitting."
	input Stop(void) : "Tells the particle system to stop emitting."
	input DestroyImmediately(void) : "Makes the particle system stop emitting and remove its existing particles immediately."
]

@PointClass base(Targetname, Parentname, Angles) studio("models/editor/cone_helper.mdl") line(255 255 255, targetname, cpoint1) line(255 255 255, targetname, cpoint2) line(255 255 255, targetname, cpoint3) line(255 255 255, targetname, cpoint4) line(255 255 255, targetname, cpoint5) line(255 255 255, targetname, cpoint6) line(255 255 255, targetname, cpoint7) line(255 255 255, targetname, cpoint8) line(255 255 255, targetname, cpoint9) line(255 255 255, targetname, cpoint10) line(255 255 255, targetname, cpoint11) line(255 255 255, targetname, cpoint12) line(255 255 255, targetname, cpoint13) line(255 255 255, targetname, cpoint14) line(255 255 255, targetname, cpoint15) line(255 255 255, targetname, cpoint16) line(255 255 255, targetname, cpoint17) line(255 255 255, targetname, cpoint18) line(255 255 255, targetname, cpoint19) line(255 255 255, targetname, cpoint20) line(255 255 255, targetname, cpoint21) line(255 255 255, targetname, cpoint22) line(255 255 255, targetname, cpoint23) line(255 255 255, targetname, cpoint24) line(255 255 255, targetname, cpoint25) line(255 255 255, targetname, cpoint26) line(255 255 255, targetname, cpoint27) line(255 255 255, targetname, cpoint28) line(255 255 255, targetname, cpoint29) line(255 255 255, targetname, cpoint30) line(255 255 255, targetname, cpoint31) line(255 255 255, targetname, cpoint32) line(255 255 255, targetname, cpoint33) line(255 255 255, targetname, cpoint34) line(255 255 255, targetname, cpoint35) line(255 255 255, targetname, cpoint36) line(255 255 255, targetname, cpoint37) line(255 255 255, targetname, cpoint38) line(255 255 255, targetname, cpoint39) line(255 255 255, targetname, cpoint40) line(255 255 255, targetname, cpoint41) line(255 255 255, targetname, cpoint42) line(255 255 255, targetname, cpoint43) line(255 255 255, targetname, cpoint44) line(255 255 255, targetname, cpoint45) line(255 255 255, targetname, cpoint46) line(255 255 255, targetname, cpoint47) line(255 255 255, targetname, cpoint48) line(255 255 255, targetname, cpoint49) line(255 255 255, targetname, cpoint50) line(255 255 255, targetname, cpoint51) line(255 255 255, targetname, cpoint52) line(255 255 255, targetname, cpoint53) line(255 255 255, targetname, cpoint54) line(255 255 255, targetname, cpoint55) line(255 255 255, targetname, cpoint56) line(255 255 255, targetname, cpoint57) line(255 255 255, targetname, cpoint58) line(255 255 255, targetname, cpoint59) line(255 255 255, targetname, cpoint60) line(255 255 255, targetname, cpoint61) line(255 255 255, targetname, cpoint62) line(255 255 255, targetname, cpoint63) = info_particle_system_coordinate : 
	"An entity that spawns a particle system built using the particle editor."
[
	effect_name(string) : "Particle System Name"
	start_active(choices) : "Start Active?" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	flag_as_weather(choices) : "Flag as Weather?" : 0 : "Is this particle system going to be used as a weather effect?" =
	[
		0 : "No"
		1 : "Yes"
	]	
	cpoint1(origin) : "Control Point 1" : : "If set, control point 1 of the effect will be at this location."
	cpoint2(origin) : "Control Point 2" : : "If set, control point 2 of the effect will be at this location. If control point 1 is not set, this will be ignored."
	cpoint3(origin) : "Control Point 3" : : "If set, control point 3 of the effect will be at this location. If control point 2 is not set, this will be ignored."
	cpoint4(origin) : "Control Point 4" : : "If set, control point 4 of the effect will be at this location. If control point 3 is not set, this will be ignored."
	cpoint5(origin) : "Control Point 5" : : "If set, control point 5 of the effect will be at this location. If control point 4 is not set, this will be ignored."
	cpoint6(origin) : "Control Point 6" : : "If set, control point 6 of the effect will be at this location. If control point 5 is not set, this will be ignored."
	cpoint7(origin) : "Control Point 7" : : "If set, control point 7 of the effect will be at this location. If control point 6 is not set, this will be ignored."
	cpoint8(origin) : "Control Point 8" : : "If set, control point 8 of the effect will be at this location. If control point 7 is not set, this will be ignored."
	cpoint9(origin) : "Control Point 9" : : "If set, control point 9 of the effect will be at this location. If control point 8 is not set, this will be ignored."
	cpoint10(origin) : "Control Point 10" : : "If set, control point 10 of the effect will be at this location. If control point 9 is not set, this will be ignored."
	cpoint11(origin) : "Control Point 11" : : "If set, control point 11 of the effect will be at this location. If control point 10 is not set, this will be ignored."
	cpoint12(origin) : "Control Point 12" : : "If set, control point 12 of the effect will be at this location. If control point 11 is not set, this will be ignored."
	cpoint13(origin) : "Control Point 13" : : "If set, control point 13 of the effect will be at this location. If control point 12 is not set, this will be ignored."
	cpoint14(origin) : "Control Point 14" : : "If set, control point 14 of the effect will be at this location. If control point 13 is not set, this will be ignored."
	cpoint15(origin) : "Control Point 15" : : "If set, control point 15 of the effect will be at this location. If control point 14 is not set, this will be ignored."
	cpoint16(origin) : "Control Point 16" : : "If set, control point 16 of the effect will be at this location. If control point 15 is not set, this will be ignored."
	cpoint17(origin) : "Control Point 17" : : "If set, control point 17 of the effect will be at this location. If control point 16 is not set, this will be ignored."
	cpoint18(origin) : "Control Point 18" : : "If set, control point 18 of the effect will be at this location. If control point 17 is not set, this will be ignored."
	cpoint19(origin) : "Control Point 19" : : "If set, control point 19 of the effect will be at this location. If control point 18 is not set, this will be ignored."
	cpoint20(origin) : "Control Point 20" : : "If set, control point 20 of the effect will be at this location. If control point 19 is not set, this will be ignored."
	cpoint21(origin) : "Control Point 21" : : "If set, control point 21 of the effect will be at this location. If control point 10 is not set, this will be ignored."
	cpoint22(origin) : "Control Point 22" : : "If set, control point 22 of the effect will be at this location. If control point 21 is not set, this will be ignored."
	cpoint23(origin) : "Control Point 23" : : "If set, control point 23 of the effect will be at this location. If control point 22 is not set, this will be ignored."
	cpoint24(origin) : "Control Point 24" : : "If set, control point 24 of the effect will be at this location. If control point 23 is not set, this will be ignored."
	cpoint25(origin) : "Control Point 25" : : "If set, control point 25 of the effect will be at this location. If control point 24 is not set, this will be ignored."
	cpoint26(origin) : "Control Point 26" : : "If set, control point 26 of the effect will be at this location. If control point 25 is not set, this will be ignored."
	cpoint27(origin) : "Control Point 27" : : "If set, control point 27 of the effect will be at this location. If control point 26 is not set, this will be ignored."
	cpoint28(origin) : "Control Point 28" : : "If set, control point 28 of the effect will be at this location. If control point 27 is not set, this will be ignored."
	cpoint29(origin) : "Control Point 29" : : "If set, control point 29 of the effect will be at this location. If control point 28 is not set, this will be ignored."
	cpoint30(origin) : "Control Point 30" : : "If set, control point 30 of the effect will be at this location. If control point 29 is not set, this will be ignored."
	cpoint31(origin) : "Control Point 31" : : "If set, control point 31 of the effect will be at this location. If control point 30 is not set, this will be ignored."
	cpoint32(origin) : "Control Point 32" : : "If set, control point 32 of the effect will be at this location. If control point 31 is not set, this will be ignored."
	cpoint33(origin) : "Control Point 33" : : "If set, control point 33 of the effect will be at this location. If control point 32 is not set, this will be ignored."
	cpoint34(origin) : "Control Point 34" : : "If set, control point 34 of the effect will be at this location. If control point 33 is not set, this will be ignored."
	cpoint35(origin) : "Control Point 35" : : "If set, control point 35 of the effect will be at this location. If control point 34 is not set, this will be ignored."
	cpoint36(origin) : "Control Point 36" : : "If set, control point 36 of the effect will be at this location. If control point 35 is not set, this will be ignored."
	cpoint37(origin) : "Control Point 37" : : "If set, control point 37 of the effect will be at this location. If control point 36 is not set, this will be ignored."
	cpoint38(origin) : "Control Point 38" : : "If set, control point 38 of the effect will be at this location. If control point 37 is not set, this will be ignored."
	cpoint39(origin) : "Control Point 39" : : "If set, control point 39 of the effect will be at this location. If control point 38 is not set, this will be ignored."
	cpoint40(origin) : "Control Point 40" : : "If set, control point 40 of the effect will be at this location. If control point 39 is not set, this will be ignored."
	cpoint41(origin) : "Control Point 41" : : "If set, control point 41 of the effect will be at this location. If control point 40 is not set, this will be ignored."
	cpoint42(origin) : "Control Point 42" : : "If set, control point 42 of the effect will be at this location. If control point 41 is not set, this will be ignored."
	cpoint43(origin) : "Control Point 43" : : "If set, control point 43 of the effect will be at this location. If control point 42 is not set, this will be ignored."
	cpoint44(origin) : "Control Point 44" : : "If set, control point 44 of the effect will be at this location. If control point 43 is not set, this will be ignored."
	cpoint45(origin) : "Control Point 45" : : "If set, control point 45 of the effect will be at this location. If control point 44 is not set, this will be ignored."
	cpoint46(origin) : "Control Point 46" : : "If set, control point 46 of the effect will be at this location. If control point 45 is not set, this will be ignored."
	cpoint47(origin) : "Control Point 47" : : "If set, control point 47 of the effect will be at this location. If control point 46 is not set, this will be ignored."
	cpoint48(origin) : "Control Point 48" : : "If set, control point 48 of the effect will be at this location. If control point 47 is not set, this will be ignored."
	cpoint49(origin) : "Control Point 49" : : "If set, control point 49 of the effect will be at this location. If control point 48 is not set, this will be ignored."
	cpoint50(origin) : "Control Point 50" : : "If set, control point 50 of the effect will be at this location. If control point 49 is not set, this will be ignored."
	cpoint51(origin) : "Control Point 51" : : "If set, control point 51 of the effect will be at this location. If control point 50 is not set, this will be ignored."
	cpoint52(origin) : "Control Point 52" : : "If set, control point 52 of the effect will be at this location. If control point 51 is not set, this will be ignored."
	cpoint53(origin) : "Control Point 53" : : "If set, control point 53 of the effect will be at this location. If control point 52 is not set, this will be ignored."
	cpoint54(origin) : "Control Point 54" : : "If set, control point 54 of the effect will be at this location. If control point 53 is not set, this will be ignored."
	cpoint55(origin) : "Control Point 55" : : "If set, control point 55 of the effect will be at this location. If control point 54 is not set, this will be ignored."
	cpoint56(origin) : "Control Point 56" : : "If set, control point 56 of the effect will be at this location. If control point 55 is not set, this will be ignored."
	cpoint57(origin) : "Control Point 57" : : "If set, control point 57 of the effect will be at this location. If control point 56 is not set, this will be ignored."
	cpoint58(origin) : "Control Point 58" : : "If set, control point 58 of the effect will be at this location. If control point 57 is not set, this will be ignored."
	cpoint59(origin) : "Control Point 59" : : "If set, control point 59 of the effect will be at this location. If control point 58 is not set, this will be ignored."
	cpoint60(origin) : "Control Point 60" : : "If set, control point 60 of the effect will be at this location. If control point 59 is not set, this will be ignored."
	cpoint61(origin) : "Control Point 61" : : "If set, control point 61 of the effect will be at this location. If control point 60 is not set, this will be ignored."
	cpoint62(origin) : "Control Point 62" : : "If set, control point 62 of the effect will be at this location. If control point 61 is not set, this will be ignored."
	cpoint63(origin) : "Control Point 63" : : "If set, control point 63 of the effect will be at this location. If control point 62 is not set, this will be ignored."
	
	cpoint1_parent(integer) : "Control Point 1's Parent" : 0 : "If set and nonzero, control point 1 of the effect will use this point for its parent."
	cpoint2_parent(integer) : "Control Point 2's Parent" : 0 : "If set and nonzero, control point 2 of the effect will use this point for its parent."
	cpoint3_parent(integer) : "Control Point 3's Parent" : 0 : "If set and nonzero, control point 3 of the effect will use this point for its parent."
	cpoint4_parent(integer) : "Control Point 4's Parent" : 0 : "If set and nonzero, control point 4 of the effect will use this point for its parent."
	cpoint5_parent(integer) : "Control Point 5's Parent" : 0 : "If set and nonzero, control point 5 of the effect will use this point for its parent."
	cpoint6_parent(integer) : "Control Point 6's Parent" : 0 : "If set and nonzero, control point 6 of the effect will use this point for its parent."
	cpoint7_parent(integer) : "Control Point 7's Parent" : 0 : "If set and nonzero, control point 7 of the effect will use this point for its parent."

	// Inputs
	input Start(void) : "Tells the particle system to start emitting."
	input Stop(void) : "Tells the particle system to stop emitting."
	input DestroyImmediately(void) : "Makes the particle system stop emitting and remove its existing particles immediately."
]


@PointClass base(Targetname, EnableDisable, Parentname, Angles) iconsprite("editor/info_target.vmt") sphere(radius) = phys_ragdollmagnet : 
	"An entity that acts like a magnet for ragdolls. Useful for crafting exaggerated ragdoll behavior (i.e. guys falling over rails on death). If the "+
	"Bar Magnet spawnflag is set, the magnet works like it was a cylindrical magnet i.e. it attracts ragdolls to the nearest point on a line."
[
	axis(vecline) : "Bar Magnet Axis"
	radius(float) : "Effective Radius" : "512" : "Radius in which ragdolls are affected around this entity's origin."
	force(float) : "Force" : "5000" : "Magnetic force to apply to ragdolls within the radius. Expressed as kilograms per inch per second. So a force of 1000 will add 10 units/second to a 100kg man. It will add 100 units per second to a 10kg headcrab."
	BoneTarget(string) : "Bone Target" : : "Targets a specific bone to apply the force to. (e.g. ValveBiped.Bip01_R_Foot)"

	target(target_destination) : "Entity to affect" : "" : "If specified, the phys_ragdollmagnet will only affect the target entity."

	spawnflags( Flags ) =
	[
		2 : "[2] Bar Magnet (use axis helper)" : 0
	]
	
	// Outputs
	output OnUsed(vector) : "Fires when this magnet is used by a ragdoll. Passes the ragdoll's original force + the force this magnet has applied."
]

@PointClass base(Targetname) iconsprite("editor/info_lighting.vmt")  = info_lighting : 
	"An entity that can be used to change the lighting origin of a prop_static. Set the prop_static's Lighting Origin to point at this entity to "+
	"make the prop_static light as if it was at the info_lighting's origin. Good for prop_static entities that are embedded in world geometry (like rocks/windows/etc)."
[
]

// This is obsolete, info_target is all you need now.
@PointClass base(Targetname, Parentname, Angles, PlayerClass) studio("models/editor/playerstart.mdl") = info_teleport_destination : 
	"An entity that does nothing itself, but can be used to specify the destination for a trigger_teleport entity. An info_target can be used instead."
[
]


//-------------------------------------------------------------------------
//
// Nodes and Hints
//
//-------------------------------------------------------------------------

@PointClass base(Node) studio("models/editor/ground_node.mdl") color(232 219 8) = info_node :
	"A navigation node for ground moving NPCs. Navigation nodes are baked into the nodegraph so that NPCs can move " +
	"to them. Ground nodes fall to the ground when they spawn."
[
	spawnflags(Flags) = 
	[
		1 : "[1] Force human permission" : 0
		2 : "[2] Force small_centered permission" : 0
		4 : "[4] Force wide_human permission" : 0
		8 : "[8] Force tiny permissiont" : 0
		16 : "[16] Force wide_short permission" : 0
		32 : "[32] Force medium permission" : 0
		64 : "[64] Force tiny_centered permission" : 0
		128 : "[128] Force large permission" : 0
		256 : "[256] Force large_centered permission" : 0
		512 : "[512] Keep editor position" : 0
	]
]

@PointClass base(Targetname, Angles, HintNode) studio("models/editor/ground_node_hint.mdl") sphere(radius) color(232 219 8) = info_node_hint :
	"A navigation node for ground moving NPCs that includes some context information for NPCs that are interested in it. The hint might " +
	"indicate a window that could be looked out of, or an item of interest that could be commented on. Many hint nodes are NPC-specific, " +
	"so it's helpful to use naming conventions like 'Crow: Fly to point' in the hint choices list. The angles of a hint node indicate what direction " +
	"the NPC should face to perform the hint behavior.\n\n" +
	"It's important to understand the distinction between scripts, such as scripted_sequence and scripted_schedule, and info_hint entities. Scripts summon " +
	"NPCs to specific cue points to play their parts, while hints provide context information to the AI that they use to perform their " +
	"behaviors. Hints require code support in the NPC, while scripts are generic and may require only animations to play. Use a hint if the behavior is driven " +
	"by the AI, use a script if the behavior is driven by the map."

[
	// Outputs
	output OnNPCStartedUsing(string) : "Fired when an NPC has reached this node and started using it. Passes along the NPC."
	output OnNPCStoppedUsing(string) : "Fired when an NPC has stopped using this node. Passes along the NPC."
]

@PointClass base(Node) studio("models/editor/air_node.mdl") color(232 171 8)  = info_node_air :
	"A navigation node for flying NPCs. Air navigation nodes are baked into the nodegraph so that NPCs can move " +
	"to them. Air nodes do not fall to the ground when they spawn."
[
	nodeheight(integer) : "NodeHeight"  : 0
]

@PointClass base(Angles, Targetname, HintNode) studio("models/editor/air_node_hint.mdl") sphere(radius) color(232 171 8) line(255 255 255, nodeid, TargetNode) = info_node_air_hint :
	"A navigation node for flying NPCs that includes some context information for NPCs that are interested in it. The hint might " +
	"indicate a window that could be looked into, or an item of interest that could be commented on. Many hint nodes are NPC-specific, " +
	"so it's helpful to use naming conventions like 'Crow: Fly to point' in the hint choices list. The angles of a hint node indicate what direction " +
	"the NPC should face to perform the hint behavior."

[
	nodeheight(integer) : "NodeHeight"  : 0
]

@PointClass base(Targetname, Angles, HintNode) studio("models/editor/node_hint.mdl") sphere(radius) color(255 255 255) frustum(nodeFOV,-1,128,250 250 250,-1) = info_hint :
	"A hint that is not used for navigation. They don't go into the nodegraph, nor do they fall to the ground. Use these to provide " +
	"some spatial context for NPCs, such as 'look here if you can't find the player' or 'throw rocks at this spot'."
[
]

// size(-8 -8 -8, 8 8 8)
@PointClass base(Targetname) color(220 180 0) iconsprite("editor/info_node_link.vmt") line(255 255 255, nodeid, StartNode, nodeid, EndNode) = info_node_link :
	"A dynamic connection between two navigation nodes. You specify the node IDs of the start and end nodes, and then you can use entity I/O " +
	"to turn on and off the connection. This could be used to create or destroy a connection in the nodegraph because of some event in your map " +
	"(a bridge being created/destroyed, etc)."
[
    StartNode(node_dest) : "Start node ID" : : "The node ID of one end of the node connection."
    EndNode(node_dest) : "End node ID" : : "The node ID of one end of the node connection."
	initialstate(choices) : "Initial State" : 1 =
	[
		0 : "Off"
		1 : "On"
	]

	linktype(choices) : "Type of Connection" : 1 =
	[
		1 : "Ground"
		2 : "Jump"
		4 : "Fly"
		8 : "Climb"
	]
	AllowUse(target_name_or_class) : "Allow Pass When Off" : : "Entity or class to allow passage even when node is off"
	InvertAllow(choices) : "Invert exclusion rules" : 0 : "Allowed entity is the only entity NOT allowed when this is set to 'yes'. The link must still be disabled for exclusion rules to apply." =
	[
		0 : "No"
		1 : "Yes"
	]

	spawnflags( Flags ) =
	[
		1 : "[1] Force human connect" : 0
		2 : "[2] Force small_centered connect" : 0
		4 : "[4] Force wide_human connect" : 0
		8 : "[8] Force tiny connect" : 0
		16 : "[16] Force wide_short connect" : 0
		32 : "[32] Force medium connect" : 0
		64 : "[64] Force tiny_centered connect" : 0
		128 : "[128] Force large connect" : 0
		256 : "[256] Force large_centered connect" : 0
		512 : "[512] Force medium_tall connect" : 0
	]

	// Inputs
	input TurnOn(void) : "Turn the link on."
	input TurnOff(void) : "Turn the link off."
]

@PointClass base(info_node_link) color(220 180 0) iconsprite("editor/info_node_link.vmt") line(255 255 255, nodeid, StartNode, nodeid, EndNode) = info_node_link_oneway :
	"A variant of info_node_link that only works from one direction. " +
	"Navigation requests from the start node to the end node will always pass, but requests from the end node to the start node will not be allowed. " +
	"If the link is disabled, the link will work from neither direction. Exclusion rules still apply and excluded NPCs will be able to cross from the opposite direction."
[
    StartNode(node_dest) : "Start node ID" : : "The node ID that will always be allowed to pass."
    EndNode(node_dest) : "End node ID" : : "The node ID that will not be allowed to pass unless the NPC follows exclusion rules."
	
	AllowUse(target_name_or_class) : "Allow Pass When Off" : : "Entity or class to allow passage regardless of which node they're coming from."
	
	Usage(choices) : "Usage" : 0 : "Causes the link to use slightly different behavior." =
	[
		0 : "Enabled is one-way, disabled turns off link"
		1 : "Enabled is two-way, disabled is one-way"
	]
]

@PointClass base(info_node_link) color(220 180 0) iconsprite("editor/info_node_link.vmt") line(255 255 255, nodeid, StartNode, nodeid, EndNode) = info_node_link_filtered :
	"A variant of info_node_link that uses an entity filter. " +
	"Only entities that pass the specified filter can use this link. While disabled, the filter is disregarded and filtering is handed to the regular exclusion rules."
[
    damagefilter(filterclass) : "Link Filter" : "" : "Name of the filter entity that controls which entities can use this link."
	
	Usage(choices) : "Usage" : 0 : "Causes the link to use slightly different behavior." =
	[
		0 : "Enabled uses filter, disabled hands to exclusion rules"
		1 : "Enabled is free-to-use, disabled uses filter"
	]
	
	// Inputs
	input SetLinkFilter(target_destination) : "Sets the link's filter."
]

@PointClass base(info_node_link) color(220 180 0) iconsprite("editor/info_node_link.vmt") line(255 255 255, nodeid, StartNode, nodeid, EndNode) = info_node_link_logic :
	"A variant of info_node_link that fires outputs when a NPC tries to use it. " +
	"Otherwise functions identically to a regular info_node_link."
[
	// Outputs
	output OnUsageAccepted(void) : "Fires when a NPC uses this link after meeting all of the requirements."
	output OnUsageAcceptedWhileDisabled(void) : "Fires when a NPC that meets all of the requirements tries to use this link, but it's disabled."
]

@PointClass wirebox(mins, maxs) base(Targetname) = info_node_link_controller :
	"An entity that controls all connections between nodes that intersect the controller's volume. "+
	"This allows for mass enabling/disabling of all node connections through a volume."
[
	mins(vector) : "Mins" : "-8 -32 -36"
	maxs(vector) : "Maxs" : "8 32 36"

	initialstate(choices) : "Initial State" : 1 =
	[
		0 : "Off"
		1 : "On"
	]
	useairlinkradius(choices) : "Use Larger Radius (for air links)" : 0 : "Set this to 'Yes' if this controller is intended to control air links. "+
		"Air links connect using a larger search radius so leaving this at 'No' might miss some air links." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	AllowUse(target_name_or_class) : "Allow Pass When Off" : : "Entity or class to allow passage even when node is off"
	InvertAllow(choices) : "Invert exclusion rules" : 0 : "Allowed entity is the only entity NOT allowed when this is set to 'yes'" =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input TurnOn(void) : "Turn the link on."
	input TurnOff(void) : "Turn the link off."
	input SetAllowed(target_destination) : "Change the allowed pass when off"
	input SetInvert(integer) : "Change the invert exclusion rule"
]

@PointClass wirebox(mins, maxs) base(info_node_link_controller) = info_template_link_controller :
	"An entity that controls all connections between nodes that intersect the controller's volume. "+
	"This allows for mass enabling/disabling of all node connections through a volume.\n\n"+
	"NOTE: Due to the way this works, using info_node_link_logic may cause several identical instances of the outputs to be fired instead of one. One way to remedy this by passing your action through a relay with fast refire disabled."
[
	ReferenceTemplate(target_destination) : "Reference Template" : : "The point_template whose first template would be used as a reference for all of this controller's links. The first template MUST be info_node_link or an entity derived from it, like info_node_link_filtered."
]

@PointClass sphere(radius) base(Targetname, Parentname) = info_radial_link_controller :
	"This entity automatically severs node connections that pass through its radius. If it moves, it will restore those connections."
[
	radius(float) : "Radius (Use Helper!)" : 120
]

@PointClass base(Targetname, Angles, HintNode) studio("models/editor/climb_node.mdl") color(153 215 103) = info_node_climb : 
	"A climb-node for AI navigation. Only usable by NPCs that can climb."
[
]


//-------------------------------------------------------------------------
//
// Lights
//
//-------------------------------------------------------------------------
@PointClass light() iconsprite("editor/light.vmt") base(Targetname, Light) sphere(_fifty_percent_distance) sphere(_zero_percent_distance) sphere(_hardfalloff) sphere(_distance) = light :
	"An invisible omnidirectional lightsource."
[
	target(target_destination) : "Entity To Point At" : : "The name of an entity in the map that the spotlight will point at. This will override the spotlight's angles."
	spawnflags(Flags) = [ 1 : "[1] Initially dark" : 0 ]
	_distance(integer) : "Maximum Distance" : 0 : "This is the distance that light is allowed to cast."
]

@PointClass base(Angles) iconsprite("editor/light_env.vmt") = light_environment : 
	"Sets the color and angle of the light from the sun and sky."
[
	pitch(integer) : "Pitch" : 0 : "The downward pitch of the light from the sun. 0 is horizontal, -90 is straight down."
	_light(color255) : "Brightness" : "255 255 255 200"
	_ambient(color255) : "Ambient" : "255 255 255 20"
	_lightHDR(color255) : "BrightnessHDR" : "-1 -1 -1 1"
	_lightscaleHDR(float) : "BrightnessScaleHDR" : "1" : "Amount to scale the light by when compiling for HDR."
	_ambientHDR(color255) : "AmbientHDR" : "-1 -1 -1 1"
	_AmbientScaleHDR(float) : "AmbientScaleHDR" : "1" : "Amount to scale the ambient light by when compiling for hdr."
	pitch(integer) : "Pitch" : 0 : "The downward pitch of the light from the sun. 0 is horizontal, -90 is straight down."
	SunSpreadAngle(float) : "SunSpreadAngle" : 0 : "The angular extent of the sun for casting soft shadows. Higher numbers are more diffuse. 5 is a good starting value."
]

@PointClass base(Targetname, Angles, Light) lightprop("models/editor/spot.mdl") lightcone() sphere(_fifty_percent_distance) sphere(_zero_percent_distance) sphere(_hardfalloff) sphere(_distance) = light_spot :
	"An invisible and directional spotlight."
[
	target(target_destination) : "Entity to point at" : : "The name of an entity in the map that the spotlight will point at. This will override the spotlight's angles."
	_inner_cone(integer) : "Inner (bright) angle" : 30
	_cone(integer) : "Outer (fading) angle" : 45
	_exponent(integer) : "Focus" : 1
	_distance(integer) : "Maximum distance" : 0 : "This is the distance that light is allowed to cast."
	pitch(angle_negative_pitch) : "Pitch" : -90
	spawnflags(Flags) = [ 1 : "[1] Initially dark" : 0 ]
]

@PointClass base(Targetname, Parentname, Angles) iconsprite("editor/light.vmt") sphere(distance) lightcone() size(-4 -4 -4, 4 4 4) = light_dynamic : 
	"An invisible lightsource that changes in some way over time." 
[
	target(target_destination) : "Entity to point at" : : "The name of an entity in the map that the dynamic light will point at."
	_light(color255) : "Light color" : "255 255 255 200"
	brightness(integer) : "Light brightness" : 0
	_inner_cone(integer) : "Inner (bright) angle" : 30
	_cone(integer) : "Outer (fading) angle" : 45
	pitch(integer) : "Pitch" : -90
	distance(float) : "Maximum distance" : 120 : "This is the distance that light is allowed to cast, in units."
	spotlight_radius(float) : "Spotlight end radius" : 80 : "This is the radius of the light, in units, at the object that it is hitting."
    style(Choices) : "Appearance" : 0 =
	[
		0 : "Normal"
		10: "Fluorescent flicker"
		2 : "Slow, strong pulse"
		11: "Slow pulse, noblack"
		5 : "Gentle pulse"
		1 : "Flicker A"
		6 : "Flicker B"
		3 : "Candle A"
		7 : "Candle B"
		8 : "Candle C"
		4 : "Fast strobe"
		9 : "Slow strobe"
	]
	spawnflags(Flags) = 
	[ 
		1 : "[1] Do not light world (better perf)" : 0 
		2 : "[2] Do not light models" : 0
		4 : "[4] Add Displacement Alpha" : 0
		8 : "[8] Subtract Displacement Alpha" : 0
	]

	// Inputs
	input Color(color255) : "Set the light's render color (R G B)."
	input brightness(integer) : "Set the light brightness."
	input distance(float) : "Set the maximum light distance."
	input _inner_cone(integer) : "Set the inner (bright) angle."
	input _cone(integer) : "Set the outer (fading) angle."
	input spotlight_radius(float) : "Set the radius of the spotlight at the end point."
	input style(integer) : "Change the lightstyle (see Appearance field for possible values)."

	input TurnOn(void) : "Turn the light off."
	input TurnOff(void) : "Turn the light on."
	input Toggle(void) : "Toggle the light on/off."
]


//-------------------------------------------------------------------------
// Shadow control
//-------------------------------------------------------------------------

@PointClass base(Targetname, Angles) iconsprite("editor/shadow_control.vmt") = shadow_control : 
	"An entity to control the shadows in the map."
[
	angles(angle) : "Pitch Yaw Roll (Y Z X)" : "80 30 0" : "This is the shadow direction. Pitch is rotation around the Y axis, yaw is the rotation around the Z axis, and roll is the rotation around the X axis."

	color(color255) : "Shadow Color" : "128 128 128" : "This is the color of the shadows."
	distance(float) : "Maximum Distance" : 75 : "This is the maximum distance the shadow is allowed to cast, in units."
	disableallshadows(Choices) : "All Shadows Disabled" : 0 = 
	[
		0 : "No"
		1 : "Yes"
	]
	
	enableshadowsfromlocallights(Choices) : "Enable Local Light Shadows" : 0 : "Enables RTT dynamic shadow angles, which cause shadows to face away from the nearest light source instead of always using this entity's direction. This is a new feature and the original Half-Life 2 had no dynamic shadow angles. Leave this off if they are not desired." = 
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input color(color255) : "Set the shadow color."
	input direction(vector) : "Set the shadow direction."
	input SetDistance(float) : "Set the maximum shadow cast distance."
	input SetAngles(string) : "Set the shadow direction."
	input SetShadowsDisabled(bool) : "Set shadows disabled state."
	input SetShadowsFromLocalLightsEnabled(bool) : "Toggles shadows from local lights."
]


//-------------------------------------------------------------------------
// Color correction control
//-------------------------------------------------------------------------

@PointClass base(Targetname, EnableDisable) sphere(minfalloff) sphere(maxfalloff) iconsprite("editor/color_correction.vmt") = color_correction : 
	"An entity to control the color correction in the map."
[
	minfalloff(float) : "Lookup Falloff Start Distance" : "0.0"   : "This is the distance to the start of the falloff region (-1 = everywhere)"
	maxfalloff(float) : "Lookup Falloff End Distance"   : "200.0" : "This is the distance to the end of the falloff region (-1 = everywhere)"
	maxweight(float)  : "Maximum Weight"				: "1.0"   : "This is the maximum weight for this lookup"
	filename(string)  : "Lookup Table Filename"			: ""	  : "This is the lookup table filename"
	fadeInDuration(float)   : "Lookup Fade In Duration"		: "0.0"	  : "Duration of fade in on when enabled."
	fadeOutDuration(float)   : "Lookup Fade out Duration"		: "0.0"	  : "Dration of fade out on when disabled."
	exclusive(choices) : "Exlusive" : 0 : "An exclusive color_correction entity disables and fades out all other color corrections when it is enabled. There should only be one active exclusive color_correction ent at any time." = 
	[
		0 : "No"
		1 : "Yes"
	]
	
	spawnflags(flags) =
	[
		1 : "[1] Master (Default color correction when used with L4D fog_volume)" : 0
		2 : "[2] Client-side simulation (Must be set when used with L4D fog_volume)" : 0
	]
	
	// Inputs
	input SetFadeInDuration(float) : "Sets the 'fadeInDuration' variable, used to fade cc lookup usage when entity is enabled."
	input SetFadeOutDuration(float) : "Sets the 'fadeOutDuration' variable, used to fade cc lookup usage when entity is disabled."
	
	input SetMinFalloff(float) : "Sets the Lookup Falloff Start Distance."
	input SetMaxFalloff(float) : "Sets the Lookup Falloff End Distance."
]


//-------------------------------------------------------------------------
// Color correction volume control
//-------------------------------------------------------------------------

@SolidClass base(Targetname, EnableDisable ) = color_correction_volume : 
	"An entity to control the color correction in the map."
[
	fadeDuration(float) : "Lookup Fade Duration"  : "10.0" : "This is the duration for the lookup to fade in/out on extry/exit"
	maxweight(float)    : "Maximum Weight"		  : "1.0"  : "This is the maximum weight for this lookup"
	filename(string)    : "Lookup Table Filename" : ""     : "This is the lookup table filename"
]


//-------------------------------------------------------------------------
//
// Movement and Keyframing Entities
//
//-------------------------------------------------------------------------

@BaseClass = KeyFrame
[
	NextKey(target_destination) : "Next KeyFrame" : : "Name of the next keyframe along this keyframe path."

//	TimeModifier(choices) : "Time Modifier" : 0 =
//	[
//		0 : "Linear"
//		1 : "Accel"
//		2 : "Deaccel"
//		2 : "Accel/Deaccel (sine)"
//	]
	
	MoveSpeed(integer) : "Speed (units per second)" : 64					// NEEDHELP
//	NextTime(string) : "Time to get to next keyframe"
]

@BaseClass = Mover
[
	PositionInterpolator(choices) : "Position Interpolator" : 0 =
	[
		0 : "Linear"
		1 : "Catmull-Rom Spline"
	]
]

@SolidClass base(Targetname, Origin, RenderFields) = func_movelinear :
	"A brush entity that moves linearly along a given distance, in a given direction."
[
	parentname(target_destination) : "Parent" : : "The name of this entity's parent in the movement hierarchy. Entities with parents move with their parent. Please don't use any parenting inputs with func_movelinear."

	movedir(angle) : "Move Direction (Pitch Yaw Roll)" : "0 0 0" : "The direction the brushes will move, when told to."
	spawnflags(flags) =
	[
		8 : "[8] Not Solid" : 0
	]

	startposition(float) : "Start Position" : 0 : "Position of brush when spawned. The range is a value between 0.0 and 1.0, where 0 is the starting position and 1 is the starting position + (move direction * move distance)."	
	speed(integer) : "Speed" : 100 : "The speed that the brush moves, in units per second."
	movedistance(float) : "Move Distance" : 100 : "The distance from the starting point that the brush should move, in units."
	blockdamage(float) : "Block Damage" : 0 : "The amount of damage to do to any entity that blocks the brushes, per frame."
	startsound(sound) : "Sound played when the brush starts moving."
	stopsound(sound) : "Sound played when the brush stops moving."

	// Inputs
	input Open(void) : "Move the brush to the end position (starting position + (move direction * move distance))."
	input Close(void) : "Move the brush to the starting position."
	input SetPosition(string) : "Move the brush to a specific position between 0.0 and 1.0, where 0 is the starting position and 1 is the starting position + (move direction * move distance)."
	input SetSpeed(float) : "Set the speed and update immediately."

	// Outputs
	output OnFullyOpen(void) : "Fired when the brush reaches the end position (starting position + (move direction * move distance))."
	output OnFullyClosed(void) : "Fired when the brush reaches the starting position."
]

@SolidClass base(Targetname, Parentname, Origin) = func_water_analog :
	"A water brush entity that moves linearly along a given distance, in a given direction"
[
	movedir(angle) : "Move Direction (Pitch Yaw Roll)" : "0 0 0" : "The direction the water will move, when told to 'Open'."
	startposition(float) : "Start Position" : 0 : "Position of the water brush when spawned. The range is a value between 0.0 and 1.0, where 0 is the starting position and 1 is the starting position + (move direction * move distance)."	
	speed(integer) : "Speed" : 100 : "The speed that the water brush moves, in units per second."
	movedistance(float) : "Move Distance" : 100 : "The distance from the starting point that the water brush should move, in units."
	startsound(sound) : "Sound played when the water brush starts moving."
	stopsound(sound) : "Sound played when the water brush stops moving."
	WaveHeight(string) : "Wave Height" : "3.0"

	// Inputs
	input Open(void) : "Move the water brush to the end position (starting position + (move direction * move distance))."
	input Close(void) : "Move the water brush to the starting position."
	input SetPosition(string) : "Move the water brush to a specific position between 0.0 and 1.0, where 0 is the starting position and 1 is the starting position + (move direction * move distance)."

	// Outputs
	output OnFullyOpen(void) : "Fired when the water brush reaches the end position (starting position + (move direction * move distance))."
	output OnFullyClosed(void) : "Fired when the water brush reaches the starting position."
]

@SolidClass base(Targetname, Parentname, Origin, Angles, RenderFields, Shadow) = func_rotating : 
	"A rotating brush entity."
[
	maxspeed(integer) : "Max Rotation Speed" : 100 : "The maximum rotation speed of the brushes, in degrees per second."
	fanfriction(integer) : "Friction (0 - 100%)" : 20 : "The amount of rotational friction. Value must be between 0 and 100 %."
	message(sound) : "Rotating sound WAV" : : "Sound to play while rotating."
	volume(integer) : "Volume (10 = loudest)" : 10 : "The volume of the rotation sound."
	spawnflags(flags) =
	[
		1 : "[1] Start ON"  : 0
		2 : "[2] Reverse Direction" : 0
		4 : "[4] X Axis"  : 0
		8 : "[8] Y Axis"  : 0
		16: "[16] Acc/Dcc" : 0
		32: "[32] Fan Pain" : 0
		64: "[64] Not Solid" : 0
		128: "[128] Small Sound Radius" : 0
		256: "[256] Medium Sound Radius" : 0
		512: "[512] Large Sound Radius" : 1
		1024: "[1024] Client-side animation" : 0
	]
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
	dmg(integer) : "Blocking Damage" : 0 : "Damage done to any entity that blocks the rotation, per frame."
	
	minpitch(integer) : "Minimum Sound Pitch" : 30 : "Minimum pitch for the rotating sound when it plays based on the speed of the rotating brush."
	maxpitch(integer) : "Maximum Sound Pitch" : 100 : "Maximum pitch for the rotating sound when it plays based on the speed of the rotating brush."

	solidbsp(choices) : "Solid Type" : 0 =
	[
		0 : "VPhysics"	
		1 : "BSP"
	]

	// Inputs
	input SetSpeed(integer) : "Set the speed as a ratio of the specified Max Rotation Speed, where 0 is stopped and 1 is the Max Rotation Speed.."
	input Start(void) : "Start the rotator rotating."
	input Stop(void) : "Stop the rotator from rotating."
	input StopAtStartPos(void) : "Stop the rotator from rotating when it gets around to the start position again (on its rotation axis)."
	input StartForward(void) : "Start the rotator rotating forward."
	input StartBackward(void) : "Start the rotator rotating backward."
	input Toggle(void) : "Toggle the rotator between rotating and not rotating."
	input Reverse(void) : "Reverse the direction of rotation of the rotator."
]

@SolidClass base(Targetname, Parentname, Origin, Angles, RenderFields, BasePlat, Shadow) = func_platrot : 
	"A brush entity that moves vertically, and can rotate while doing so." 
[
	spawnflags(Flags) =
	[
		1: "[1] Toggle" : 1
		64: "[64] X Axis" : 0
		128: "[128] Y Axis" : 0
	]
	noise1(sound) : "Movement Sound" : : "The sound to play when the brush moves."
	noise2(sound) : "Stop Sound" : : "The sound to play when the brush stops moving."
	speed(integer) : "Speed of Rotation" : 50 : "Speed at which the brush rotates, in degrees per second."
	height(integer) : "Travel Altitude" : 0 : "The vertical distance from the starting position that this platform moves. If negative, the platform will lower."
	rotation(integer) : "Spin amount" : 0 : "The amount this platform should rotate as it moves, in degrees."
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
]

@KeyFrameClass base(Targetname, Parentname, Angles, KeyFrame) size(-6 -6 -6, 6 6 6) color(255 200 0) keyframe() = keyframe_track : 
	"Animation KeyFrame"
[
]

@MoveClass base(Targetname, Parentname, KeyFrame, Mover) size(-8 -8 -8, 8 8 8) color(255 170 0) animator() = move_keyframed : 
	"Keyframed Move Behavior"
[
]

@MoveClass base(Targetname, Parentname, Mover, KeyFrame) size(-8 -8 -8, 8 8 8) color(255 0 0) animator() = move_track : 
	"Track Move Behavior"
[
	WheelBaseLength(integer) : "Distance between the wheels" : 50
	Damage(integer) : "Damage done to blocking entities" : 0
	NoRotate(choices) : "Turn to face down path" : 0 =
	[
		0 : "Yes"
		1 : "No"
	]
]

//-------------------------------------------------------------------------
//
// Ropes and Cables
//
//-------------------------------------------------------------------------
@BaseClass base(DXLevelChoice, DamageFilter) = RopeKeyFrame
[
	spawnflags(Flags) = 
	[
		1 :  "[1] Auto Resize" : 0
	]

	Slack(integer) : "Slack" : 25 : "How much extra length the rope has (by default it has the length between its two endpoints in the editor)."

	Type(choices) : "Type" : 0 =
	[
		0  : "Rope"
		1  : "Semi-rigid"
		2  : "Rigid"
	]

	Subdiv(integer) : "Subdivision" : 2 : "Number of subdivisions between each rope segment. Maximum value is 8. Higher values make smoother ropes, but are slower to render."

	Barbed(choices) : "Barbed" : 0 : "Test effect that makes the rope look sharper and more barbed." =
	[
		0 : "No"
		1 : "Yes"
	] 
	
	Width(float) : "Width" : "2" : "Width of the rope."

	TextureScale(string) : "Texture Scale" : "1" : "This changes the texture resolution. The default resolution is 4 pixels per inch. Larger values stretch the texture and smaller values scrunch it up."
	
	Collide(choices) : "Collide with world" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	Dangling(choices) : "Start Dangling" : 0 : "When set to Yes, the rope starts out detached from its target endpoint." =
	[
		0 : "No"
		1 : "Yes"
	] 

	Breakable(choices) : "Breakable" : 0 : "When set to yes, the rope can be detached from either endpoint when shot." =
	[
		0 : "No"
		1 : "Yes"
	] 

	RopeMaterial(material) : "Rope Material" : "cable/cable.vmt" : "The material to use when rendering the rope."

	// Inputs
	input SetScrollSpeed(float) : "Set the speed at which the texture scrolls."
	input SetForce(string) : "Apply a force instantaneously to the rope. The parameter should be a vector containing the force to be applied (X Y Z)."
	input SetSlack(integer) : "Set the rope's slack. (Wind may need to be enabled for changes to apply)"
	input SetWidth(float) : "Set the rope's width."
	input SetSubdivision(integer) : "Set the rope's subdivision. (Wind may need to be enabled for changes to apply)"
	input Break(void) : "Break the rope, if it's marked to do so."
	
	// Outputs
	output OnBreak(void) : "Fires when this rope breaks."

	NoWind(choices) : "Disable Wind" : 0 : "When set to Yes, the rope will no longer act as though it's being affected by wind." =
	[
		0 : "No"
		1 : "Yes"
	]

]

@KeyFrameClass base(Targetname, Parentname, KeyFrame, RopeKeyFrame) studio("models/editor/axis_helper_thick.mdl") keyframe() = keyframe_rope : 
	"A node entity that marks a point in a rope. The first node in the rope should be a move_rope, followed by 1 or more keyframe_ropes."
[
]

@MoveClass base(Targetname, Parentname, KeyFrame, RopeKeyFrame) studio("models/editor/axis_helper.mdl") animator() = move_rope : 
	"The first node in set of nodes that are used to place ropes in the world. It should connect to 1 or more keyframe_rope entities."
[
	PositionInterpolator(choices) : "Position Interpolator" : 2 : "Curve Type. Currently only type 2 (Rope) is fully supported." =
	[
		0 : "Linear"
		1 : "Catmull-Rom Spline"
		2 : "Rope"
	]
]


//-------------------------------------------------------------------------
//
// Buttons
//
//-------------------------------------------------------------------------

@BaseClass = Button
[
	// Inputs
	input Lock(void) : "Lock the button, preventing it from functioning."
	input Unlock(void) : "Unlock the button, allowing it to function."
	input Press(void) : "Activate the button as if it was pressed."
	input PressIn(void) : "Activate the button as if it was pressed, sending it to the bottom position."
	input PressOut(void) : "Unpress the button, sending it to the top position."

	// Outputs
	output OnDamaged(void) : "Fired when the button is damaged."
	output OnPressed(void) : "Fired when the button is pressed."
	output OnUseLocked(void) : "Fired when the button is used while locked."
	output OnIn(void) : "Fired when the button reaches the in/pressed position."
	output OnOut(void) : "Fired when the button reaches the out/released position."
]

@SolidClass base(Targetname, Parentname, Origin, RenderFields,DamageFilter, Button) = func_button : 
	"A brush entity that's designed to be used for a player-useable button. When used by the player, it moves to a pressed position."
[
	movedir(angle) : "Move Direction (Pitch Yaw Roll)" : "0 0 0" : "Specifies the direction of motion to move when the button is used."
	speed(integer) : "Speed" : 5 : "The speed that the button moves, in units per second."
	//health(integer) : "Health (Obsolete)" : 0 : "Legacy method of specifying whether or not the button can be shot to activate it. Use the 'Damage Activates' spawnflag instead."
	lip(integer) : "Lip" : 0 : "The amount, in units, of the button to leave sticking out of the wall it recedes into when pressed. Negative values make the button recede even further into the wall."
	//master(target_destination) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this button cannot be pressed."
	sounds(choices) : "Sounds" : 0 = 
	[
		0: "None (Silent)"
		1: "Big zap & Warmup"
		2: "Access Denied"
		3: "Access Granted"
		4: "Quick Combolock"
		5: "Power Deadbolt 1"
		6: "Power Deadbolt 2"
		7: "Plunger"
		8: "Small zap"
		9: "Keycard Sound"
		10: "Buzz"
		11: "Buzz Off"
		12: "latch locked"
		13: "Latch Unlocked"
		14: "Lightswitch"
		15: "small bleek"
		16: "small deny"
		17: "small doop"
		18: "small tech deny"
		19: "click and combine screen fuzz"
		20: "roomy beep"
		21: "lever or wheel: turn + move sqeek"
		22: "lever or wheel: latch + release gas"
		23: "lever or wheel: ratchet + sqeek"
		24: "lever or wheel: large ratchet"
		25: "lever or wheel: clanky + gas release"
		26: "lever or wheel: latch + large metal thud"
		27: "lever or wheel: smaller ratchet"
		28: "lever or wheel: smaller lever move"
		31: "shock buzz"
		32: "clickbeep"
		33: "tech blip"
		34: "clickbeepbeep open"
		35: "small high blip"
		36: "small tech fuzz blip"
		37: "small click bleep (change to lightswitch)"
		40: "combine door lock - locked"
		41: "combine blip growl"
		42: "combine squick growl"
		43: "combine whine purr"
		44: "combine click talk"
		45: "combine click growl fizz"
		46: "combine click fizz (deny)"
		47: "combine click talker"
	]	
	wait(integer) : "Delay Before Reset (-1 stay)" : 3 : "Amount of time, in seconds, after the button has been pressed before it returns to the starting position. Once it has returned, it can be used again. If the value is set to -1, the button never returns."
	spawnflags(flags) =
	[
		1: "[1] Don't move" : 0
		32: "[32] Toggle" : 0
		256: "[256] Touch Activates": 0
		512: "[512] Damage Activates": 0
		1024: "[1024] Use Activates" : 1
		2048: "[2048] Starts locked" : 0
		4096: "[4096] Sparks" : 0
	]
	locked_sound(choices) : "Locked Sound" : 0 : "Sound played when the player tries to use the button, and fails because it's locked." = 
	[
		0: "None"
		2: "Access Denied"
		8: "Small zap"
		10: "Buzz"
		11: "Buzz Off"
		12: "Latch Locked"
	]
	unlocked_sound(choices) : "Unlocked Sound" : 0 : "Sound to play when the button is door...Err--Sound played when the button is unlocked." = 
	[
		0: "None"
		1: "Big zap & Warmup"
		3: "Access Granted"
		4: "Quick Combolock"
		5: "Power Deadbolt 1"
		6: "Power Deadbolt 2"
		7: "Plunger"
		8: "Small zap"
		9: "Keycard Sound"
		10: "Buzz"
		13: "Latch Unlocked"
		14: "Lightswitch"
	]
	locked_sentence(choices) : "Locked Sentence" : 0 : "A sentence played when the player tries to use the button, and fails because it's locked." = 
	[
		0: "None"
		1: "Gen. Access Denied"
		2: "Security Lockout"
		3: "Blast Door"
		4: "Fire Door"
		5: "Chemical Door"
		6: "Radiation Door"
		7: "Gen. Containment"
		8: "Maintenance Door"
		9: "Broken Shut Door"
	]
	unlocked_sentence(choices) : "Unlocked Sentence" : 0 : "A sentence played when the button is unlocked." = 
	[
		0: "None"
		1: "Gen. Access Granted"
		2: "Security Disengaged"
		3: "Blast Door"
		4: "Fire Door"
		5: "Chemical Door"
		6: "Radiation Door"
		7: "Gen. Containment"
		8: "Maintenance area"
	]
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
]

@SolidClass base(Targetname, Parentname, Origin, Angles, Global, Button, EnableDisable) = func_rot_button : 
	"A brush entity that's designed to be used for a rotating player-useable button. When used by the player, it rotates to a pressed position."
[
	//master(target_destination) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this button cannot be used."
	speed(integer) : "Speed" : 50 : "The speed that the button rotates, in degrees per second."
	//health(integer) : "Health (Obsolete)" : 0 : "Legacy method of specifying whether or not the button can be shot to activate it. Use the 'Damage Activates' spawnflag instead."
	sounds(choices) : "Sounds" : 21 = 
	[
		0: "None (Silent)"
		21: "Squeaky"
		22: "Squeaky Pneumatic"
		23: "Ratchet Groan"
		24: "Clean Ratchet"
		25: "Gas Clunk"
	]
	wait(integer) : "Delay Before Reset (-1 stay)" : 3 : "Amount of time, in seconds, after the button has been pressed before it returns to the starting position. Once it has returned, it can be used again. If the value is set to -1, the button never returns."
	distance(integer) : "Distance (deg)" : 90 : "The amount, in degrees, that the button should rotate when it's pressed."
	// TODO: move spawnflags into Button base class?
	spawnflags(flags) =
	[
		1 : "[1] Not solid" : 0
		2 : "[2] Reverse Dir" : 0
		32: "[32] Toggle" : 0
		64: "[64] X Axis" : 0
		128: "[128] Y Axis" : 0
		256: "[256] Touch Activates": 0
		512: "[512] Damage Activates": 0
		1024: "[1024] Use Activates": 0
		2048: "[2048] Starts locked" : 0
	]
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
]

@SolidClass base(Targetname, Parentname, Origin, Angles, RenderFields) = momentary_rot_button : 
	"A brush entity that's designed to be used for rotating wheels, where the player can rotate them to arbitrary positions before stopping."
[
	speed(integer) : "Speed (deg/sec)" : 50 : "The amount, in degrees, that the wheel turns per second."
	//master(target_destination) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this button cannot be used."
	sounds(choices) : "Sounds" : 0 = 
	[
		0: "None"
		1: "Big zap & Warmup"
		2: "Access Denied"
		3: "Access Granted"
		4: "Quick Combolock"
		5: "Power Deadbolt 1"
		6: "Power Deadbolt 2"
		7: "Plunger"
		8: "Small zap"
		9: "Keycard Sound"
		21: "Squeaky"
		22: "Squeaky Pneumatic"
		23: "Ratchet Groan"
		24: "Clean Ratchet"
		25: "Gas Clunk"
	]
	distance(integer) : "Distance" : 90 : "The maximum amount, in degrees, that the wheel is allowed to rotate."
	returnspeed(integer) : "Auto-return speed" : 0 : "If the 'Toggle' spawnflag is not set, the speed at which the wheel auto-returns when left alone, in degrees per second."
	spawnflags(flags) =
	[
		1: "[1] Not Solid" : 1
		32: "[32] Toggle (Disable Auto Return)" : 1
		64: "[64] X Axis" : 0
		128: "[128] Y Axis" : 0
		1024: "[1024] Use Activates" : 1
		2048: "[2048] Starts locked" : 0
		8192: "[8192] Jiggle when used while locked" : 0
	]
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
	startposition(float) : "Start Position" : 0 : "Postion when spawned. The value is a range between 0.0 and 1.0, where 0 is the unrotated position and 1 is the rotated position + 'Distance'."
	startdirection(choices) : "Start Direction" : "Forward" =
	[
		-1 : "Forward"		 // Reverses upon USE, so are
		1 : "Backward"	 // reversed here.
	]
	solidbsp(choices) : "Solid BSP" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]	

	// Inputs
	input Lock(void) : "Lock the button, preventing it from functioning."
	input Unlock(void) : "Unlock the button, allowing it to function."
	input SetPosition(string) : "Move to a position. The parameter must be a value between 0 and 1, where 0 is the unrotated position and 1 is the rotated position + 'Distance'."
	input SetPositionImmediately(string) : "Immediately teleport to a position. The parameter must be a value between 0 and 1, where 0 is the unrotated position and 1 is the rotated position + 'Distance'."

	// Outputs
	output Position(integer)   : "Fired whenever the button moves. The output is the position of button from 0 to 1, where 0 is the unrotated position and 1 is the rotated position + 'Distance'."
	output OnPressed(integer)  : "Fired when the button is first pressed."
	output OnUnpressed(integer): "Fired when the button is first released from being pressed."
	output OnFullyClosed(void) : "Fired when the button has reached position 1, the rotated position + 'Distance'."
	output OnFullyOpen(void)   : "Fired when the button has reached position 0, the unrotated starting position."
	output OnReachedPosition(void)   : "Fired whenever the button reaches a goal position: i.e. when it becomes open, becomes closed, or reaches the point specified by a 'SetPosition' input."
]


//-------------------------------------------------------------------------
//
// Doors
//
//-------------------------------------------------------------------------

@BaseClass base(Targetname, Parentname, RenderFields, Global, Shadow) = Door
[
	speed(integer) : "Speed" : 100 : "The speed at which the door moves."
	//master(target_destination) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this button cannot be used."
	noise1(sound) : "Start Sound" : : "Sound to play when the door starts moving."
	noise2(sound) : "Stop Sound" : : "Sound to play when the door stops moving."
	startclosesound(sound) : "Start Close Sound" : : "(Optional) Sound to play when the door starts closing."
	closesound(sound) : "Stop Close Sound" : : "(Optional) Sound to play when the door stops closing."
	wait(integer) : "Delay Before Reset (-1 stay)" : 4 : "Amount of time, in seconds, after the door has opened before it closes. Once it has closed, it can be used again. If the value is set to -1, the door never closes itself."
	lip(integer) : "Lip" : 0 : "The amount, in units, of the button to leave sticking out of the wall it recedes into when pressed. Negative values make the button recede even further into the wall."
	dmg(integer) : "Blocking Damage" : 0 : "Amount of damage done to entities that block the movement of this door, per frame."
	forceclosed(choices) : "Force Closed" : 0 : "If set, this door will close no matter what. Useful for doors that have to close even if the player tries to block them with objects." =
	[
		0 : "No"
		1 : "Yes"
	]
	ignoredebris(choices) : "Ignore Debris" : 0 : "If set this will change the door's collision group to one that ignore collisions with debris objects (note that this is not compatible with the non-solid-to-player spawnflag)." =
	[
		0 : "No"
		1 : "Yes"
	]

	//message(string) : "Message If Triggered"		// NEEDHELP: Looks like this was removed
	health(integer) : "Health (shoot open)" : 0		// NEEDHELP: Looks like this was removed

	locked_sound(sound) : "Locked Sound" : : "Sound played when the player tries to use the door, and fails because it's locked."
	unlocked_sound(sound) : "Unlocked Sound" : : "Sound played when the button is door."

	spawnpos(choices) : "Spawn Position" : 0 =
	[
		0 : "Closed"
		1 : "Open"
	]

	spawnflags(flags) =
	[
		//1 : "[1] Starts Open - OBSOLETE, use 'Spawn Position' key instead" : 0
		4 : "[4] Non-solid to Player" : 0
		8: "[8] Passable" : 0
	    32: "[32] Toggle" : 0
		256:"[256] Use Opens" : 0
		512: "[512] NPCs Can't" : 0
		1024: "[1024] Touch Opens" : 1
		2048: "[2048] Starts locked" : 0
		4096:	"[4096] Door Silent" : 0
	]
	//locked_sentence(choices) : "Locked Sentence" : 0 : "A sentence played when the player tries to use the door, and fails because it's locked." =  
	//[
	//	0: "None"
	//	1: "Gen. Access Denied"
	//	2: "Security Lockout"
	//	3: "Blast Door"
	//	4: "Fire Door"
	//	5: "Chemical Door"
	//	6: "Radiation Door"
	//	7: "Gen. Containment"
	//	8: "Maintenance Door"
	//	9: "Broken Shut Door"
	//]
	//unlocked_sentence(choices) : "Unlocked Sentence" : 0 : "A sentence played when the door is unlocked." = 
	//[
	//	0: "None"
	//	1: "Gen. Access Granted"
	//	2: "Security Disengaged"
	//	3: "Blast Door"
	//	4: "Fire Door"
	//	5: "Chemical Door"
	//	6: "Radiation Door"
	//	7: "Gen. Containment"
	//	8: "Maintenance area"
	//]	
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
	loopmovesound(choices) : "Loop Moving Sound?" : 0 : "If set to true, the door's 'Start Sound' will be continually looped until the door finishes moving." =
	[
		0: "No"
		1: "Yes"
	]

	// Outputs
	output OnClose(void) : "Fired when the door starts closing."
	output OnOpen(void) : "Fired when the door starts opening."
	output OnFullyOpen(void) : "Fired when the door reaches the fully open position. Reversed if 'Start Open' flag is set."
	output OnFullyClosed(void) : "Fired when the door reaches the fully closed position. Reversed if 'Start Open' flag is set."
	output OnBlockedClosing(void) : "Fired when the door is blocked while closing."
	output OnBlockedOpening(void) : "Fired when the door is blocked while opening."
	output OnUnblockedClosing(void) : "Fired when the door is unblocked while closing."
	output OnUnblockedOpening(void) : "Fired when the door is unblocked while opening."
	output OnLockedUse(void) : "Fired when the player uses the door, but it is locked."

	// Inputs
	input Open(void) : "Open the door, if it is not fully open."
	input Close(void) : "Close the door, if it is not fully closed."
	input Toggle(void) : "Toggle the door between open and closed."
	input Lock(void) : "Lock the door."
	input Unlock(void) : "Unlock the door."
	input SetSpeed(float) : "Set the door speed."
]

@SolidClass base(Door, Origin) = func_door : 
	"A brush entity for use as a player-useable door."
[
	movedir(angle) : "Move Direction (Pitch Yaw Roll)" : "0 0 0" : "The direction the door will move, when it opens."

	filtername(filterclass) : "Block Filter Name" : : "Filter to use to determine entities that block the door. ( Half-Life: Source port only )"
]

@SolidClass base(Door, Origin, Angles) = func_door_rotating : 
	"A brush entity for use as a rotating player-useable door." 
[
	spawnflags(flags) =
	[
		2 : "[2] Reverse Dir" : 0
		16: "[16] One-way" : 0
		64: "[64] X Axis" : 0
		128: "[128] Y Axis" : 0
		65536: "[65536] New func_door +USE rules (NOT for prop_doors!!)" : 0
	]
	distance(integer) : "Distance" : 90 : "The amount, in degrees, that the button should rotate when it's pressed."

	solidbsp(choices) : "Solid Type" : 0 =
	[
		0 : "VPhysics"	
		1 : "BSP"
	]
]

@PointClass base(Targetname, Parentname, Angles, Global, Studiomodel, RenderFields) studioprop() = prop_door_rotating : 
	"An entity used to place a door in the world."
[
	disableshadows(choices) : "Disable Shadows" : 1 : "Used to disable dynamic shadows on this entity." =
	[
		0 : "No"
		1 : "Yes"
	]

	slavename(target_destination) : "Slave Name" : : "The name of any doors that should be slaved to this door (i.e. should open when this one opens, and close when this one closes)."
	hardware(choices) : "Hardware Type" : 1 =
	[
		0 : "<None>"
		1 : "Lever"
		2 : "Push bar"
		3 : "Keypad"
	]
	
	ajarangles(angle) : "Ajar Angles (Pitch Yaw Roll)" : "0 0 0" : "If the door 'Spawn Position' is set to Ajar, these are the angles to spawn at, instead of being open or closed."
	spawnpos(choices) : "Spawn Position" : 0 =
	[
		0 : "Closed"
		1 : "Open forward"
		2 : "Open back"
		3 : "Ajar (use Ajar Angles)"
	]
	
	axis(axis) : "Hinge Axis"
	distance(float) : "Rotation Distance (deg)" : 90 : "The amount, in degrees, that the door should rotate when opened."
	speed(integer) : "Speed" : 100 : "The speed at which the door moves."
	soundopenoverride(sound) : "Fully Open Sound" : : "Sound played when the door has finished opening."
	soundcloseoverride(sound) : "Fully Closed Sound" : : "Sound played when the door has finished closing."
	soundmoveoverride(sound) : "Moving Sound" : : "Sound played when the door starts to move."
	returndelay(integer) : "Delay Before close (-1 stay open)" : -1 : "Amount of time, in seconds, after the door has opened before it closes. If the value is set to -1, the door never closes itself."
	dmg(integer) : "Damage Inflicted When Blocked" : 0 : "Amount of damage done to entities that block the movement of this door, per frame."
	health(integer) : "Health (0 = Unbreakable)" : 0
	soundlockedoverride(sound) : "Locked Sound" : : "Sound played when the player tries to open the door, and fails because it's locked."
	soundunlockedoverride(sound) : "Unlocked Sound" : : "Sound played when the door is unlocked."
	
	opendistoverride(integer) : "NPC Open Distance" : -1 : "How far away NPCs should move in order to open the door. (default = 64)"
	openfrontactivityoverride(string) : "NPC Front Open Activity" : "" : "The gesture activity NPCs should play when opening the door from the front."
	openbackactivityoverride(string) : "NPC Back Open Activity" : "" : "The gesture activity NPCs should play when opening the door from the back."
	
	lightingorigin(target_destination) : "Lighting Origin" : "" : "Select an entity to specify a location to sample lighting from, instead of using this entity's origin."

	forceclosed(choices) : "Force Closed" : 0 : "If set, this door will close no matter what. Useful for doors that have to close even if the player tries to block them with objects." =
	[
		0 : "No"
		1 : "Yes"
	]

	spawnflags(flags) =
	[
		256 : "[256] Start with collision disabled" : 0
		512: "[512] NPCs Can't" : 0
		2048: "[2048] Starts locked" : 0
		4096: "[4096] Door silent (No sound, and does not alert NPCs)" : 0
		8192: "[8192] Use closes" : 1
		16384 : "[16384] Door silent to NPCS (Does not alert NPCs)" : 0
		32768 : "[32768] Ignore player +USE" : 0
	]

	opendir(choices) : "Open Direction" : 0 : "Force the door to open only forwards or only backwards. Both directions is the standard door behavior." =
	[
		0 : "Open Both Directions"
		1 : "Open Forward Only"
		2 : "Open Backward Only"
	]
	
	//breaktype(choices) : "Break Type" : 0 : "If this door is breakable or it receives the 'Break' input, what should it do?" =
	//[
	//	0 : "Break normally"
	//	1 : "Turn into prop_physics"
	//	2 : "Turn into prop_physics and hinge"
	//]
	
	//DoorFilter(filterclass) : "NPC Filter" : "" : "An optional filter that can control which NPCs are allowed to pass through this door."

	// Outputs
	output OnClose(void) : "Fired when the door is told to close."
	output OnOpen(void) : "Fired when the door is told to open."
	output OnFullyOpen(void) : "Fired when the door reaches the fully open position."
	output OnFullyClosed(void) : "Fired when the door reaches the fully closed position."
	output OnBlockedClosing(void) : "Fired when the door is blocked while closing."
	output OnBlockedOpening(void) : "Fired when the door is blocked while opening."
	output OnUnblockedClosing(void) : "Fired when the door is unblocked while closing."
	output OnUnblockedOpening(void) : "Fired when the door is unblocked while opening."
	output OnLockedUse(void) : "Fired when the player uses the door, but it is locked."

	// Inputs
	input Open(void) : "Open the door, if it is not fully open."
	input OpenAwayFrom(target_destination) : "Open the door away from the specified entity."
	input Close(void) : "Close the door, if it is not fully closed."
	input Toggle(void) : "Toggle the door between open and closed."
	input Lock(void) : "Lock the door."
	input Unlock(void) : "Unlock the door."
	input SetRotationDistance(float) : "Set the distance (in degrees) between Open and Closed."
	input SetSpeed(float) : "Set the speed at which the door rotates. 100 is default."
	
	input AllowPlayerUse(void) : "Allows players to use the door. This just disables the 'Ignore player +USE' spawnflag."
	input DisallowPlayerUse(void) : "Prevents players from using the door. This just enables the 'Ignore player +USE' spawnflag."
	
	input SetDoorFilter(target_destination) : "Sets the entity to use as the NPC filter. Pass in an empty string to clear the NPC filter."
]


//-------------------------------------------------------------------------
//
// Cube map sample
//
//-------------------------------------------------------------------------

@PointClass color(0 0 255) sidelist(sides) iconsprite("editor/env_cubemap.vmt") = env_cubemap : 
	"An entity that creates a sample point for the Cubic Environment Map."
[
	cubemapsize(choices) : "Cubemap Size" : 0 =
	[
		0 : "Default"
		1 : "1x1"
		2 : "2x2"
		3 : "4x4"
		4 : "8x8"
		5 : "16x16"
		6 : "32x32"
		7 : "64x64"
		8 : "128x128"
		9 : "256x256"
	]
	sides(sidelist) : "Brush faces": : "(Optional) Brushes faces to directly attach to the env_cubemap. Press Pick then click on faces in the 3D View to select them. Use CTRL while clicking to add or remove from the selection."
	
	parallaxobb(target_destination) : "Cubemap Bounds" : : "MAPBASE VBSP ONLY: Optionally assigns this cubemap a bounding box for parallax correction (brush entity tied to parallax_obb). This means the cubemap reflection will move as the camera moves, similar to func_reflective_glass."
]

@SolidClass = parallax_obb
[
	targetname(target_source) : "Name" : : "The name that other entities refer to this entity by."
]

@BaseClass = BModelParticleSpawner
[ 
	StartDisabled(choices) : "Start Disabled" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	Color(color255) : "Particle Color (R G B)" : "255 255 255"
	SpawnRate(integer) : "Particle Per Second" : 40 : "Number of particles to spawn, per second."
	SpeedMax(string) : "Maximum Particle Speed" : 13 : "Maximum speed that the particles can move after spawning."
	LifetimeMin(string) : "Minimum Particle Lifetime" : 3 : "Minimum number of seconds until each particle dies. Particles live for a random duration between this and 'Maximum Particle Lifetime'."
	LifetimeMax(string) : "Maximum Particle Lifetime" : 5 : "Maximum number of seconds until each particle dies. Particles live for a random duration between 'Minimum Particle Lifetime' and this."
	DistMax(integer) : "Maximum Visible Distance" : 1024 : "Maximum distance at which particles are visible. They fade to translucent at this distance."

	Frozen(choices) : "Frozen" : 0 : "When set, this entity spawns the number of particles in SpawnRate immediately, and then goes inactive." =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input TurnOn(void) : "Turn on."
	input TurnOff(void) : "Turn off."
]

@SolidClass base(Targetname, BModelParticleSpawner) sphere(DistMax) = func_dustmotes : 
	"A brush entity that spawns sparkling dust motes within its volume."
[
	SizeMin(string) : "Minimum Particle Size" : 10
	SizeMax(string) : "Maximum Particle Size" : 20

	Alpha(integer) : "Alpha" : 255 : "Transparency of the particles. 0 means they will be invisible and 255 means they will be opaque."
]

@SolidClass base( Targetname ) = func_smokevolume : 
	"A brush entity that spawns smoke particles within its volume."
[
	spawnflags(flags) =
	[
		1 : "[1] Emissive" : 0
	]

	Color1(color255) : "Particle Color1 (R G B)" : "255 255 255"
	Color2(color255) : "Particle Color2 (R G B)" : "255 255 255"
	material(material) : "Material" : "particle/particle_smokegrenade" : "The material to use for the particles"
	ParticleDrawWidth(float) : "Particle Draw Width (units)" : 120 : "The size of the particles, in units/inches."
	ParticleSpacingDistance(float) : "Particle Spacing Distance (units)" : 80 : "The distance between the particles inside the volume. The lower the number, the denser the particles, and the more overdraw there will be. It is best to keep it as high as you can without it looking bad."
	DensityRampSpeed(float) : "Density Ramp Speed (seconds)" : 1 : "Time to go from density 0 to density 1, in seconds."

	RotationSpeed(float) : "Rotation Speed (degrees/sec)" : 10 : "The speed that the particles should rotate, in degrees per second."
	MovementSpeed(float) : "Movement Speed (units/sec)" : 10 : "The speed that the particles should move around, in units/inches per second."
	Density(float) : "Density [0..1]" : 1

	// Inputs
	input SetRotationSpeed(float) : "Set the particle rotation speed (in degrees per second)."
	input SetMovementSpeed(float) : "Set the particle movement speed (in units/inches per second)."
	input SetDensity(float) : "Set the particle density. It should be a range from 0 to 1."
]

@SolidClass base( Targetname, BModelParticleSpawner ) sphere(DistMax) = func_dustcloud : 
	"A brush entity that spawns a translucent dust cloud within its volume."
[
	Alpha(integer) : "Alpha" : 30 : "Transparency of the particles. 0 means that they are invisible, 255 means opaque."

	SizeMin(string) : "Minimum Particle Size" : 100
	SizeMax(string) : "Maximum Particle Size" : 200
]

@PointClass base( Targetname, Parentname, Angles ) size( -8 -8 -8, 8 8 8 ) = env_dustpuff : 
	"An entity that can emit dust puffs."
[
	scale(float) : "Scale" : 8 : "Size of the dust puff."
	speed(float) : "Speed" : 16 : "Speed at which the dust particles should move."

	color(color255) : "Dust color" : "128 128 128"

	// Inputs
	input SpawnDust(void) : "Spawn a dust puff."
]

@PointClass base( Targetname, Parentname, Angles ) size( -8 -8 -8, 8 8 8 ) = env_particlescript : 
	"An entity that has special animation events that can be fired by a model with an animation inside its .qc designed for"+
	"use by this entity."
[
	model(studio) : "Script Model" : "models/Ambient_citadel_paths.mdl" : "Model to use for animation sequences."

	// Inputs
	input SetSequence(string) : "Sets the script model's sequence."
]


// NEEDHELP
@PointClass base( Targetname, Parentname, Angles ) size( -8 -8 -8, 8 8 8 ) = env_effectscript : 
	"An entity that allows you to script special visual effects via a script file."
[
	model(studio) : "Script Model" : "models/Effects/teleporttrail.mdl" : "Model to use for animation sequences."
	scriptfile(string) : "Script File" : "scripts/effects/testeffect.txt" : "Name of the script to use for this model." 

	// Inputs
	input SetSequence(string) : "Sets the script model's sequence."
]


//-------------------------------------------------------------------------
//
// Logic Entities
//
//-------------------------------------------------------------------------

@PointClass iconsprite("editor/logic_auto.vmt") = logic_auto : 
	"Fires outputs when a map spawns. " +
	"If 'Remove on fire' flag is set the logic_auto is deleted after firing. " +
	"It can be set to check a global state before firing. This allows you to only fire events based on "+
	"what took place in a previous map."
[
	spawnflags(Flags) =
	[
		1 : "[1] Remove on fire" : 1
	]
	
	globalstate(choices) : "Global State to Read" : : "If set, this specifies a global state to check before firing. The OnMapSpawn output will only fire if the global state is set." =
	[
		"" : "--- None ---"
		"gordon_precriminal" : "Gordon pre-criminal" 
		"antlion_allied" : "Antlions are player allies" 
//		"player_stealth" : "Player in APC is disguised as combine" 
		"suit_no_sprint" : "Suit sprint function not yet enabled" 
		"super_phys_gun" : "Super phys gun is enabled" 
		"friendly_encounter" : "Friendly encounter sequence (lower weapons, etc.)"
//		"citizens_passive" : "Citizens are *not* player allies (cannot be commanded)"
		"gordon_invulnerable" : "Gordon is invulnerable"
		"no_seagulls_on_jeep" : "Don't spawn seagulls on the jeep"
		"is_console" : "Game is running on a console"
		"is_pc" : "Game is running on a PC"
	]
	
	// Outputs
	output OnMapSpawn(void) : "Fired when the map is loaded for any reason."
	output OnNewGame(void) : "Fired when the map is loaded to start a new game."
	output OnLoadGame(void) : "Fired when the map is loaded from a saved game."
	output OnMapTransition(void) : "Fired when the map is loaded due to a level transition."
	output OnBackgroundMap(void) : "Fired when the map is loaded as a background to the main menu."
	output OnMultiNewMap(void) : "Fired only in multiplayer, when a new map is loaded."
	output OnMultiNewRound(void) : "Fired only in multiplayer, when a new round is started. Only fired in multiplayer games that use round-based gameplay."
]

@PointClass base(Targetname,Angles,Parentname) studioprop("models/editor/camera.mdl") frustum(fov,4,250,250 250 250,-1) = point_viewcontrol : 
	"A camera entity that controls the player's view. While it's active, the player will see out of the camera." 
[
	target(target_destination) : "Entity to Look At" : : "Name of the entity that the camera should point at and track while active."
	targetattachment(string) : "Target Attachment Name" : : "If set, the camera will focus on the specified attachment on the 'Entity to Look At'."
	wait(integer) : "Hold Time" : 10 : "The amount of time the camera should control the player's view for, after which it deactivates itself. If the camera should stay active until told to deactive, set the 'Infinite Hold Time' spawnflag."
	moveto(target_destination) : "Path Corner" : : "The first path corner in a track that the camera should move along once it's activated. If not specified, the camera won't move. This can actually be literally any entity, but don't worry about that."
	interpolatepositiontoplayer(choices) : "Interpolate Position To Player" : 0 : "Gradually interpolate player's position to here on start. (Episodic only)" =
	[
		0 : "No"
		1 : "Yes"
	]
	
	spawnflags(flags) =
	[
		1: "[1] Start At Player" : 1
		2: "[2] Follow Player" : 1
		4: "[4] Freeze Player" : 0
		8: "[8] Infinite Hold Time" : 0
		16:"[16] Snap to goal angles" : 0
		32:"[32] Make Player non-solid" : 0
		64:"[64] Interruptable by Player" : 0
		128:"[128] Set FOV" : 0
		256:"[256] Allow fixed behavior (can move without look target, removal stops softlock, etc.)" : 1
	]
	
	speed(string) : "Initial Speed" : "0" : "The starting speed that the camera moves at, if it's on a path track."
	acceleration(string) : "Acceleration units/sec^2" : "500" : "The speed at which the camera accelerates to path corner's desired speeds."
	deceleration(string) : "Stop Deceleration units/sec^2" : "500" : "The speed at which the camera decelerates to path corner's desired speeds."
	
	fov(float) : "FOV" : "75" : "The player's FOV when using this camera. Be sure to have the 'Set FOV' spawnflag enabled if you want to use this."
	fov_rate(float) : "FOV rate" : "0" : "How quickly the FOV should be set. Be sure to have the 'Set FOV' spawnflag enabled if you want to use this."
	
	DontSetPlayerView(choices) : "Don't set player view" : 0 : "Prevents this point_viewcontrol from actually controlling the player's view. FOV, player-affecting spawnflags, etc. may still happen." =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input Enable(void) : "Enable the point_viewcontrol, and start controlling the player's view."
	input Disable(void) : "Disable the point_viewcontrol, and stop controlling the player's view."

	// Outputs
	output OnEndFollow(void) : "Fired when the point_viewcontrol deactivates, due to the Disable input being received, the Entity to Look At being destroyed, or the Hold Time expiring."
	output OnStartFollow(void) : "Fired when the point_viewcontrol activates, usually due to the Enable input being received."
]

@PointClass base(Targetname) = point_posecontroller : 
	"An entity that controls a pose parameter of a prop and cycles the pose clientside." 
[
	PropName(target_destination) : "Target" : : "Name of the prop to control. Can be any animating entity."
	PoseParameterName(string) : "Pose Parameter Name" : : "Name of the pose parameter to control."
	PoseValue(float) : "Pose Parameter Value" : "0.0" : "Normalized value for the pose parameter from 0.0 and 1.0 (maps to min and max range)."
	InterpolationTime(float) : "Interpolation Time" : "0.0" : "Number of seconds (0.0 to 10.0) for client to match absolue pose values."
	InterpolationWrap(choices) : "Should wrap from 0.0 to 1.0 when interpolating." : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	CycleFrequency(float) : "Cycle Frequency" : "0.0" : "Base cycles per second from -10.0 to 10.0."
	FModulationType(choices) : "Frequency Modulation Type" : 0 = 
	[
		0: "None"
		1: "Sine"
		2: "Square"
		3: "Triangle"
		4: "Sawtooth"
		5: "Noise"
	]
	FModTimeOffset(float) : "Frequency Modulation Time Offset" : "0.0" : "Modulation time offset from -1.0f to 1.0."
	FModRate(float) : "Frequency Modulation Rate" : "0.0" : "Modulation cycles per second from -10.0f to 10.0."
	FModAmplitude(float) : "Frequency Modulation Amplitude" : "0.0" : "Modulation extents from 0.0f to 10.0."
	
	// Inputs
	input SetTarget(target_destination) : "Sets the prop to control."
	input SetPoseParameterName(string) : "Sets the pose parameter to control."
	input SetPoseValue(float) : "Set the pose parameter to a normalized value between 0.0 and 1.0 (maps to min and max range)."
	input SetInterpolationTime(float) : "Set the interpolation time to a number of seconds between 0.0 and 10.0."
	input SetCycleFrequency(float) : "Set the pose parameter's base cycles per second from -10.0f to 10.0."
	input SetFModType(integer) : "Set the type of frequency modulation."
	input SetFModTimeOffset(float) : "Set the modulation time offset from -1.0f to 1.0."
	input SetFModRate(float) : "Set the modulation cycles per second from -10.0f to 10.0."
	input SetFModAmplitude(float) : "Set the modulation extents from 0.0f to 10.0."
	input RandomizeFMod(float) : "Randomize the frequency modulation by an extremeness of 0.0 to 1.0."
]

@PointClass base(Targetname) iconsprite("editor/logic_compare.vmt") = logic_compare :
	"Compares an input value to another value. " +
	"If the input value is less than the compare value, the OnLessThan output is fired with the input value. " +
	"If the input value is equal to the compare value, the OnEqualTo output is fired with the input value. " +	
	"If the input value is greater than the compare value, the OnGreaterThan output is fired with the input value."
[
	// Keys
	InitialValue(string) : "Initial value" : : "Initial value for the input value. This keyvalue supports matchers (<, >, !=, etc.)."
	CompareValue(string) : "Compare value" : : "The value to compare against. This keyvalue supports matchers (<, >, !=, etc.)."
	
	// Inputs
	input SetValue(string) : "Sets the value that will be compared against the compare value."
	input SetValueCompare(string) : "Sets the value that will be compared against the compare value and performs the comparison."
	input SetCompareValue(string) : "Sets the compare value."
	input SetCompareValueCompare(string) : "Sets the compare value and performs the comparison."
	input Compare(void) : "Forces a compare of the input value with the compare value."
	
	// Outputs
	output OnLessThan(string) : "Fired when the input value is less than the compare value. Sends the input value as data." 
	output OnEqualTo(string) : "Fired when the input value is equal to the compare value. Sends the input value as data." 
	output OnNotEqualTo(string) : "Fired when the input value is different from the compare value. Sends the input value as data." 
	output OnGreaterThan(string) : "Fired when the input value is greater than the compare value. Sends the input value as data."
	output OnGreaterThanOrEqualTo(string) : "Fired when the input value is greater than or equal to the compare value. Sends the input value as data."
	output OnLessThanOrEqualTo(string) : "Fired when the input value is greater than or equal to the compare value. Sends the input value as data."
]

@PointClass base(Targetname) iconsprite("editor/logic_branch.vmt") = logic_branch :
	"Tests a boolean value and fires an output based on whether the value is true or false. " +
	"Use this entity to branch between two potential sets of events."
[
	// Keys
	InitialValue(integer) : "Initial value" : : "Initial value for the boolean value (0 or 1)."
	
	// Inputs
	input SetValue(bool) : "Set the boolean value without performing the comparison. Use this to hold a value for a future test."
	input SetValueTest(bool) : "Set the boolean value and test it, firing OnTrue or OnFalse based on the new value."
	input Toggle(void) : "Toggle the boolean value between true and false."
	input ToggleTest(void) : "Toggle the boolean value and tests it, firing OnTrue or OnFalse based on the new value."
	input Test(void) : "Test the input value and fire OnTrue or OnFalse based on the value."
	
	// Outputs
	output OnTrue(void) : "Fired when the input value is true (nonzero)." 
	output OnFalse(void) : "Fired when the input value is false (zero)." 
]


@PointClass base(Targetname) = logic_branch_listener :
	"Contains a list of logic_branch entities and fires outputs when the state of any of the logic_branches changes.\n\n"+
	"This entity is used to fire an event when a set of conditions are all satisfied."
[
	Branch01(target_destination) : "Logic Branch 01" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch02(target_destination) : "Logic Branch 02" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch03(target_destination) : "Logic Branch 03" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch04(target_destination) : "Logic Branch 04" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch05(target_destination) : "Logic Branch 05" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch06(target_destination) : "Logic Branch 06" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch07(target_destination) : "Logic Branch 07" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch08(target_destination) : "Logic Branch 08" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch09(target_destination) : "Logic Branch 09" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch10(target_destination) : "Logic Branch 10" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch11(target_destination) : "Logic Branch 11" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch12(target_destination) : "Logic Branch 12" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch13(target_destination) : "Logic Branch 13" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch14(target_destination) : "Logic Branch 14" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch15(target_destination) : "Logic Branch 15" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch16(target_destination) : "Logic Branch 16" : : "The name of one or more logic_branches (wildcards allowed)."

	input Test(void) : "Tests the state of all the logic_branches in the list and fires the appropriate output."

	output OnAllTrue(void) : "Fired when all the logic_branches in the list become true."
	output OnAllFalse(void) : "Fired when all the logic_branches in the list become false."
	output OnMixed(void) : "Fired when one of the logic branches in the list changes, but some are true and some are false."
]


@PointClass base(Targetname) iconsprite("editor/logic_case.vmt") = logic_case :
	"Compares an input to up to 16 preset values. If the input value is the same as " +
	"any of the preset values, an output corresponding to that value is fired.\n\n" +
	"For example: if Case01 is set to 2 and Case02 is set to 5, and the input value is 5, " +
	"the OnCase02 output will be fired.\n\n" +
	"This entity can also be used to select from a number of random targets via the " +
	"PickRandom input. One of the OnCase outputs that is connected to another entity will " +
	"be picked at random and fired."
[
	MultipleCasesAllowed(choices) : "Multiple case hits allowed" : 0 : "If an input value matches a given case, are we allowed to test the rest of the cases or should we stop there? Don't worry about this if you're only using this entity for PickRandom." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	Case01(string) : "Case 01" : : "Fires OnCase01 if the InValue parameter matches this value. This keyvalue supports matchers (<, >, !=, etc.). Not needed for PickRandom or PickRandomShuffle."
	Case02(string) : "Case 02" : : "Fires OnCase02 if the InValue parameter matches this value. This keyvalue supports matchers (<, >, !=, etc.). Not needed for PickRandom or PickRandomShuffle."
	Case03(string) : "Case 03" : : "Fires OnCase03 if the InValue parameter matches this value. This keyvalue supports matchers (<, >, !=, etc.). Not needed for PickRandom or PickRandomShuffle."
	Case04(string) : "Case 04" : : "Fires OnCase04 if the InValue parameter matches this value. This keyvalue supports matchers (<, >, !=, etc.). Not needed for PickRandom or PickRandomShuffle."
	Case05(string) : "Case 05" : : "Fires OnCase05 if the InValue parameter matches this value. This keyvalue supports matchers (<, >, !=, etc.). Not needed for PickRandom or PickRandomShuffle."
	Case06(string) : "Case 06" : : "Fires OnCase06 if the InValue parameter matches this value. This keyvalue supports matchers (<, >, !=, etc.). Not needed for PickRandom or PickRandomShuffle."
	Case07(string) : "Case 07" : : "Fires OnCase07 if the InValue parameter matches this value. This keyvalue supports matchers (<, >, !=, etc.). Not needed for PickRandom or PickRandomShuffle."
	Case08(string) : "Case 08" : : "Fires OnCase08 if the InValue parameter matches this value. This keyvalue supports matchers (<, >, !=, etc.). Not needed for PickRandom or PickRandomShuffle."
	Case09(string) : "Case 09" : : "Fires OnCase09 if the InValue parameter matches this value. This keyvalue supports matchers (<, >, !=, etc.). Not needed for PickRandom or PickRandomShuffle."
	Case10(string) : "Case 10" : : "Fires OnCase10 if the InValue parameter matches this value. This keyvalue supports matchers (<, >, !=, etc.). Not needed for PickRandom or PickRandomShuffle."
	Case11(string) : "Case 11" : : "Fires OnCase11 if the InValue parameter matches this value. This keyvalue supports matchers (<, >, !=, etc.). Not needed for PickRandom or PickRandomShuffle."
	Case12(string) : "Case 12" : : "Fires OnCase12 if the InValue parameter matches this value. This keyvalue supports matchers (<, >, !=, etc.). Not needed for PickRandom or PickRandomShuffle."
	Case13(string) : "Case 13" : : "Fires OnCase13 if the InValue parameter matches this value. This keyvalue supports matchers (<, >, !=, etc.). Not needed for PickRandom or PickRandomShuffle."
	Case14(string) : "Case 14" : : "Fires OnCase14 if the InValue parameter matches this value. This keyvalue supports matchers (<, >, !=, etc.). Not needed for PickRandom or PickRandomShuffle."
	Case15(string) : "Case 15" : : "Fires OnCase15 if the InValue parameter matches this value. This keyvalue supports matchers (<, >, !=, etc.). Not needed for PickRandom or PickRandomShuffle."
	Case16(string) : "Case 16" : : "Fires OnCase16 if the InValue parameter matches this value. This keyvalue supports matchers (<, >, !=, etc.). Not needed for PickRandom or PickRandomShuffle."

	// Inputs
	input InValue(string) : "Compares the Input value to the case values, and fires the appropriate output, if any."
	input PickRandom(void) : "Fires a random OnCase output with at least one connection."
	input PickRandomShuffle(void) : "Fires a random OnCase output with at least one connection, with no repeats until all cases have been picked, at which point the shuffle starts over."
	
	// Outputs
	output OnCase01(void) : "Fired when the input value equals the Case01 value."
	output OnCase02(void) : "Fired when the input value equals the Case02 value."
	output OnCase03(void) : "Fired when the input value equals the Case03 value."
	output OnCase04(void) : "Fired when the input value equals the Case04 value."
	output OnCase05(void) : "Fired when the input value equals the Case05 value."
	output OnCase06(void) : "Fired when the input value equals the Case06 value."
	output OnCase07(void) : "Fired when the input value equals the Case07 value."
	output OnCase08(void) : "Fired when the input value equals the Case08 value."
	output OnCase09(void) : "Fired when the input value equals the Case09 value."
	output OnCase10(void) : "Fired when the input value equals the Case10 value."
	output OnCase11(void) : "Fired when the input value equals the Case11 value."
	output OnCase12(void) : "Fired when the input value equals the Case12 value."
	output OnCase13(void) : "Fired when the input value equals the Case13 value."
	output OnCase14(void) : "Fired when the input value equals the Case14 value."
	output OnCase15(void) : "Fired when the input value equals the Case15 value."
	output OnCase16(void) : "Fired when the input value equals the Case16 value."
	output OnDefault(string) : "Fired when the input value does not equal any of the Case values. Passes the input value."
	output OnUsed(string) : "Fired when an input value is received, regardless of whether it matches a case. Passes the input value."
]

// Original Comment >>> NEEDHELP: Unused in HL2, not clear what it's useful for.
// 
// Apparently, this entity's usefulness was called into question at some point by Valve programmers.
// Either way, I've changed it a lot, so this may (or may not) be useful now.
@PointClass base(Targetname) iconsprite("editor/logic_multicompare.vmt") = logic_multicompare :
	"Compares a set of inputs to each other. If they are all the same, fires an OnEqual output. " +
	"If any are different, fires the OnNotEqual output." +
	"There is currently no way to remove inputs."
[
	// Keys
	IntegerValue(string) : "Reference Value (optional)" : : "The value all inputs are compared to if ''Should use Reference Value'' is enabled."
	ShouldComparetoValue(choices) : "Should use Reference Value" : 0 : "If enabled, all inputs are compared to the reference value. If not enabled, they are instead compared to the last input added." =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input InputValue(string) : "Adds a value to our set of inputs and fires CompareValues automatically, comparing existing inputs to this one if set to do so."
	input InputValueNoFire(string) : "Adds a value to our set of inputs without firing CompareValues."
	input SetReferenceValue(string) : "Sets our reference value."
	input CompareValues(void) : "Compares the values and fires appropriate outputs."

	// Outputs
	output OnEqual(string) : "Fires if the compared value is equal to all of our inputs. Passes the compared value."
	output OnNotEqual(string) : "Fires if the compared value is equal to all of our inputs. Passes the violator."
]

// Mapbase - Taken directly from Portal 2 base FGD.
@PointClass base(Targetname, EnableDisable) iconsprite("editor/logic_random_outputs.vmt") = logic_random_outputs :
	"A message forwarder. Fires up to eight separate outputs, each with a different chance of firing."
[
	spawnflags(flags) =
	[
		1: "[1] Only trigger once" : 0
		2: "[2] Allow fast retrigger" : 0
	]
	OnTriggerChance1(float) : "OnTrigger1 Chance" : "1.0" : "Chance (from 0 to 1) of the OnTrigger1 output firing when this entity is triggered."
	OnTriggerChance2(float) : "OnTrigger2 Chance" : "1.0" : "Chance (from 0 to 1) of the OnTrigger2 output firing when this entity is triggered."
	OnTriggerChance3(float) : "OnTrigger3 Chance" : "1.0" : "Chance (from 0 to 1) of the OnTrigger3 output firing when this entity is triggered."
	OnTriggerChance4(float) : "OnTrigger4 Chance" : "1.0" : "Chance (from 0 to 1) of the OnTrigger4 output firing when this entity is triggered."
	OnTriggerChance5(float) : "OnTrigger5 Chance" : "1.0" : "Chance (from 0 to 1) of the OnTrigger5 output firing when this entity is triggered."
	OnTriggerChance6(float) : "OnTrigger6 Chance" : "1.0" : "Chance (from 0 to 1) of the OnTrigger6 output firing when this entity is triggered."
	OnTriggerChance7(float) : "OnTrigger7 Chance" : "1.0" : "Chance (from 0 to 1) of the OnTrigger7 output firing when this entity is triggered."
	OnTriggerChance8(float) : "OnTrigger8 Chance" : "1.0" : "Chance (from 0 to 1) of the OnTrigger8 output firing when this entity is triggered."

	// Inputs
	input Trigger(void) : "Trigger this entity, causing its OnTrigger outputs to fire if it is enabled."
	input Toggle(void) : "Toggle this entity between enabled and disabled."
	//input CancelPending(void) : "Cancel any events fired by this entity that are currently pending in the I/O event queue."
	
	// Outputs
	output OnSpawn(void) : "Fired when this entity is spawned. If this entity is set to only trigger once, it will "+
		"delete itself after firing this output."
	output OnTrigger1(void) : "This output has a chance to fire when the entity is triggered."
	output OnTrigger2(void) : "This output has a chance to fire when the entity is triggered."
	output OnTrigger3(void) : "This output has a chance to fire when the entity is triggered."
	output OnTrigger4(void) : "This output has a chance to fire when the entity is triggered."
	output OnTrigger5(void) : "This output has a chance to fire when the entity is triggered."
	output OnTrigger6(void) : "This output has a chance to fire when the entity is triggered."
	output OnTrigger7(void) : "This output has a chance to fire when the entity is triggered."
	output OnTrigger8(void) : "This output has a chance to fire when the entity is triggered."
]

@PointClass base(Targetname, EnableDisable) size(-8 -8 -8, 8 8 8) = logic_register_activator :
	"Stores an entity and sends messages with it as the activator\n" +
	"Useful for keeping track of entities with mangled names due " +
	"to template spawners and instances."
[
	// Inputs
	input Toggle(void) : "Toggle between enabled and disabled."
	input FireRegisteredAsActivator1(void) : "Start a message from this entity using the matching OnRegisteredActivating - but the activator is the registered entity."
	input FireRegisteredAsActivator2(void) : "Start a message from this entity using the matching OnRegisteredActivating - but the activator is the registered entity."
	input FireRegisteredAsActivator3(void) : "Start a message from this entity using the matching OnRegisteredActivating - but the activator is the registered entity."
	input FireRegisteredAsActivator4(void) : "Start a message from this entity using the matching OnRegisteredActivating - but the activator is the registered entity."
	input RegisterEntity(target_destination) : "Stores an entity to later be used as an activator."
	
	// Outputs
	output OnRegisteredActivate1(void) : "Fired to send a message using the registered as the activator."
	output OnRegisteredActivate2(void) : "Fired to send a message using the registered as the activator."
	output OnRegisteredActivate3(void) : "Fired to send a message using the registered as the activator."
	output OnRegisteredActivate4(void) : "Fired to send a message using the registered as the activator."
]

@PointClass base(Targetname, EnableDisable) iconsprite("editor/logic_relay.vmt") = logic_relay :
	"A message forwarder. Fires an OnTrigger output when triggered, and " +
	"can be disabled to prevent forwarding outputs.\n\n" +
	"Useful as an intermediary between one entity and another for turning " +
	"on or off an I/O connection, or as a container for holding a set of " +
	"outputs that can be triggered from multiple places."
[
	spawnflags(flags) =
	[
		1: "[1] Only trigger once" : 0
		2: "[2] Allow fast retrigger" : 0
	]

	// Inputs
	input Trigger(void) : "Triggers the relay, causing its OnTrigger output to fire if it is enabled."
	input TriggerWithParameter(string) : "Triggers the relay with a parameter, causing its OnTriggerParameter output to fire if it is enabled."
	input Toggle(void) : "Toggle the relay between enabled and disabled."
	//input CancelPending(void) : "Cancel any events fired by this relay that are currently pending in the I/O event queue."
	input EnableRefire(void) : "If fast retrigger is disabled, the relay will not be able to fire again until its most delayed output has been fired. "+
		"This input allows the relay to fire again early if it is in this state."
	
	// Outputs
	output OnSpawn(void) : "Fired when the relay is spawned. If the relay is set to only trigger once, it will "+
		"delete itself after firing this output."
	output OnTrigger(void) : "Fired when the relay is triggered. If the relay is set to only trigger once, it will "+
		"delete itself after firing this output."
	output OnTriggerParameter(string) : "Fired when the relay is triggered with a parameter. If the relay is set to only trigger once, it will "+
		"delete itself after firing this output."
]

@PointClass base(Targetname, EnableDisable) iconsprite("editor/logic_relay_queue.vmt") = logic_relay_queue :
	"A special variant of logic_relay designed to queue trigger inputs. " +
	"If the relay is still handling its I/O connections after being triggered, additional Trigger inputs will be queued and automatically fire when the relay is able to be re-fired. Activator, output ID, and parameter are all kept and saved. " +
	"Inputs are added to the queue each time Trigger or TriggerWithParameter are received while the relay is disabled or still handling its current I/O connections. The first one in the queue will trigger the moment an opportunity becomes available and the next one in the queue will wait for that one.\n\n" +
	"This is useful for when you don't want something to happen multiple times at once, but don't want to discard further requests either."
[
	SetMaxQueueItems(integer) : "Maximum Items" : 3 : "The maximum number of Trigger and TriggerWithParameter inputs allowed in the queue. Any others received while this value is full will be discarded. Keep in mind this does not count the I/O chain currently being handled."
	
	DontQueueWhenDisabled(choices) : "Don't queue when disabled" : 0 : "Prevents the relay from queuing inputs when disabled. This means inputs will only be queued when enabled and still handling its current I/O connections." =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input Trigger(void) : "Triggers the relay, causing its OnTrigger output to fire if it is enabled."
	input TriggerWithParameter(string) : "Triggers the relay with a parameter, causing its OnTriggerParameter output to fire if it is enabled."
	input Toggle(void) : "Toggle the relay between enabled and disabled."
	//input CancelPending(void) : "Cancel any events fired by this relay that are currently pending in the I/O event queue."
	input EnableRefire(void) : "If fast retrigger is disabled, the relay will not be able to fire again until its most delayed output has been fired. "+
		"This input allows the relay to fire again early if it is in this state."
		
	input ClearQueue(void) : "Clears the input queue."
	input SetMaxQueueItems(integer) : "Sets the maximum queue items."
	
	// Outputs
	output OnTrigger(void) : "Fired when the relay is triggered."
	output OnTriggerParameter(string) : "Fired when the relay is triggered with a parameter."
]

@PointClass base(Targetname) iconsprite("editor/logic_script.vmt") = logic_script : "An entity that acts as a container for scripts"
[
	Group00(target_destination) : "EntityGroup[0]"
	Group01(target_destination) : "EntityGroup[1]"
	Group02(target_destination) : "EntityGroup[2]"
	Group03(target_destination) : "EntityGroup[3]"
	Group04(target_destination) : "EntityGroup[4]"
	Group05(target_destination) : "EntityGroup[5]"
	Group06(target_destination) : "EntityGroup[6]"
	Group07(target_destination) : "EntityGroup[7]"
	Group08(target_destination) : "EntityGroup[8]"
	Group09(target_destination) : "EntityGroup[9]"
	Group10(target_destination) : "EntityGroup[10]"
	Group11(target_destination) : "EntityGroup[11]"
	Group12(target_destination) : "EntityGroup[12]"
	Group13(target_destination) : "EntityGroup[13]"
	Group14(target_destination) : "EntityGroup[14]"
	Group15(target_destination) : "EntityGroup[15]"
]

@PointClass base(Targetname) iconsprite("editor/logic_script_client.vmt") = logic_script_client : "An entity capable of running client-side scripts"
[
	ClientThink(choices) : "Client Think" : 0 : "Allows client-side VScript to run a think function in the form of a 'ClientThink' hook. (NOTE: The 'Script think function' keyvalue is not related to this!)" =
	[
		0 : "No"
		1 : "Yes"
	]
	
	RunOnServer(choices) : "Run on Server" : 0 : "Runs the entity scripts on the server as well as the client. Use IsServer() or IsClient() to determine which side is running from within the scripts." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	input CallScriptFunctionClient(string) : "Call a named function on the entity's client-side script scope."
]

@PointClass base(Targetname, EnableDisable) iconsprite("editor/logic_timer.vmt") = logic_timer :
	"An entity that fires a timer event at regular, or random, intervals. It can also be set to oscillate between" + 
	"a high and low end, in which case it will fire alternating high/low outputs each time it fires."
[
	// Keys
	spawnflags(flags) =
	[
		1 : "[1] Oscillator (alternates between OnTimerHigh and OnTimerLow outputs)" : 0
	]

	UseRandomTime(choices) : "Use Random Time" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	
	LowerRandomBound(string) : "Minimum Random Interval" : : "If 'Use Random Time' is set, this is the minimum time between timer fires. The time will be a random number between this and the 'Maximum Random Interval'."
	UpperRandomBound(string) : "Maximum Random Interval" : : "If 'Use Random Time' is set, this is the maximum time between timer fires. The time will be a random number between the 'Minimum Random Interval' and this."
	RefireTime(string) : "Refire Interval" : : "If 'Use Random Time' isn't set, this is the time between timer fires, in seconds."
	
	UseBoundsForTimerInputs(choices) : "Limit Timer Inputs" : 0 : "Allows the Minumum/Maximum Random Interval keyvalues to limit the total timer value when it receives AddToTimer or SubtractFromTimer inputs." =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input RefireTime(integer) : "Set a new Refire Interval."
	input ResetTimer(void) : "Reset the timer. It will fire after the Refire Interval expires."
	input FireTimer(void) : "Force the timer to fire immediately."
	input Enable(void) : "Enable the timer."
	input Disable(void) : "Disable the timer."
	input Toggle(void) : "Toggle the timer on/off."
	input LowerRandomBound(float) : "Set a new Minimum Random Interval."
	input UpperRandomBound(float) : "Set a new Maximum Random Interval."
	input AddToTimer(float) : "Add time to the timer if it is currently enabled.  Does not change the Refire Interval."
	input SubtractFromTimer(float) : "Subtract time from the timer if it is currently enabled.  Does not change the Refire Interval."


	// Outputs
	output OnTimer(void) : "Fired when the timer expires."
	output OnTimerHigh(void) : "Fired every other time for an oscillating timer."
	output OnTimerLow(void) : "Fired every other time for an oscillating timer."
]


@PointClass base(Targetname) = hammer_updateignorelist :
	"Specifies entities that are to be ignored by the hammer_update_safe_entities console command. " + 
	"Enter the targetnames of entities that you want to exclude into the list of fields here. " +
	"Several of these may exist in a map."
[
	IgnoredName01(target_destination) : "IgnoredName 01" : "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName02(target_destination) : "IgnoredName 02" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName03(target_destination) : "IgnoredName 03" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName04(target_destination) : "IgnoredName 04" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName05(target_destination) : "IgnoredName 05" : ""  : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName06(target_destination) : "IgnoredName 06" : ""  : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName07(target_destination) : "IgnoredName 07" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName08(target_destination) : "IgnoredName 08" : ""  : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName09(target_destination) : "IgnoredName 09" : ""  : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName10(target_destination) : "IgnoredName 10" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName11(target_destination) : "IgnoredName 11" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName12(target_destination) : "IgnoredName 12" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName13(target_destination) : "IgnoredName 13" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName14(target_destination) : "IgnoredName 14" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName15(target_destination) : "IgnoredName 15" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName16(target_destination) : "IgnoredName 16" : ""  : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
]


@PointClass base(Targetname) size(-4 -4 -4, 4 4 4) color(0 255 0) = logic_collision_pair : 
	"An entity that can be used to enables/disable vphysics collisions between two target entities."
[
	attach1(target_destination) : "Attachment 1" : "" : "The first entity."
	attach2(target_destination) : "Attachment 2" : "" : "The second entity."

	startdisabled(choices) : "Start with collisions disabled" : 1 =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input EnableCollisions(void) : "Enable collisions between the first and second entity."
	input DisableCollisions(void) : "Disable collisions between the first and second entity."
]


@PointClass base(Targetname, Parentname, EnableDisable) iconsprite("editor/env_microphone.vmt") sphere(MaxRange) color(0 0 255) = env_microphone :
	"An entity that acts as a microphone. It works in one of two modes. If it has a 'Speaker' set, it picks up all sounds within the specified sound range, " +
	"and rebroadcasts them through the Speaker entity. In this Speaker mode, it ignores the Hears X spawnflags and does not fire the SoundLevel output. " +
	"If it has no Speaker set, it measures the sound level at a point, and outputs the sound level as a value between 0 and 1. In Measuring mode, it only hears sounds that match the Hear X spawnflags."
[
	target(target_destination) : "Measure target" : : "If the speaker is in Measuring mode, this is the name of the entity where the sound level is to be measured."
	SpeakerName(target_destination) : "Speaker target" : "" : "The name of an info_target entity through which to play any sounds heard by this microphone. If specified, the microphone will consider itself in Speaker mode."
	ListenFilter(filterclass) : "Listen Filter" : "" : "The name of an filter entity which specifies the only entities the microphone can hear. Sounds emitted by other entities will not be heard."
	speaker_dsp_preset(choices) : "Speaker DSP Preset" : 0 : "Only useful in Speaker mode. If specified, when the microphone is enabled, it'll set the global dsp_speaker preset to this value. Sounds played back through speakers will then be affected by the selected DSP." =
	[
 		0 : "Use Default"
		50 : "1 NO EFFECT"
		51 : "2 (DUPLICATE OF 1)"
		52 : "3 (DUPLICATE OF 1)"
		53 : "4 (DUPLICATE OF 1)"
		54 : "5 (DUPLICATE OF 1)"
		55 : "6 SPEAKER, LOUDER"
		56 : "7 SPEAKER VERY SMALL"
		57 : "8 LOUDSPEAKER, ECHO"
		58 : "9 SPEAKER SMALL"
		59 : "10 SPEAKER TINY"
		
		// A few unmarked DSP presets added with Mapbase
		32 : "32 EXPLOSION MUFFLE 1"
		33 : "33 EXPLOSION MUFFLE 2"
		34 : "34 EXPLOSION MUFFLE 3"
		35 : "35 EXPLOSION RING 1"
		36 : "36 EXPLOSION RING 2"
		37 : "37 EXPLOSION RING 3"
		38 : "38 ''EXPLOSION RING'' 4"
		44 : "44 Test 1 (High Pitch)"
		45 : "45 Test 2 (Low Pitch)"
		46 : "46 Test 3 (Silence?)"
		47 : "47 Test 4 (Distort)"
		48 : "48 Test 5 (Long Wobble)"
		49 : "49 Test 6 (Silence?)"
	]

	spawnflags(flags) =
	[
		1 : "[1] Hears combat sounds" : 1
		2 : "[2] Hears world sounds" : 1
		4 : "[4] Hears player sounds" : 1
		8 : "[8] Hears bullet impacts" : 1
		16: "[16] Swallows sounds routed through speakers" : 0
		32: "[32] Hears explosions" : 0
		64: "[64] Ignores non-attenuated sounds" : 0
		128 : "[128] Hears sentences (Combine dialogue, etc.)" : 1
	]

	Sensitivity(float) : "Sensitivity (0 - 10)" : 1 : "Microphone sensitivity, 0=deaf, 1=default, 10=extremely sensitive). Only applicable in Measuring mode."
	SmoothFactor(float) : "Smoothing (0 - 1)" : 0 : "Smoothing factor, 0=no smoothing, 1=maximum smoothing). Only applicable in Measuring mode."
	MaxRange(float) : "Maximum hearing range (0=infinite)" : 240 : "Sounds beyond this range won't be heard, irrelevant of attenuation. "+
		"WARNING: setting this to zero (or a value > 1024) when the microphone is in Speaker mode can be very bad for performance!!"
		
	landmark(target_destination) : "Local Destination Landmark" : : "If specified, then sounds offset from the speaker by their initial offset from this landmark. Only applicable in Speaker mode."
	
	PitchScale(float) : "Pitch Scale" : "1.0" : "Scales the pitch of transmitted sounds. Only applicable in Speaker mode."
	VolumeScale(float) : "Volume Scale" : "1.0" : "Scales the volume of transmitted sounds. Only applicable in Speaker mode."
	
	channel(choices) : "Channel" : 6 : "Sets the channel which sounds should transmit as. Only applicable in Speaker mode." =
	[
 		0 : "CHAN_AUTO"
 		1 : "CHAN_WEAPON"
 		2 : "CHAN_VOICE"
 		3 : "CHAN_ITEM"
 		4 : "CHAN_BODY"
 		5 : "CHAN_STREAM"
 		6 : "CHAN_STATIC"
 		7 : "CHAN_VOICE2"
	]

	// Inputs
	input SetSpeakerName(target_destination) : "Set the microphone to output through a different speaker entity."
	input SetDSPPreset(integer) : "Sets our DSP preset."
	input SetPitchScale(float) : "Sets the pitch scale."
	input SetVolumeScale(float) : "Sets the volume scale."
	input SetChannel(integer) : "Sets the channel."

	// Outputs
	output SoundLevel(float) : "Fired in Measuring mode whenever the sound level changes."
	output OnRoutedSound(void) : "Fired whenever a sound is routed out through the specified speaker (if any)."
	output OnHeardSound(void) : "Fired whenever this microphone hears any sound it cares about."
]

@PointClass base(Targetname, EnableDisable ) = math_remap :
	"An entity that remaps a range of input values to a given range of output values."
[
	spawnflags(flags) = 
	[
		1 : "[1] Ignore out of range input values" : 1
		2 : "[2] Clamp output to output range" : 2
	]

	in1(integer) : "Minimum Valid Input Value" : 0 : "Input values below this value will be ignored."
	in2(integer) : "Maximum Valid Input Value" : 1 : "Input values above this value will be ignored."
	out1(integer) : "Output Value When Input Is Min." : : "When the input value is equal to 'Minimum Valid Input Value', this is the output value."
	out2(integer) : "Output Value When Input Is Max." : : "When the input value is equal to 'Maximum Valid Input Value', this is the output value."

	// Inputs
	input InValue(float) : "Input value and fire the output with the remapped value."
	
	// Outputs
	output OutValue(float) : "Fired when the InValue input is received, with the remapped input value as the parameter."
]

@PointClass base(Targetname) = math_colorblend :
	"Used to create a blend between two colors for controlling the color of another entity."
[
	spawnflags(flags) = 
	[
		1 : "[1] Ignore out of range input values" : 1
	]

	inmin(integer) : "Minimum Valid Input Value" : 0 : "Input values below this value will be ignored."
	inmax(integer) : "Maximum Valid Input Value" : 1 : "Input values above this value will be ignored."
	colormin(color255) : "Output RGB color when input is min." : "0 0 0" : "When the input value is equal to 'Minimum Valid Input Value', this is the output RGB color."
	colormax(color255) : "Output RGB color when input is max." : "255 255 255" : "When the input value is equal to 'Maximum Valid Input Value', this is the output RGB color."

	// Inputs
	input InValue(float) : "Input value and fire the output with the remapped value."
	
	// Outputs
	output OutColor(color255) : "Fired when the InValue input is received, with the remapped RGB color as the parameter."
]

@PointClass base(Targetname, EnableDisable) iconsprite("editor/math_counter.vmt") = math_counter :
	"Holds a numeric value and performs arithmetic operations upon it. If either the minimum or maximum " +
	"legal value is nonzero, OutValue will be clamped to the legal range, and the OnHitMin/OnHitMax " +
	"outputs will be fired at the appropriate times. If both min and max are set to zero, no clamping is " +
	"performed and only the OutValue output will be fired."
[
	// Keys
	startvalue(float) : "Initial Value" : 0 : "Starting value for the counter."
	min(float) : "Minimum Legal Value" : 0 : "Minimum legal value for the counter. If min=0 and max=0, no clamping is performed."
	max(float) : "Maximum Legal Value" : 0 : "Maximum legal value for the counter. If min=0 and max=0, no clamping is performed."

	// Inputs
	input Add(float) : "Add an amount to the counter and fire the OutValue output with the result."
	input Divide(float): "Divide the counter by an amount and fire the OutValue output with the result."
	input Multiply(float): "Multiply the counter by an amount and fire the OutValue output with the result."
	input SetValue(float): "Set the counter to a new value and fire the OutValue output with the result."
	input SetValueNoFire(float): "Set the counter to a new value without firing any outputs."
	input Subtract(float): "Subtract an amount from the counter and fire the OutValue output with the result."
	input SetHitMax(float): "Set the upper bound of the counter and fire the OutValue output with the current value."
	input SetHitMin(float): "Set the lower bound of the counter and fire the OutValue output with the current value."
	input GetValue(void): "Causes the counter to fire its OnGetValue output with the current value of the counter. Used for polling the counter when you don't want constant updates from the OutValue output."
	input SetMaxValueNoFire(float): "Set the upper bound of the counter without firing any outputs."
	input SetMinValueNoFire(float): "Set the lower bound of the counter without firing any outputs."

	// Outputs
	output OutValue(float) : "Fired when the counter value changes."
	output OnHitMin(void) : "Fired when the counter value meets or goes below the min value. The counter must go back above the min value before the output will fire again."
	output OnHitMax(void) : "Fired when the counter value meets or exceeds the max value. The counter must go below the max value before the output will fire again."
	output OnGetValue(float) : "Fired in response to the GetValue input. Used for polling the counter when you don't want constant updates from the OutValue output."
	output OnChangedFromMin(void) : "Fired when the counter value changes from the minimum value."
	output OnChangedFromMax(void) : "Fired when the counter value changes from the maximum value."
]

@PointClass base(Targetname, EnableDisable, math_counter) iconsprite("editor/math_counter_advanced.vmt") = math_counter_advanced :
	"A special version of math_counter with the ability to perform advanced calculations. " +
	"Otherwise functions identically to math_counter."
[
	// Keys
	PreserveValue(choices) : "Preserve Value?" : 0 : "If set to 'Yes', calculations will fire OutValue with the resulting value, but the actual value stored in this entity will stay the same, allowing future calculations to use a constant value. If you want to change the value, you must use SetValueNoFire to set the counter's value or the PreserveValue input to toggle this feature. This also disables min/max functionality." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	AlwaysOutputAsInt(choices) : "Always Output As Int" : 0 : "If set to 'Yes', the stored value (and OutValue) will always be rounded to an integer before firing." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	SetLerpPercent(float) : "Lerp Percent" : "0.5" : "The percentage used by the LerpTo input."

	// Inputs
	input PreserveValue(bool): "Sets whether this counter's value should be preserved after calculations. 1 = Yes, 0 = No"
	input AlwaysOutputAsInt(bool): "Sets whether this counter's value should always output as an integer. 1 = Yes, 0 = No"
	
	input SetValueToPi(void) : "Sets the counter's value to 3.14159265358979323846 and fires the OutValue output with it."
	
	input SquareRoot(void) : "Calculates the square root of the counter's current value. Fires the OutValue output with the result."
	input Power(integer) : "Raises the power of the counter's current value to this value. Fires the OutValue output with the result."
	
	input Round(integer) : "Rounds the counter's current value to the specified number place. For example, rounding 256 to 100 will round it to 300 and rounding 256 to 10 will round it to 260. Use 0 to round decimals to integers. Fires the OutValue output with the result."
	input Floor(integer) : "Floors, or rounds down, the counter's current value to the specified number place. Fires the OutValue output with the result."
	input Ceil(integer) : "Ceils, or rounds up, the counter's current value to the specified number place. Fires the OutValue output with the result."
	input Trunc(integer) : "Truncates, or rounds toward zero, the counter's current value to the specified number place. Fires the OutValue output with the result."
	
	input Sin(void) : "Applies sine to the counter's current value. Fires the OutValue output with the result."
	input Cos(void) : "Applies cosine to the counter's current value. Fires the OutValue output with the result."
	input Tan(void) : "Applies tangent to the counter's current value. Fires the OutValue output with the result."
	
	input RandomInt(string) : "Generates a random integer between the specified bounds. Format = 'lowerbound upperbound', like '22 65'. Fires the OutValue output with the result."
	input RandomFloat(string) : "Generates a random float between the specified bounds. Format = 'lowerbound upperbound', like '22.5 48.721'. Fires the OutValue output with the result."
	
	input LerpTo(float) : "Lerps this counter's value to the specified value based on the lerp percent."
	input SetLerpPercent(float) : "Sets the lerp percent."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = logic_lineto : 
	"An entity that calculates and outputs a vector from one entity to another." 
[
	source(target_destination) : "Start entity" : : "Name of the entity the line should start from."
	target(target_destination) : "End entity" : : "Name of the entity that line should end at."
	
	// Outputs
	output Line(vector) : "Fired when the vector, from the start entity to the end entity, changes. Passes along the vector as a parameter."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = logic_navigation : 
	"An entity that is used to set navigation properties on other entities. Useful to make NPCs ignore physics props in their way that they can easily push." 
[
	target(target_destination) : "Navigation Entity" : : "Name of the entity to set navigation properties on."
	spawnflags(flags) =
	[
		1 : "[1] Start On" : 1
	]
	navprop(choices) : "Nav Property" : "Ignore" =
	[
		"Ignore" : "NPCs Ignore this when navigating (they'll bump into it)"
	]
	
	// Inputs
	input TurnOn(void) : "Turn on. The Navigation Entity will have its navigation properties set."
	input TurnOff(void) : "Turn off. The Navigation Entity will have its navigation properties returned to the default settings."
	input Toggle(void) : "Toggle on/off."
]

@PointClass base(Targetname) iconsprite("editor/logic_autosave.vmt") = logic_autosave :
	"An entity that is used to force an autosave." +
	"Can be used multiple times."
[
	NewLevelUnit(choices) : "Force New Level Unit" : 0 : "If set, the save will discard any savedata from previous levels, for the purpose of keeping savegame filesizes down. Can only be safely used if there is no way for the player to return to previous levels." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	MinimumHitPoints(integer): "Minimum Hit Points" : 0 : "Don't save dangerous when player has less than this many hitpoints."
	MinHitPointsToCommit(integer) : "Minimum Hit Points to Commit" : 0 : "Minimum hitpoints required to commit to save. The save will be made if you have at least Minimum Hit Points, but when the autosave timer expires, the autosave is only kept if you have at least Min Hitpoints to Commit."

	// Inputs
	input Save(void) : "Force an autosave."
	input SaveDangerous(float) : "Force an autosave as autosavedangerous.sav. If the player is alive after the passed number of seconds it replaces the standard auto save."
	input SetMinHitpointsThreshold(integer) : "Set MinimumHitPoints to this."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = logic_active_autosave :
	"An entity that is used to look for opportunities to autosave."
[
	MinimumHitPoints(integer): "Initiation Hit Points" : 30 : "Start looking for an opportunity to save if player drops below this hitpoint level."
	TriggerHitPoints(integer): "Trigger Hit Points" : 75 : "If started looking for an opportunity, save when hitpoints reach this level."
	TimeToTrigget(float): "Time to trigger" : 0 : "If > 0, how long to try and get a save off before giving up"
	DangerousTime(float): "Dangerous time" : 10 : "If 0, just autosave. Otherwise, do an autosavedangerous with this time threshold"
	
	// Inputs
	input Enable(void) : "Enable the entity"
	input Disable(void) : "Enable the entity"
]

@PointClass base(Targetname) iconsprite("editor/logic_playmovie.vmt") = logic_playmovie : "Plays a movie and allows for various playback options"
[
	MovieFilename(string) : "Movie to play" : "" : "Filename of the movie to play"
	allowskip(choices) : "Allow User to Skip" : 0 : "Whether or not the user may skip the video with common keys" =
	[
		0 : "No"
		1 : "Yes"
	]
	loopvideo(choices) : "Loop Video" : 0 : "If set to true, the movie will loop forever" =
	[
		0 : "No"
		1 : "Yes"
	]
	mute(choices) : "Mute Video" : 0 : "If set to true, the movie will not produce any sound" =
	[
		0 : "No"
		1 : "Yes"
	]

	input PlayMovie(void) : "Play the movie."
	input StopMovie(void) : "Stop the movie if it is currently playing."

	// Outputs
	output OnPlaybackFinished(void) : "Fired when the movie has completed playing back, was skipped by the user, or was stopped with StopMovie."
]


@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = point_template : 
	"Turns an entity, or set of entities, into a single template that can be instanced anywhere, and multiple times. "+
	"If there are interdependencies (entity I/O, hierarchy, or other name references) between the entities "+
	"in the template, the entities in the template will have their names changed and the interdependencies will "+
	"be reconnected to the changes names. The name change format is as follows: '<original name>&0000', where the 0000 "+
	"will be replaced with the current global template instance, so wildcard searches for '<original name>*' will still find them.\n"+
	"If you don't want the name fixup to happen, because you're only spawning the template once, or you want inputs to "+
	"trigger all instances of the template, check the 'Preserve entity names' spawnflag. \n"+
	"To spawn the template in other places, use an env_entity_maker."
[
	spawnflags(flags) =
	[
		1 : "[1] Don't remove template entities" : 0
		2 : "[2] Preserve entity names (Don't do name fixup)" : 1
	]

	FixupMode(choices) : "Expanded name fixup" : 0 : "Allows name fixup to target *all* instances of template names in keyvalues and I/O, including output parameters. Requires name fixup to be enabled (''Preserve entity names'' spawnflag disabled)." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	Template01(target_destination) : "Template 1"
	Template02(target_destination) : "Template 2"
	Template03(target_destination) : "Template 3"
	Template04(target_destination) : "Template 4"
	Template05(target_destination) : "Template 5"
	Template06(target_destination) : "Template 6"
	Template07(target_destination) : "Template 7"
	Template08(target_destination) : "Template 8"
	Template09(target_destination) : "Template 9"
	Template10(target_destination) : "Template 10"
	Template11(target_destination) : "Template 11"
	Template12(target_destination) : "Template 12"
	Template13(target_destination) : "Template 13"
	Template14(target_destination) : "Template 14"
	Template15(target_destination) : "Template 15"
	Template16(target_destination) : "Template 16"

	// Inputs
	input ForceSpawn(void) : "Spawns an instance of the template at the original position."
	input ForceSpawnRandomTemplate(void) : "Spawns one of this entity's templates at its original position."

	// Outputs
	output OnEntitySpawned(void) : "Fired after spawning an instance of this template."
	output OutSpawnedEntity(ehandle) : "Fired for each entity spawned by this template, passing said entity as the parameter and activator."
]

@PointClass base(Targetname,Parentname,Angles) = env_entity_maker : 
	"Spawns the specified entity template at its origin. If set to auto-spawn, it will spawn the template whenever there's room and the player "+
	"is looking elsewhere." 
[
	spawnflags(Flags) =
	[
		1 : "[1] Enable AutoSpawn (will spawn whenever there's room)" : 0
		2 : "[2] AutoSpawn: Wait for entity destruction" : 0
		4 : "[4] AutoSpawn: Even if the player is looking" : 0
		8 : "[8] ForceSpawn: Only if there's room" : 0
	  	16 : "[16] ForceSpawn: Only if the player isn't looking" : 0
	]

	EntityTemplate(target_destination) : "Point_template To Spawn" : "" : "Name of the point_template to spawn here."

	PostSpawnSpeed(float) : "PostSpawn Movement Speed" : "0" : "If specified, all the entities created in the template will move this fast in the specified PostSpawn Movement Direction."
	PostSpawnDirection(angle) : "PostSpawn Movement Direction" : "0 0 0" : "If a PostSpawn Movement Speed is specified, all the entities created in the template will move in this direction."
	PostSpawnDirectionVariance(float) : "PostSpawn Direction Variance" : "0.15" : "This variance is applied to the PostSpawn Movement Direction for each spawned entity in the template. Use it to apply some randomness to the directions."
	PostSpawnInheritAngles(choices) : "PostSpawn Inherit Angles" : 0 : "If in hierarchy, is spawn direction in world space, or object local space of parent" =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input ForceSpawn(void)				: "Spawn an instance of the template at this origin and angle."
	input ForceSpawnAtEntityOrigin(target_destination) : "Spawns an instance of the template that has the same origin and angles as the specified entity."
	input ForceSpawnAtEntityCenter(target_destination) : "Spawns an instance of the template at the specified entity's world space center and angles."
	input ForceSpawnAtPosition(vector) : "Spawn an instance of the template at the specified position (has env_entity_maker's angles)"

	// Outputs
	output OnEntitySpawned(void) : "Fired when an instance of the entity template has been spawned."
	output OnEntityFailedSpawn(void) : "Fired when a ForceSpawn input failed to spawn the template, either due to lack of space or being in player's view, depending on the spawnflags."
	output OutSpawnedEntity(ehandle) : "Fired for each entity spawned by this template, passing said entity as the parameter and activator."
]

// ===========================================
// Mapbase logic entities start here
// ===========================================

@PointClass base(Targetname) iconsprite("editor/logic_skill.vmt") = logic_skill :
	"Fires various inputs and outputs related to difficulty levels. " +
	"You can use this entity to figure out what difficulty the player is using."
[	
	ListenForSkillChange(choices) : "Listen for skill changes?" : 1 : "If enabled, this entity will fire the 'OnSkillChanged' output every time the difficulty is changed. This can also be toggled during the game with inputs." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	// Inputs
	input Test(void) : "Test the skill level and fire an input based on the returning value."
	input StartListening(void) : "Starts listening for difficulty level changes."
	input StopListening(void) : "Stops listening for difficulty level changes."
	
	// Outputs
	output OnSkillChanged(void) : "Fired when the difficulty is changed." 
	output OnEasy(void) : "Fired when the tested difficulty is on Easy." 
	output OnNormal(void) : "Fired when the tested difficulty is on Normal." 
	output OnHard(void) : "Fired when the tested difficulty is on Hard." 
]

@PointClass base(Targetname) iconsprite("editor/logic_console.vmt") = logic_console :
	"Sends messages to the console. Not to be confused with point_clientcommand or point_servercommand."
[
	// Keys
	SetDevLvl(integer) : "Developer Level" : 1 : "What level developer messages should appear at."
	SetMsgColor(color255) : "Message Color" : "210 250 255 255" : "The color of standard messages."
	SetWarningColor(color255) : "Warning Color" : "255 210 210 255" : "The color of warning messages."
	
	SetNewLineNotAuto(choices) : "Don't automatically append \n?" : 0 : "Prevents this logic_console from automatically appending a new line each time it prints." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	// Inputs
	input SendMsg(string) : "Sends a message to the console."
	input SendWarning(string) : "Sends a message to the console in red text."
	input SendDevMsg(string) : "Sends a message to the console that can only be viewed in developer mode."
	input SendDevWarning(string) : "Sends a red-colored message to the console that can only be viewed in developer mode."
	input SetDevLvl(integer) : "Sets the level developer messages should appear at."
	input SetMsgColor(color255) : "Sets the color of standard messages."
	input SetWarningColor(color255) : "Sets the color of warning messages."
	input SetNewLineNotAuto(bool) : "Enables or disables this logic_console's ability to append \n to each message."
	input NewLine(void) : "Manually sends \n."
	input DevNewLine(void) : "Manually sends \n in the specified developer level."
	input ClearConsole(void) : "Clears the console of all output."
	
	// No way, you wacko!
	//input SendError(string) : "Crashes the player's game and gives the parameter as an error message. Please handle with care."
]

@PointClass base(Targetname) iconsprite("editor/logic_convar.vmt") = logic_convar :
	"A powerful entity that can read the specified ConVar's value. " +
	"It functions similarly to a logic_branch, except you could also output the value directly. " +
	"Due to theoretical abuse, players have the option to disable logic_ConVar usage on a map. " +	
	"Use the 'OnDenied' output to prevent any issues from players who have disabled logic_ConVar."
[
	// Keys
	SetConVar(string) : "ConVar" : : "The ConVar to read. Can be serverside or clientside(?)"
	SetTestValue(string) : "Compare value" : : "The value to compare with the ConVar's value during comparisons. This keyvalue supports matchers (<, >, !=, etc.)."
	
	// Inputs
	input SetConVar(string) : "Sets the ConVar whose variable will be retrieved."
	input SetTestValue(string) : "Sets the value that will be compared with the ConVar variable during comparisons."
	input GetValue(void) : "Retrieves the ConVar's value, firing OutValue with its value."
	input Test(void) : "Compares the ConVar's value with the compare value."
	
	// Outputs
	output OnTrue(void) : "Fired when a comparison is true."
	output OnFalse(void) : "Fired when a comparison is false."
	output OutValue(string) : "Fired with the GetValue input. Passes the ConVar's current value."
	output OnDenied(void) : "Fires when the ConVar is requested and logic_convar is not allowed by the server."
]

@PointClass base(Targetname) iconsprite("editor/logic_format.vmt") = logic_format :
	"Formats a line of text akin to C# String.Format.\n" +
	"As curly brackets cannot be used in the help window, please see Mapbase documentation for clear instructions."
	//"For example, take the following values:\n\n" +
	//"Input Value: 'A  {0} there and a \{1\} {1} there\n" +
	//"Parameter 0: 'poot'\n" +
	//"Parameter 1: 'doot'\n" +
	//"\n" +
	//"The 'GetFormattedString' input will create the following text:\n\n" +
	//"'A poot poot there and a doot doot there'\n\n" +
	//"This will be sent out via the OutFormattedValue output."
[
	// Keys
	SetInputValue(string) : "Input Value" : : "The input value. Should contain {0}, {1}, etc, which will be replaced by the parameters and then output as OutFormattedValue."
	SetParameter0(string) : "Parameter 0" : : "Will replace all instances of {0} in the input value."
	SetParameter1(string) : "Parameter 1" : : "Will replace all instances of {1} in the input value."
	SetParameter2(string) : "Parameter 2" : : "Will replace all instances of {2} in the input value."
	SetParameter3(string) : "Parameter 3" : : "Will replace all instances of {3} in the input value."
	SetParameter4(string) : "Parameter 4" : : "Will replace all instances of {4} in the input value."
	SetParameter5(string) : "Parameter 5" : : "Will replace all instances of {5} in the input value."
	SetParameter6(string) : "Parameter 6" : : "Will replace all instances of {6} in the input value."
	SetParameter7(string) : "Parameter 7" : : "Will replace all instances of {7} in the input value."
	SetBackupParameter(string) : "Backup Parameter" : : "If an invalid parameter is used (e.g. null parameter or asks for a parameter beyond {7}), then this will be used instead. Otherwise just uses '<null>'."
	
	// Inputs
	input GetFormattedValue(void) : "Fires OutFormattedValue, which passes the formatted input value."
	input SetInputValue(string) : "Sets the input value. Should contain {0}, {1}, etc. enclosed by curly brackets, which will be replaced by the parameters and then output as OutFormattedValue."
	input SetParameter0(string) : "Sets the text that will replace all instances of {0}."
	input SetParameter1(string) : "Sets the text that will replace all instances of {1}."
	input SetParameter2(string) : "Sets the text that will replace all instances of {2}."
	input SetParameter3(string) : "Sets the text that will replace all instances of {3}."
	input SetParameter4(string) : "Sets the text that will replace all instances of {4}."
	input SetParameter5(string) : "Sets the text that will replace all instances of {5}."
	input SetParameter6(string) : "Sets the text that will replace all instances of {6}."
	input SetParameter7(string) : "Sets the text that will replace all instances of {7}."
	input SetBackupParameter(string) : "Sets the text that will replace all invalid parameters."
	
	// Outputs
	output OutFormattedValue(string) : "Fired when the formatted value is requested. Outputs the formatted value."
]

@PointClass base(Targetname) iconsprite("editor/logic_keyfield.vmt") = logic_keyfield :
	"A logic entity that could read an entity's keyfields. " +
	"Use the target and key name options if you want to store a specific target and/or keyvalue. " +
	"Use the 'Test' input to look for the key within the target's datadesc. " +
	"The 'OutValue' output will fire with the keyfield's value if it is found." +
	"\n\nPlease note that some keyvalues do not work with this entity. (most do though, so don't worry about it)"
[
	// Keys
	target(target_destination) : "Target Entity" : : "The entity with the key to measure."
	keyname(string) : "Key Name" : : "The name of the key to measure."
	
	// Inputs
	input Test(void) : "Gets the stored key's value from stored target."
	input TestKey(string) : "Tests the specified key against the target instead of using the stored key. Does not change the stored key."
	input TestTarget(target_destination) : "Tests the specified target against the key instead of using the stored target. Does not change the stored target."
	input SetKey(string) : "Sets the key to measure."
	input SetValue(string) : "Sets the stored target's stored key value to the specified string."
	input SetTarget(target_destination) : "Sets the target entity."
	
	// Outputs
	output OutValue(string) : "Fires when a keyfield is found. Passes its value."
	output OnFailed(void) : "Fires when this entity fails to find the specified keyfield."
]

@PointClass base(Targetname) iconsprite("editor/logic_datadesc_accessor.vmt") = logic_datadesc_accessor :
	"A logic entity that could read or write any field in an entity's data description, keyvalue or not, based on its internal name. It otherwise functions identically to logic_keyfield.\n\n" +
	"You'd better know what you're doing."
[
	// Keys
	target(target_destination) : "Target Entity" : : "The entity whose data description will be measured."
	keyname(string) : "Element Name" : : "The internal name (e.g. m_iName) of the field to measure. Use the ''ent_info_datatable'' command followed by an entity's class name to see all of their fields."
	
	// Inputs
	input Test(void) : "Gets the stored field's value from stored target."
	input TestKey(string) : "Tests the specified field against the target instead of using the stored field. Does not change the stored field."
	input TestTarget(target_destination) : "Tests the specified target against the field instead of using the stored target. Does not change the stored target."
	input SetKey(string) : "Sets the field to measure."
	input SetValue(string) : "Sets the stored target's stored field to the specified string."
	input SetTarget(target_destination) : "Sets the target entity."
	
	// Outputs
	output OutValue(string) : "Fires when a field is found. Passes its value."
	output OnFailed(void) : "Fires when this entity fails to find the specified field."
]

@PointClass base(Targetname) iconsprite("editor/math_clamp.vmt") = math_clamp :
	"Clamps a value between two values. Supports integers, floats, and vectors."
[
	// Keys
	SetMax(string) : "Max" : : "The maximum value. Can be an integer, a float, or a vector."
	SetMin(string) : "Min" : : "The minimum value. Can be an integer, a float, or a vector."
	
	// Inputs
	input ClampValue(string) : "Clamps the specified value. Can be an integer, a float, or a vector."
	input SetMax(string) : "Sets the max value. Can be an integer, a float, or a vector."
	input SetMin(string) : "Sets the max value. Can be an integer, a float, or a vector."
	
	// Outputs
	output OutValue(string) : "Outputs the clamped value."
	output OnBeforeMin(string) : "Fires when a clamped value was before the minimum value. Outputs the clamped value."
	output OnBeyondMax(string) : "Fires when a clamped value was beyond the maximum value. Outputs the clamped value."
]

@PointClass base(Targetname, EnableDisable) iconsprite("editor/math_bits.vmt") = math_bits :
	"A math_counter variant that specializes in bitwise operations."
[
	// Keys
	startvalue(integer) : "Initial Value" : 0 : "The bits this entity should start with."

	// Inputs
	input Add(integer) : "Adds bit(s) to this entity's value and fires the OutValue output with the result."
	input Subtract(integer): "Subtracts bit(s) to this entity's value and fires the OutValue output with the result."
	input ShiftLeft(integer): "Shifts this entity's value to the left by the specified number and fires the OutValue output with the result."
	input ShiftRight(integer): "Shifts this entity's value to the right by the specified number and fires the OutValue output with the result."
	input SetValue(integer): "Changes this entity's value and fires the OutValue output with the result."
	input SetValueNoFire(integer): "Changes this entity's value without firing any outputs."
	input GetValue(void): "Causes this entity to fire its OnGetValue output with its current bits. Used for polling the current bits when you don't want constant updates from the OutValue output."
	input ContainsBits(integer): "Tests whether this entity's current value contains at least one of the specified bit(s)."
	input ContainsAllBits(integer): "Tests whether this entity's current value contains all of the specified bit(s)."

	// Outputs
	output OutValue(integer) : "Fired when the value changes."
	output OnGetValue(integer) : "Fired in response to the GetValue input. Used for polling the current bits when you don't want constant updates from the OutValue output."
	output OnTrue(void) : "Fired by ContainsBits when the current value contains the specified bit." 
	output OnFalse(void) : "Fired by ContainsBits when the current value does not contain the specified bit." 
]

@PointClass base(Targetname, EnableDisable) iconsprite("editor/math_vector.vmt") = math_vector :
	"A math_counter variant that specializes in vector operations."
[
	// Keys
	startvalue(vector) : "Initial Value" : "0 0 0" : "The vector this entity should start with."
	
	spawnflags(flags) =
	[
		1 : "[1] Disable X" : 0
		2 : "[2] Disable Y" : 0
		4 : "[4] Disable Z" : 0
	]

	// Inputs
	input Add(vector) : "Adds a vector to this entity's current value and fires the OutValue output with the result."
	input Divide(vector): "Divides a vector from this entity's current value and fire the OutValue output with the result."
	input Multiply(vector): "Multiplies a vector from this entity's current value and fires the OutValue output with the result."
	input SetValue(vector): "Sets this entity's current vector to a new value and fires the OutValue output with the result."
	input SetValueNoFire(vector): "Sets this entity's current vector to a new value without firing any outputs."
	input Subtract(vector): "Subtracts a vector from this entity's current value and fires the OutValue output with the result."
	input GetValue(void): "Causes this entity to fire its OnGetValue output with its current vector. Used for polling the counter when you don't want constant updates from the OutValue output."
	
	input PointAtLocation(vector): "Creates an angle pointing from the entity's current vector to the specified point and fires the OutValue output with the result."
	input PointAtEntity(target_destination): "Creates an angle pointing from the entity's current vector to the specified entity and fires the OutValue output with the result."
	
	input Normalize(void): "Normalizes this entity's vector and fires the OutValue output with the result."
	input NormalizeAngles(void): "Normalizes this entity's vector as angles and fires the OutValue output with the result."
	input VectorAngles(void): "Converts this entity's vector to an angle, assuming the current vector is a direction vector. Fires the OutValue output with the result."
	input AngleVectorForward(void): "Converts this entity's vector angles to a vector in the forward direction. Fires the OutValue output with the result."
	input AngleVectorRight(void): "Converts this entity's vector angles to a vector in the right direction. Fires the OutValue output with the result."
	input AngleVectorUp(void): "Converts this entity's vector angles to a vector in the up direction. Fires the OutValue output with the result."
	
	input SetX(float) : "Sets this entity's X coordinate."
	input SetY(float) : "Sets this entity's Y coordinate."
	input SetZ(float) : "Sets this entity's Z coordinate."
	input GetX(void) : "Gets this entity's X coordinate."
	input GetY(void) : "Gets this entity's Y coordinate."
	input GetZ(void) : "Gets this entity's Z coordinate."
	input AddX(float) : "Adds to this entity's X coordinate."
	input AddY(float) : "Adds to this entity's Y coordinate."
	input AddZ(float) : "Adds to this entity's Z coordinate."
	input SubtractX(float) : "Subtracts from this entity's X coordinate."
	input SubtractY(float) : "Subtracts from this entity's Y coordinate."
	input SubtractZ(float) : "Subtracts from this entity's Z coordinate."

	// Outputs
	output OutValue(vector) : "Fired when the value changes."
	output OutX(float) : "Fired when the value changes, passing the resulting X coordinate."
	output OutY(float) : "Fired when the value changes, passing the resulting Y coordinate."
	output OutZ(float) : "Fired when the value changes, passing the resulting Z coordinate."
	
	output OnGetValue(vector) : "Fired in response to the GetValue input. Used for polling this entity's current value when you don't want constant updates from the OutValue output."
	output OnGetX(float) : "Fired in response to the GetX input."
	output OnGetY(float) : "Fired in response to the GetY input."
	output OnGetZ(float) : "Fired in response to the GetZ input."
]

@PointClass base(Targetname, EnableDisable) iconsprite("editor/math_mod.vmt") = math_mod :
	"A lightweight entity that performs simple calculations on the fly without needing a complicated I/O chain. "+
	"This is useful for values that are outputted on a per-frame basis and might not work with a math_counter chain."
[
	// Keys
	startvalue(string) : "Mod Value" : "0" : "The value that is applied to input values."
	
	SetOperator(choices) : "Operator" : 43 : "What calculation to perform with the mod value. (input value _ mod value)" = 
	[
		43 : "Addition"
		45 : "Subtraction"
		42 : "Multiplication"
		47 : "Division"
	]

	// Inputs
	input SetMod(string) : "Sets the mod value."
	input ModInt(integer) : "Applies modification to the specified integer."
	input ModFloat(float) : "Applies modification to the specified float."
	input ModVector(vector) : "Applies modification to the specified vector."
	input SetOperator(string): "Sets the operator. Use +, -, *, or / to choose addition, subtraction, multiplication, or division respectively."

	// Outputs
	output OutInt(integer) : "Outputs the modified integer."
	output OutFloat(float) : "Outputs the modified float."
	output OutVector(vector) : "Outputs the modified vector."
]

@PointClass base(Targetname, EnableDisable) size(-8 -8 -8, 8 8 8) = logic_modelinfo :
	"Gets and outputs some model information from an entity."
[
	target(target_destination) : "Target" : "" : "The entity whose model will be evaluated."
	PoseParameterName(string) : "Pose Parameter Name" : "" : "(Optional) The pose parameter to use for pose parameter-related I/O."

	// Inputs
	input SetTarget(target_destination) : "Sets this entity's target."
	input GetNumSkins(void) : "Gets the number of skins on the target entity."
	input LookupSequence(string) : "Looks up the specified sequence on the target entity."
	input LookupActivity(string) : "Looks up the specified activity on the target entity. Uses the sequence outputs and outputs the first sequence with the given activity."
	
	input SetPoseParameterName(string) : "Sets the pose parameter to target."
	input SetPoseParameterValue(float) : "Sets the target pose parameter's current value."
	input GetPoseParameter(void) : "Gets the current value of the target pose parameter and fires OutPoseParameterValue with it."

	// Outputs
	output OutNumSkins(integer) : "Outputs number of skins."
	output OnHasSequence(integer) : "Fires when the target has the sequence requested. Outputs the sequence's index."
	output OnLacksSequence(void) : "Fires when the target does not have the sequence requested."
	
	output OutPoseParameterValue(float) : "Fires when the pose parameter value is requested, outputting its current value."
]

@PointClass base(Targetname, EnableDisable) size(-8 -8 -8, 8 8 8) = game_globalvars :
	"Outputs a few global variables when requested."
[
	// Inputs
	input GetCurtime(void) : "Gets curtime."
	input GetFrameCount(void) : "Gets frame count."
	input GetFrametime(void) : "Gets frame time."
	input GetTickCount(void) : "Gets tick count."
	input GetIntervalPerTick(void) : "Gets interval per tick."

	// Outputs
	output OutCurtime(float) : "Outputs curtime."
	output OutFrameCount(integer) : "Outputs frame count."
	output OutFrametime(float) : "Outputs frame time."
	output OutTickCount(integer) : "Outputs tick count."
	output OutIntervalPerTick(integer) : "Outputs interval per tick."
]

@PointClass base(Targetname) iconsprite("editor/logic_entity_position.vmt") = logic_entity_position :
	"Outputs an entity's position. Prediction operations can be performed as well."
[
	target(target_destination) : "Target" : "" : "Who's position should be measured? Use the SetTarget input to change mid-game."
	PositionType(choices) : "Position Type" : 0 : "What position should be measured." =
	[
		0 : "Origin (default)"
		1 : "Local Origin"
		2 : "Worldspace Center"
		3 : "Eyes"
		4 : "Ears"
		5 : "Attachment (use parameter keyvalue)"
	]
	PositionParameter(string) : "Position Type Parameter" : "" : "If using an attachment's position, enter the name of the attachment here."

	// Inputs
	input GetPosition(void) : "Gets the target's position."
	input SetPosition(vector) : "Sets the target's position. Using the default 'Origin' will set absolute origin while using 'Local Origin' will set local origin."
	input PredictPosition(float) : "Predicts what position the target will be at in the specified number of seconds."

	// Outputs
	output OutPosition(vector) : "Outputs the position."
	output OutAngles(vector) : "Outputs the angles."
]

@PointClass base(Targetname) iconsprite("editor/logic_context_accessor.vmt") = logic_context_accessor :
	"A logic entity that could read an entity's response contexts. " +
	"Use the target and context name keyvalues if you want to store a specific target and/or context. " +
	"Use the 'Test' input to look for the context on the target. " +
	"The 'OutValue' output will fire with the context's value if it is found."
[
	// Keys
	target(target_destination) : "Target Entity" : : "The entity with the context to measure."
	context(string) : "Context Name" : : "The name of the context to measure."
	
	// Inputs
	input Test(void) : "Gets the stored context's value from stored target."
	input TestContext(string) : "Tests the specified context against the target instead of using the stored context. Does not change the stored context."
	input TestTarget(target_destination) : "Tests the specified target against the context instead of using the stored target. Does not change the stored target."
	input SetContext(string) : "Sets the context to measure."
	input SetValue(string) : "Sets the stored target's stored context value to the specified string."
	input SetTarget(target_destination) : "Sets the target entity."
	
	// Outputs
	output OutValue(string) : "Fires when a context is found. Passes its value."
	output OnFailed(void) : "Fires when this entity fails to find the specified context."
]

@PointClass base(Targetname, EnableDisable) iconsprite("editor/math_lightpattern.vmt") = math_lightpattern :
	"A logic entity that attempts to replicate light patterns that can be used on named lights.\n\n" +
	"WARNING: This is currently out of sync with default light patterns. TODO: Fix that!"
[
	// Keys
	style(Choices) : "Appearance" : "" : "Which preset pattern to use." =
	[
		"" : "None"
		0 : "Normal"
		10: "Fluorescent flicker"
		2 : "Slow, strong pulse"
		11: "Slow pulse, noblack"
		5 : "Gentle pulse"
		1 : "Flicker A"
		6 : "Flicker B"
		3 : "Candle A"
		7 : "Candle B"
		8 : "Candle C"
		4 : "Fast strobe"
		9 : "Slow strobe"
	]
	
	pattern(string) : "Custom Appearance" : : "A custom pattern to use. a = fully dark, z = fully bright. This should always contain lowercase letters for light patterns. Uppercase letters or other types of characters won't work with actual light patterns. (although they shouldn't break the whole entity either)"
	
	PatternSpeed(float) : "Pattern Speed" : "0.1" : "The speed of the pattern."
	
	// Inputs
	input SetStyle(integer) : "Sets the pattern from the style presets."
	input SetPattern(string) : "Sets the pattern directly."
	input Enable(void) : "Enables this entity."
	input Disable(void) : "Disables this entity."
	input Toggle(void) : "Toggles this entity."
	
	// Outputs
	output OutValue(float) : "Outputs with a brightness equivalent to the current letter."
	output OutLetter(string) : "Outputs with the current letter itself."
	output OnLightOn(void) : "Fires when the current letter is equivalnt to 'on' (greater than a)."
	output OnLightOff(void) : "Fires when the current letter is equivalent to 'off' (equal to a)."
]

@PointClass base(Targetname) iconsprite("editor/logic_sequence.vmt") = logic_sequence :
	"Coordinates a sequence out of up to 16 preset values. If the input value matches " +
	"the sequence's current case value, an output is fired and (by default) the sequence increments to the next case.\n\n" +
	"This is intended for things like passwords in keypads, which usually demand a specific combination of numbers."
[
	InitialCase(integer) : "Initial Case" : 1 : "Which case to start on, meaning inputs will initially compare with this case. Uses the case's index. (e.g. 4 for Case 04)"
	
	StartDisabled(choices) : "Start Disabled" : 0 : "If this entity is disabled, it will not accept any case tests. It will still accept other inputs, like SetSequenceIndex." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	Case01(string) : "Case 01" : : "If the sequence's current case is 01, fires OnCasePass or OnCaseFail based on whether this value matches the InValue parameter. This keyvalue supports matchers (<, >, !=, etc.)."
	Case02(string) : "Case 02" : : "If the sequence's current case is 02, fires OnCasePass or OnCaseFail based on whether this value matches the InValue parameter. This keyvalue supports matchers (<, >, !=, etc.)."
	Case03(string) : "Case 03" : : "If the sequence's current case is 03, fires OnCasePass or OnCaseFail based on whether this value matches the InValue parameter. This keyvalue supports matchers (<, >, !=, etc.)."
	Case04(string) : "Case 04" : : "If the sequence's current case is 04, fires OnCasePass or OnCaseFail based on whether this value matches the InValue parameter. This keyvalue supports matchers (<, >, !=, etc.)."
	Case05(string) : "Case 05" : : "If the sequence's current case is 05, fires OnCasePass or OnCaseFail based on whether this value matches the InValue parameter. This keyvalue supports matchers (<, >, !=, etc.)."
	Case06(string) : "Case 06" : : "If the sequence's current case is 06, fires OnCasePass or OnCaseFail based on whether this value matches the InValue parameter. This keyvalue supports matchers (<, >, !=, etc.)."
	Case07(string) : "Case 07" : : "If the sequence's current case is 07, fires OnCasePass or OnCaseFail based on whether this value matches the InValue parameter. This keyvalue supports matchers (<, >, !=, etc.)."
	Case08(string) : "Case 08" : : "If the sequence's current case is 08, fires OnCasePass or OnCaseFail based on whether this value matches the InValue parameter. This keyvalue supports matchers (<, >, !=, etc.)."
	Case09(string) : "Case 09" : : "If the sequence's current case is 09, fires OnCasePass or OnCaseFail based on whether this value matches the InValue parameter. This keyvalue supports matchers (<, >, !=, etc.)."
	Case10(string) : "Case 10" : : "If the sequence's current case is 10, fires OnCasePass or OnCaseFail based on whether this value matches the InValue parameter. This keyvalue supports matchers (<, >, !=, etc.)."
	Case11(string) : "Case 11" : : "If the sequence's current case is 11, fires OnCasePass or OnCaseFail based on whether this value matches the InValue parameter. This keyvalue supports matchers (<, >, !=, etc.)."
	Case12(string) : "Case 12" : : "If the sequence's current case is 12, fires OnCasePass or OnCaseFail based on whether this value matches the InValue parameter. This keyvalue supports matchers (<, >, !=, etc.)."
	Case13(string) : "Case 13" : : "If the sequence's current case is 13, fires OnCasePass or OnCaseFail based on whether this value matches the InValue parameter. This keyvalue supports matchers (<, >, !=, etc.)."
	Case14(string) : "Case 14" : : "If the sequence's current case is 14, fires OnCasePass or OnCaseFail based on whether this value matches the InValue parameter. This keyvalue supports matchers (<, >, !=, etc.)."
	Case15(string) : "Case 15" : : "If the sequence's current case is 15, fires OnCasePass or OnCaseFail based on whether this value matches the InValue parameter. This keyvalue supports matchers (<, >, !=, etc.)."
	Case16(string) : "Case 16" : : "If the sequence's current case is 16, fires OnCasePass or OnCaseFail based on whether this value matches the InValue parameter. This keyvalue supports matchers (<, >, !=, etc.)."
	
	DontIncrementOnPass(choices) : "Suppress auto increment" : 0 : "Prevents automatically incrementing the sequence each time a case passes." =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input Enable(void) : "Enables this entity."
	input Disable(void) : "Disables this entity."
	input Toggle(void) : "Toggles whether this entity is disabled."
	input InValue(string) : "Tests the input value against the current case."
	input SetCurrentCase(integer) : "Sets the sequence's current case. This will fire OutCurCase."
	input SetCurrentCaseNoFire(integer) : "Sets the sequence's current case without firing OutCurCase."
	input IncrementSequence(integer) : "Increments the current case by the specified number. (1 if blank)"
	input ResetSequence(void) : "Resets the sequence to Case 01."
	
	// Outputs
	output OutCurCase(integer) : "Fires each time the sequence's current case value changes, e.g. when it's incremented by a passing case."
	output OnCasePass(string) : "Fires when a case is matched, passing the input value."
	output OnCaseFail(string) : "Fires when a case fails, passing the input value."
	output OnSequenceComplete(string) : "Fires when the last case is matched and sequence is complete."
]

@PointClass base(Targetname) iconsprite("editor/math_generate.vmt") = math_generate :
	"Continuously generates numbers using various generation modes based on material proxies."
[
	// Keys
	StartDisabled(choices) : "Start Disabled" : 1 =
	[
		0 : "No"
		1 : "Yes"
	]
	
	GenerateType(choices) : "Generation Type" : 1 =
	[
		0 : "Sine Wave (param 1 = time offset, param 2 = sine period)"
		1 : "Linear Ramp (param 1 = rate)"
		2 : "Uniform Noise"
		3 : "Gaussian Noise (param 1 = mean, param 2 = half width)"
		4 : "Exponential (param 1 = scale, param 2 = offset)"
	]
	
	InitialValue(float) : "Initial Value" : 0 : "Starting value for the math_generate."
	SetHitMin(float) : "Minimum Legal Value" : 0 : "Minimum legal value for generation."
	SetHitMax(float) : "Maximum Legal Value" : 1 : "Maximum legal value for generation."
	
	SetParam1(float) : "Parameter 1" : 0 : "Multi-purpose parameter #1 for the generation algorithms to use for their own needs."
	SetParam2(float) : "Parameter 2" : 0 : "Multi-purpose parameter #2 for the generation algorithms to use for their own needs."
	
	// Inputs
	input SetValue(float): "Sets the math_generate to a new value and fires the OutValue output with the result, performing all generation from that value."
	input SetValueNoFire(float): "Sets the math_generate to a new value without firing any outputs."
	input GetValue(void): "Causes the math_generate to fire its OnGetValue output with the current value. Used for polling the value when you don't want constant updates from the OutValue output."
	input SetGenerateType(integer) : "Sets the type of generation this math_generate should perform."
	
	input Enable(void) : "Enables this entity."
	input Disable(void) : "Disables this entity."
	input Toggle(void) : "Toggles whether this entity is disabled."
	
	// Outputs
	output OutValue(string) : "Fires each tick while generation is active, passing the value continuously generated by the math_generate."
	output OnHitMin(void) : "Fired when generation meets the min value. Generation must go back above the min value before the output will fire again."
	output OnHitMax(void) : "Fired when generation meets the max value. Generation must go below the max value before the output will fire again."
	output OnGetValue(float) : "Fired in response to the GetValue input. Used for polling the value when you don't want constant updates from the OutValue output."
	output OnChangedFromMin(void) : "Fired when the current generation value changes from the minimum value."
	output OnChangedFromMax(void) : "Fired when the current generation value changes from the maximum value."
]

//

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = point_ragdollboogie : 
	"An entity that makes ragdolls dance."
[
	spawnflags(flags) =
	[
		65536: "[65536] Electrical" : 1
		131072: "[131072] Narrow arcs (must be electrical)" : 0
	]

	target(target_destination) : "Boogie target(s)" : : "The one(s) that must boogie. prop_ragdolls have no hassle, but NPCs will have to break them elbows and become prop_ragdolls themselves (a.k.a. die) in order to boogie."
	StartTime(float) : "Start time" : "0" : "How long after we've received the 'Activate' input should ragdolls boogie?"
	BoogieLength(float) : "Boogie length" : "5.0" : "How long should the boogie last? Can be a range with a lower bound and a higher bound, e.g. ''2.5,4.0'' (no quotes)"
	Magnitude(float) : "Magnitude" : "150" : "How intense is the boogie?"
	
	ZapColor(color255) : "Zap Color" : "255 255 255" : "The color of each tesla beam on an electrical boogie."

	// Inputs
	input Activate(void) : "Makes the targets dance."
	input Deactivate(void) : "Makes the targets stop dancing, if they're still dancing."
	input SetTarget(target_destination) : "Sets the ragdoll(s) to target."
	input BoogieTarget(target_destination) : "Boogies specific target(s) without using or modifying our target field."
	input SetZapColor(color255) : "Sets the zap color."
]

@BaseClass = DamageTypes
[
	damagetype(choices) : "Damage Type" : 0 : "The type(s) of damage associated with this entity." =
	[
		0 : "[0] GENERIC"
		1 : "[1] CRUSH"
		2 : "[2] BULLET"
		4 : "[4] SLASH"
		8 : "[8] BURN"
		//16 : "[16] FREEZE" // This does not appear to exist.
		16 : "[16] VEHICLE"
		32 : "[32] FALL"
		64 : "[64] BLAST"
		128 : "[128] CLUB"
		256 : "[256] SHOCK"
		512 : "[512] SONIC"
		1024 : "[1024] ENERGYBEAM"
		16384: "[16384] DROWN"
		32768 : "[32768] PARALYSE"
		65536 : "[65536] NERVEGAS"
		131072 : "[131072] POISON"
		262144 : "[262144] RADIATION"
		524288 : "[524288] DROWNRECOVER"
		1048576 : "[1048576] ACID"
		2097152 : "[2097152] SLOWBURN"
		//4194304 : "[4194304] SLOWFREEZE" // This does not appear to exist.
		4194304 : "[4194304] REMOVENORAGDOLL"
		16777216 : "[16777216] PLASMA"
		33554432 : "[33554432] AIRBOAT (gun)"
		67108864 : "[67108864] DISSOLVE"
		134217728 : "[134217728] BLAST_SURFACE"
		268435456 : "[268435456] DIRECT"
		536870912 : "[536870912] BUCKSHOT"
	]
	
	damagepresets(choices) : "Damage Presets" : 0 : "User-friendly 'presets' based on combined damage types. This is accompanied by the damage type and damage or, if they are specified." = 
	[
		0 : "None"
		268435464 : "[268435464] Ignite Damage (BURN + DIRECT)"
		134217792 : "[134217792] All Blast Types (BLAST + BLAST_SURFACE)"
	]
	
	damageor(choices) : "Damage Or" : 0 : "Optional flags that can accompany the damage type." = 
	[
		0 : "None"
		2048 : "[2048] PREVENT_PHYSICS_FORCE (no physics force)"
		4096 : "[4096] NEVERGIB (no gibs)"
		8192 : "[8192] ALWAYSGIB (always gib if possible)"
		4194304 : "[4194304] REMOVENORAGDOLL (no ragdoll on death)"
		134217728 : "[134217728] BLAST_SURFACE (no damage underwater)"
		268435456 : "[268435456] DIRECT (With burn, NPCs treat as being on fire)"
	]
]

// So we can arrange the DamageTypes base class in point_damageinfo
@BaseClass = PointDamageInfoInit
[
	Target(target_destination) : "Target/Victim" : : "The entit(ies) that will take all of this damage. This is optional if you're only using the 'ApplyDamageToEntity' input."
	Inflictor(target_destination) : "Inflictor" : : "The entity that actually supposedly dealt the damage. This isn't supposed to be the attacker as much as it's supposed to be their weapon or a projectile from their weapon."
	Attacker(target_destination) : "Attacker" : : "The entity that the damage is credited to."
	Weapon(target_destination) : "Weapon" : : "The weapon that did the damage. This is usually used when the inflictor would already be used for something else. For example, when the inflictor is a rocket, this would be the RPG."
	
	MaxEnts(integer) : "Maximum Victims" : 1 : "When ApplyDamage is called, how many entities that match the target's description should be victimized? Use 0 for no limit."

	Damage(integer) : "Damage" : 0 : "How much damage to inflict."
	MaxDamage(integer) : "Max Damage" : : "Function not fully understood, likely something related to multidamage"
	DamageBonus(integer) : "Damage Bonus" : : "Function unknown, possibly unused"
]

@PointClass base(Targetname, PointDamageInfoInit, DamageTypes) iconsprite("editor/point_damageinfo.vmt") = point_damageinfo :
	"Applies damage with full control over the variables of CTakeDamageInfo, providing as much precision as possible."
[
	// Keys
	DamageCustom(integer) : "Damage Custom" : : "A special, game-specific identifier mostly used in mods or multiplayer games."
	DamageStats(integer) : "Damage Stats" : : "Function unknown, possibly unused"
	ForceFriendlyFire(choices) : "Force Friendly Fire" : 0 : "Disregards friendly fire safechecks and applies the damage regardless of the attacker's relationship to the victim." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	AmmoType(integer) : "Ammo Type" : : "Uses a specific ammo type by order in the ammo def. (not to be confused with damage type)"
	PlayerPenetrationCount(integer) : "Player Penetration Count" : : "Presumably how many players the inflictor has gone through before reaching the current victim. Appears to be unused in singleplayer games."
	DamagedOtherPlayers(integer) : "Damaged Other Players" : : "Function unknown, possibly unused"
	
	DamageForce(vector) : "Damage Force" : "0 0 0" : "The force to apply when the damage is applied."
	DamagePosition(vector) : "Damage Position" : "0 0 0" : "What position the damage took place."
	ReportedPosition(vector) : "Reported Position" : "0 0 0" : "Function unknown, possibly related to multidamage (buckshot)"
	
	SuppressDeathSound(choices) : "Suppress Death Sound" : 0 : "Attempts to suppress the target entity's death sound." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	// Inputs
	input SetInflictor(target_destination) : "Sets the inflictor."
	input SetAttacker(target_destination) : "Sets the attacker."
	input SetWeapon(target_destination) : "Sets the weapon."
	input SetDamage(integer) : "Sets the damage."
	input SetMaxDamage(integer) : "Sets the max damage."
	input SetDamageBonus(integer) : "Sets the damage bonus."
	input SetDamageType(integer) : "Sets the damage type."
	input SetDamageCustom(integer) : "Sets the damage custom."
	input SetDamageStats(integer) : "Sets the damage stats."
	input SetForceFriendlyFire(bool) : "Sets force friendly fire."
	input SetAmmoType(integer) : "Sets the ammo type."
	input SetPlayerPenetrationCount(integer) : "Sets player penetration count."
	input SetDamagedOtherPlayers(integer) : "Sets damaged other players."
	input SetDamageForce(vector) : "Sets the damage force."
	input SetDamagePosition(vector) : "Sets the damage position."
	input SetReportedPosition(vector) : "Sets the reported position."
	input ApplyDamage(void) : "Applies damage."
	input ApplyDamageToEntity(target_destination) : "Applies damage to a specific entity."
	
	// Outputs
	output OnApplyDamage(void) : "Fires for every entity that takes our damage, using that as the activator."
	output OnApplyDeath(void) : "Fires for every entity that dies from our damage, using that as the activator."
]

@PointClass base(Targetname) iconsprite("editor/point_entity_replace.vmt") = point_entity_replace : 
	"An entity that replaces."
[
	Target(target_destination) : "Entity to be replaced" : : "The entity that should be replaced. This is optional if you're only using the 'ReplaceEntity' input."
	ReplacementEntity(target_destination) : "Replacement Entity" : : "The entity that should serve as the replacement."
	ReplacementType(choices) : "Replacement Type" : 0 : "What IS the replacement entity?" =
	[
		0 : "Specific Entity (teleports directly)"
		1 : "Classname (creates new entity)"
		2 : "Template (target is point_template, uses contents)"
		3 : "Template Relative (same as Template, keeps entities' relative position)"
		4 : "Random Template (target is point_template, uses random template)"
		5 : "Random Template Relative (same as Random Template, keeps entity's relative position)"
	]
	ReplacementLocation(choices) : "Replacement Location" : 0 : "Where should the replacement entit(ies) be teleported to?" =
	[
		0 : "Target Origin"
		1 : "Target Center (WorldSpaceCenter)"
	]
	
	RemoveOriginalEntity(choices) : "Remove original entity" : 1 : "Removes the entity being replaced." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	TakeTargetname(choices) : "Take Targetname" : 0 : "Causes the replacement entity to take the target's name." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	TakeParent(choices) : "Take Parent" : 0 : "Causes the replacement entity to take the target's current parent as well as its children." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	TakeOwner(choices) : "Take Owner" : 0 : "Causes the replacement entity to take the target's owner." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	TakeModelStuff(choices) : "Take Model Stuff" : 0 : "Causes the replacement entity to take the target's model stuff, including render fields and animation data." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	OtherStuff(string) : "Other Fields" : : "Specific variables that should transfer. Uses internal field names (e.g. ''m_bBoolean''), not keyvalues. This is really delicate, so be careful."
	
	TargetIsCaller(choices) : "Fire outputs with original entity as caller" : 0 : "If enabled, OnReplace will fire with the original entity as the caller instead of this." =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input Replace(void) : "Replaces the target entity with the replacement entity."
	input ReplaceEntity(target_destination) : "Replaces the specified entity with the replacement entity."
	input SetTarget(target_destination) : "Sets the entity to be replaced."
	input SetReplacementEntity(target_destination) : "Sets the entity to replace the target."
	
	// Outputs
	output OnReplace(ehandle) : "Fires for each replacement we undergo, passing the replacement entity as the activator and parameter. The caller can be the replaced entity or this entity depending on this entity's settings."
]

// TODO: TASK SUPPORT
@PointClass base(Targetname, EnableDisable) iconsprite("editor/ai_monitor.vmt") = ai_monitor :
	"Monitors NPCs for conditions and schedules. " +
	"You can use this entity to either watch an entity for conditions/schedules or test whether they have them. "+
	"TODO: Task support."
[	
	StartDisabled(choices) : "Start Disabled" : 1 =
	[
		0 : "No"
		1 : "Yes"
	]

	Target(target_destination) : "Target NPC(s)" : : "The NPCs that should be monitored."
	MaxEnts(integer) : "Maximum Targets" : 1 : "How many NPCs we're allowed to monitor. Each one will fire outputs. 0 = no limit."
	SetMonitorInterval(float) : "Monitor Interval" : "0.25" : "The amount of time in between monitor checks. Use 0 to monitor each tick."
	SetCooldownTime(float) : "Cooldown Time" : "1.0" : "Whenever a monitor check succeeds, how long should this entity wait before checking again? Use -1 to disable cooldown."

	CooldownAt(choices) : "Cooldown upon first success" : 0 : "While actively monitoring, engage cooldown as soon as a NPC fulfills any of the evaluators instead of checking the other NPCs and letting them fire outputs as well." =
	[
		0 : "No"
		1 : "Yes"
	]

	ConditionsSimple(choices) : "Condition" : 0 : "Which condition to monitor. Use 'Conditions (advanced)' to use conditions outside of this list or use multiple conditions." =
	[
		0 : "None"
		4 : "No ammo"
		10 : "See enemy"
		13 : "Enemy occluded"
		15 : "Have enemy LOS"
		20 : "Repeated damage"
		28 : "Enemy facing me"
		29 : "Behind enemy"
		31 : "Enemy unreachable"
		51 : "Hear thumper"
	]
	Conditions(string) : "Conditions (advanced)" : : "Allows you to specify exactly which conditions to monitor, either by their actual integer ID or their string name. Separate multiple conditions with colons: 'COND_BEHIND_ENEMY:COND_ENEMY_OCCLUDED:11'"
	
	Schedules(string) : "Schedules (advanced)" : : "Allows you to specify exactly which schedules to monitor, either by their actual integer ID or their string name. Separate multiple schedules with colons: 'SCHED_INVESTIGATE_SOUND:SCHED_COMBAT_FACE:14'"
	TranslateSchedules(choices) : "Translate shcedules" : 0 : "Translates schedules based on each NPC's behavior each time they're checked. This depends on how the NPC remaps that schedule, which may be either their own version of it or something completely different that may not be desirable. The performance impact of this setting is not known." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	HintsSimple(choices) : "Hint Node" : 0 : "Which hint to monitor. Use 'Hints (advanced)' to use conditions outside of this list or use multiple hints." =
	[
		0 : "None"
		100: "Crouch Cover Medium"
		101: "Crouch Cover Low"
		103: "Entrance / Exit Pinch"
		104: "Guard Point"
		105: "Enemy Disadvantage Point"
		900: "Follower: Wait point"
		950: "Player Ally: Push away destination"
		951: "Player Ally: Fear withdrawal destination"
	]
	Hints(string) : "Hint Nodes (advanced)" : : "Allows you to specify exactly which hints to monitor by their integer ID. Separate multiple hints with colons: '100:101:104'"
	
	HintDistance(float) : "Hint Distance" : "32.0" : "The maximum distance a NPC must be from their current hint node before we are allowed to check."
	
	// Inputs
	input SetTarget(target_destination) : "Sets the NPC(s) to be monitored."
	input UpdateActors(void) : "Updates the NPCs."
	input Test(void) : "Tests all of the current NPCs. This entity does not have to be enabled to do this."
	input TestNPC(target_destination) : "Tests the specified NPC. This entity does not have to be enabled to do this."
	
	input GetConditionName(integer) : "Looks up the specified condition ID and outputs its name through OutConditionName."
	input GetScheduleName(integer) : "Looks up the specified schedule ID and outputs its name through OutScheduleName."
	
	input SetCondition(integer) : "Adds a condition."
	input ClearCondition(integer) : "Removes a condition."
	input ClearAllConditions(void) : "Removes all conditions."
	input SetSchedule(integer) : "Sets a schedule."
	input ClearSchedule(integer) : "Removes a schedule."
	input ClearAllSchedules(void) : "Removes all schedules."
	input SetHint(integer) : "Sets a hint."
	input ClearHint(integer) : "Removes a hint."
	input ClearAllHints(void) : "Removes all hints."
	
	// Outputs
	output OutConditionName(string) : "Fires each time a condition is evaluated or a condition name is requested, outputting its actual name from its ID." 
	output OutScheduleName(string) : "Fires each time a schedule is evaluated or a schedule name is requested, outputting its actual name from its ID." 
	output OnNPCHasCondition(integer) : "Fires when a NPC has one of the conditions. Outputs the condition ID and uses the NPC as the activator. This fires for each condition on each NPC." 
	output OnNPCLacksCondition(integer) : "Fires when a NPC does not have one of the conditions. Outputs the condition ID and uses the NPC as the activator. This fires for each condition on each NPC." 
	output OnNPCRunningSchedule(integer) : "Fires when a NPC is running any of the schedules. Outputs the schedule ID and uses the NPC as the activator. This fires for each schedule on each NPC." 
	output OnNPCUsingHint(integer) : "Fires when a NPC is using any of the hints. Outputs the hint ID and uses the NPC as the activator. This fires for each hint on each NPC." 
	output OnNPCNotUsingHint(integer) : "Fires when a NPC is not using any of the hints. Outputs the hint ID and uses the NPC as the activator. This fires for each hint on each NPC." 
]

@PointClass base(Targetname) = point_copy_size : 
	"Copies the size of one entity to another."
[
	Source(target_destination) : "Size source" : : "The entity whose size would be measured and copied from."
	Target(target_destination) : "Resize target" : : "The entity that will receive the copied size."
	
	SetScale(float) : "Scale" : "1" : "Multiplies the source's size by this number. Useful for bullseyes."
	
	// Inputs
	input SetTarget(target_destination) : "Sets the resize target."
	input SetSource(target_destination) : "Sets the size source."
	input CopySize(void) : "Copies the source's size to the target."
	input CopySizeToEntity(target_destination) : "Copies the source's size to the specified entity."
	input CopySizeFromEntity(target_destination) : "Copies the specified entity's size to the target."
	
	// Outputs
	output OnCopy(void) : "Fires each time the size is successfully copied with the target as the activator." 
]

@PointClass base(Targetname, EnableDisable) = ai_weaponmodifier : 
	"Modifies a NPC's weapon shot regulation."
[
	Target(target_destination) : "Target(s)" : : "The NPC(s) that will be modified by default."

	BurstInterval(string) : "Burst Interval" : "0.1:0.25" : "The range for a random amount of time the should pass between each shot in a burst. Format: 'min:max'"
	RestInterval(string) : "Rest Interval" : "0.25:1.25" : "The range for a random amount of time the should pass between bursts. Format: 'min:max'"
	BurstShotCountRange(string) : "Burst Shot Count Range" : "2:5" : "The range for a random amount of shots that should be fired in a bursts. Format: 'min:max'"
	//BurstShotsRemaining(string) : "Burst Shots Remaining" : "2" : "How many shots are left in the current burst."
	
	// Inputs
	input EnableOnNPC(target_destination) : "Applies weapon modification to a specific NPC."
	input DisableOnNPC(target_destination) : "Stops applying weapon modification to a specific NPC."
	
	input SetBurstInterval(string) : "Sets the burst interval. Follows the same format as the keyvalue."
	input SetRestInterval(string) : "Sets the rest interval. Follows the same format as the keyvalue."
	input SetBurstShotCountRange(string) : "Sets the burst shot count range. Follows the same format as the keyvalue."
	input SetBurstShotsRemaining(integer) : "Sets how many shots are left in the current burst."
	
	input EnableShooting(void) : "Enables shooting if it was disabled."
	input DisableShooting(void) : "Disables shooting."
	input FireNoEarlierThan(float) : "Causes the NPC to stop firing for this amount of time."
	input Reset(bool) : "Causes the shot regulator to reset. If 1 is passed, the NPC will immediately start firing instead of waiting for the next burst interval."
]

@PointClass base(Targetname) = env_closecaption : 
	"Sends a CC token via the 'Send' input. Unfortunately, this does not allow you to make your own and you can only use existing ones."
[
	flags(choices) : "Flags" : 0 : "Flags." =
	[
		1 : "Warn if missing"
		2 : "From player"
		4 : "Male"
		8 : "Female"
	]
	
	duration(float) : "Duration" : "2.5" : "The duration of the CC."
	
	// Inputs
	input Send(string) : "Sends a CC."
]

@PointClass base(Targetname) iconsprite("editor/logic_externaldata.vmt") = logic_externaldata : 
	"Saves and reads keyvalue data from %mapname%_externaldata.txt. Useful for when you want to read and write data across multiple playthroughs."
[
	Target(string) : "Block" : "!self" : "The key whose subkeys should be read from/written to. Using '!self' just uses this entity's name as the block name."
	
	SaveEachChange(choices) : "Save after each change" : 1 : "Saves each change without having to use the 'Save' input." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	ReloadBeforeEachAction(choices) : "Reload file before each action" : 0 : "Reloads the file before each change this entity makes. This is mostly useful when there is a possibility that the file could change by other means which could be overwritten, like another logic_externaldata somewhere." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	Mapname(string) : "Map Name" : : "logic_externaldata normally uses ''<current map's name>_externaldata.txt'', but you could override the map name here to create/access external data intended for other maps. You could also just use this to write to additional external data files whether they're intended for another map or not."
	
	// Inputs
	input WriteKeyValue(string) : "Writes the specified keyvalue. If the keyvalue already exists, it will be overwritten. If not, it will be created. Format is '<key> <value>', like AddOutput. (Spaces after the first will still be incorporated into the value)"
	input RemoveKeyValue(string) : "Removes the specified key."
	input ReadKey(string) : "Reads the specified key, firing OutValue with its value."
	input SetBlock(string) : "Sets the block of keyvalues the logic_externaldata reads from. Using !activator or !caller uses their respective entity names."
	input Save(void) : "Saves to %mapname%_externaldata.txt."
	input Reload(void) : "Reloads %mapname%_externaldata.txt."
	
	// Outputs
	output OutValue(string) : "Fires each time a key is read from. Passes the value." 
]

@PointClass base(Targetname, Parentname, Angles) iconsprite("editor/point_projectile.vmt") = point_projectile : 
	"An entity that fires projectiles."
[
	Target(pointentityclass) : "Projectile Classname" : "crossbow_bolt" : "The classname of the projectile."
	Owner(target_destination) : "Owner Entity" : : "The projectile's owner entity, or whoever kills will be credited to."
	Damage(float) : "Damage" : "100.0" : "The damage of the projectile."
	Speed(float) : "Speed" : "1500" : "How fast the projectile should move."
	
	FireFromOwner(choices) : "Fire From Owner" : 0 : "Fires the projectile from the owner entity's origin instead of our own." =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input Fire(void) : "Fires a projectile with our current angles."
	input FireAtEntity(target_destination) : "Fires a projectile at a specific entity."
	input FireAtPosition(vector) : "Fires a projectile at a specific position."
	
	input SetDamage(float) : "Sets the projectile's damage."
	input SetOwnerEntity(target_destination) : "Sets the owner."
	input SetSpeed(float) : "Sets the projectile's starting speed."
	input SetProjectileClass(string) : "Sets the class of the projectile to spawn."
	
	// Outputs
	output OnFire(ehandle) : "Fires each time a projectile is fired, passing the projectile as the activator. The owner entity is the caller if it exists." 
]

@PointClass base(Targetname) iconsprite("editor/logic_substring.vmt") = logic_substring : "Returns substring of a string parameter\n\n"+
	"In memory of Holly Liberatore (moofemp)"
[
	spawnflags(Flags) =
	[
		1 : "[1] Start Disabled" : 0
	]
	
	startPos(integer) : "Substring start position" : 0 : "Position of the first character to be copied as a substring"
	length(integer) : "Substring length" : -1 : "Number of characters to include in the substring (-1 = until end of string)"
	
	input Disable(void) : "Disable entity functions."
	input Enable(void) : "Enable entity functions."
	input InValue(string) : "Input a string to substring and return through OutValue"
	input SetLength(integer) : "Set length of substring"
	input SetStartPos(integer) : "Set start position of substring"
	
	output OutValue(string) : "Output substring from InValue"
]


//-------------------------------------------------------------------------
//
// Activator Filters
//
//-------------------------------------------------------------------------

@BaseClass base(Targetname) = BaseFilter
[
	Negated(choices) : "Filter mode" : "Allow entities that match criteria" : "If set to Allow, only entities who match the criteria will pass the filter. "+
		"If set to Disallow, only entities who do NOT match the criteria will pass the filter." =
	[
		0 : "Allow entities that match criteria"
		1 : "Disallow entities that match criteria"
	]
	
	PassCallerWhenTested(choices) : "Pass caller when tested" : 0 : "When tested with TestActivator or TestEntity, this causes the OnPass and OnFail outputs to use either this filter as the caller or the entity that called the test as the caller." =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input TestActivator(void) : "Tests the activator against the filter and fires the OnPass or OnFail output."
	input TestEntity(target_destination) : "Tests the target entity against the specified entity and fires the OnPass or OnFail output."
	input SetField(string) : "Sets this filter's primary test criteria. (e.g. the name to test against the activator)"

	// Outputs
	output OnPass(void) : "Fired in response to TestActivator input if the activator passes the filter."
	output OnFail(void) : "Fired in response to TestActivator input if the activator fails to pass the filter."
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_generic.vmt") = filter_base :
	"A filter that literally just passes as true every single time. Useful for when you...uh...want to pass something as true every single time?"
[
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_multiple.vmt") = filter_multi :
	"A filter that tests the activator against multiple filters. This allows you to build more complex filters, such as"+
	"'Allow anyone on Team 1 who is also class engineer', or 'Allow everyone except classes npc_zombie and npc_headcrab'."
[
	filtertype(choices) : "Logic Type" : 0 =
	[
		0 : "AND (all filters must pass)"
		1 : "OR (any filter must pass)"
	]

	Negated(choices) : "Negate Outcome" : 0 : "Whether to negate the result of the subfilters, after combining them using the Logic Type chosen.\n"+
		"Negating the outcome using the AND logic type means that any subfilter must fail for this filter to pass.\n"+
		"Negating the outcome using the OR logic type means that all subfilters must fail for this filter to pass." =
	[
		0 : "No"
		1 : "Yes"
	]

	Filter01(filterclass) : "Filter 1" : : "Activator filter to test."
	Filter02(filterclass) : "Filter 2" : : "Activator filter to test."
	Filter03(filterclass) : "Filter 3" : : "Activator filter to test."
	Filter04(filterclass) : "Filter 4" : : "Activator filter to test."
	Filter05(filterclass) : "Filter 5" : : "Activator filter to test."
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_name.vmt") = filter_activator_name :
	"A filter that filters by the name of the activator."
[
	filtername(target_destination) : "Filter Name" : : "The name to filter by. If the filter mode is Allow, only entities whose "+
		"name matches the given string will pass the filter. If the filter mode is Disallow, "+
		"all entities EXCEPT those whose name matches the string will pass the filter."
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_class.vmt") = filter_activator_class :
	"A filter that filters by the class name of the activator."
[
	filterclass(string) : "Filter Classname" : : "The class name to filter by. If the filter mode is Allow, only entities whose "+
		"class name matches the given string will pass the filter. If the filter mode is Disallow, "+
		"all entities EXCEPT those whose class name matches the given string will pass the filter."
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_class.vmt") = filter_activator_mass_greater :
	"A filter that filters by the mass of the activator."
[
	filtermass(float) : "Filter Mass" : : "The mass to filter by. If the filter mode is Allow, only entities whose "+
		"mass is greater than the give float will pass the filter. If the filter mode is Disallow, "+
		"all entities EXCEPT those whose mass is greater than the given float will pass the filter."
]

@FilterClass base(BaseFilter, DamageTypes) = filter_damage_type :
	"A damage filter that filters by the type of damage inflicted. This can only be used as a damage filter, not as an activator filter."
[
	filtertype(choices) : "Logic Type" : 1 : "Most of these are only relevant if more than one damage type is a factor." =
	[
		0 : "EQUAL TO (input and damage type must be equal)"
		1 : "AND (input must contain all bits in damage type)"
		2 : "OR (input must contain any bit in damage type)"
	]

	damagetype(choices) : "Damage Type" : 0 : "The type(s) of damage associated with this entity." =
	[
		0 : "[0] GENERIC"
		1 : "[1] CRUSH"
		2 : "[2] BULLET"
		4 : "[4] SLASH"
		8 : "[8] BURN"
		//16 : "[16] FREEZE" // This does not appear to exist.
		16 : "[16] VEHICLE"
		32 : "[32] FALL"
		64 : "[64] BLAST"
		128 : "[128] CLUB"
		256 : "[256] SHOCK"
		512 : "[512] SONIC"
		1024 : "[1024] ENERGYBEAM"
		16384: "[16384] DROWN"
		32768 : "[32768] PARALYSE"
		65536 : "[65536] NERVEGAS"
		131072 : "[131072] POISON"
		262144 : "[262144] RADIATION"
		524288 : "[524288] DROWNRECOVER"
		1048576 : "[1048576] ACID"
		2097152 : "[2097152] SLOWBURN"
		//4194304 : "[4194304] SLOWFREEZE" // This does not appear to exist.
		4194304 : "[4194304] REMOVENORAGDOLL"
		16777216 : "[16777216] PLASMA"
		33554432 : "[33554432] AIRBOAT (gun)"
		67108864 : "[67108864] DISSOLVE"
		134217728 : "[134217728] BLAST_SURFACE"
		268435456 : "[268435456] DIRECT"
		536870912 : "[536870912] BUCKSHOT"
		268435464 : "Ignite Damage (BURN + DIRECT) [268435464]"
	]
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_class.vmt") sphere(filter_radius) sphere(filter_outer_radius) = filter_enemy :
	"A filter that filters a potential enemy entity by a set of criteria."
[
	filtername(string) : "Name/Classname" : : "The classname or entity name to filter by. If the filter mode is Allow, only entities whose "+
		"class name matches the given string will pass the filter. If the filter mode is Disallow, "+
		"all entities EXCEPT those whose class name matches the given string will pass the filter."
		
	filter_radius(float) : "Radius" : 0 : "Radius by which to test the proximity of the enemy.  If the filter mode is Allow, only entities whose "+
		"distance is equal to or closer than the radius will pass the filter. If the filter mode is Disallow, "+
		"all entities outside the radius will pass the filter."

	filter_outer_radius(float) : "Outer Radius" : 0 : "Enemies outside this radius are considered invalid if Allow is set and valid if Disallow is set."
	
	filter_max_per_enemy(integer) : "Max Squadmates Per Enemy" : 0 : "Maximum number of squadmates allowed to target any given entity."
	
	spawnflags(Flags) =
	[
		1 : "[1] Do not lose target if already aquired but filter failed." : 0
	]
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_model.vmt") = filter_activator_model :
	"A filter that filters by the model of the activator."
[
	filtermodel(studio) : "Filter Model" : : "The model to filter by. If the filter mode is Allow, only entities whose "+
		"model matches the given string will pass the filter. If the filter mode is Disallow, "+
		"all entities EXCEPT those whose model matches the given string will pass the filter."
		
	skin(string) : "Skin" : -1 : "Some models have multiple versions of their textures, called skins. Use this if you want to filter by skins as well. If you want any skin to be allowed, be sure to leave this at -1! It might automatically change when you choose a model. This keyvalue supports matchers (<, >, !=, etc.)."
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_context.vmt") = filter_activator_context :
	"A filter that filters by the response contexts of the activator."
[
	ResponseContext(string) : "Filter Context" : : "The context(s) to filter by. Syntax is 'key:value,key:value'. "+
		"Values in this field can use wilcards. For example, if this filter contains 'lastname:*', it will pass any entity with the context 'lastname', regardless of its value. "+
		"Wildcards do not apply to context names and you cannot define the same context multiple times, but inputs like AddContext or RemoveContext can be used to add to the filter context."
		
	any(choices) : "Pass if entity has any of these contexts" : 0 : "Should this filter only pass if the entity contains all of these contexts or can it pass if the entity has at least one of them?" =
	[
		0 : "No"
		1 : "Yes"
	]
		
	// Inputs
	input AddContext(string) : "Adds a context to this fitler's list of response contexts. The format should be 'key:value'."
	input RemoveContext(string) : "Remove a context from this filter's list of response contexts. The name should match the 'key' of a previously added context."
	input ClearContext(void) : "Removes all contexts in this filter's list of response contexts."
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_generic2.vmt") = filter_activator_squad :
	"A filter that filters by the squad of the activator."
[
	filtername(string) : "Filter Squad" : : "The squad name to filter by. If the filter mode is Allow, only entities who are "+
		"in the squad of the given string will pass the filter. If the filter mode is Disallow, "+
		"all entities EXCEPT those who are in the squad of the given string will pass the filter."
	
	allowsilentmembers(choices) : "Allow Silent Members" : 1 : "Allows silent squad members to pass the filter. Silent squad members are enemy finders and vital allies in player_squad." =
	[
		0 : "No"
		1 : "Yes"
	]
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_generic2.vmt") = filter_activator_hintgroup :
	"A filter that filters by the hintgroup of the activator."
[
	filtername(string) : "Filter Hintgroup" : : "The hintgroup to filter by. If the filter mode is Allow, only entities who have "+
		"the given hintgroup will pass the filter. If the filter mode is Disallow, "+
		"all entities EXCEPT those who have the given hintgroup will pass the filter."
		
	hintlimiting(choices) : "Hint Limit Nav" : 2 : "If set to Yes, only entities who are limiting navigation to their hintgroup will be allowed. "+
			"If set to No, only entities who are *not* limiting navigation to their hintgroup will be allowed. "+
			"If set to Don't Care, entities will pass regardless of the their navigational limits as long as they match the hintgroup."=
	[
		0 : "No"
		1 : "Yes"
		2 : "Don't Care"
	]
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_keyfield.vmt") = filter_activator_keyfield :
	"A filter that filters by the activator's keyfields."
[
	keyname(string) : "Key" : : "The key name to filter by. Please note that certain keyvalues, particularly "+
		"targetnames and base values related to clientside rendering (e.g. render mode), cannot be found by this filter."
		
	value(string) : "Value (Optional)" : : "The key value to filter by. If empty, the filter will pass if the entity just has the keyfield."
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_relationship.vmt") = filter_activator_relationship :
	"A filter that filters by the activator's relationship with another entity. Please note that any entity incapable of supporting relationships is automatically passed if this filter is set to 'Neutral'."
[
	target(target_destination) : "Subject" : : "The entity whose relationships we should test with. If empty, the entity using the filter will be used."
	
	rank(string) : "Priority" : : "The priority the subject should have with the target. If empty, priority will be disregarded."
	disposition(choices) : "Disposition" : 3 : "What relationship the subject should have with the activator." =
	[
		1 : "Hate"
		2 : "Fear"
		3 : "Like"
		4 : "Neutral"
	]
	
	inverttarget(choices) : "Invert Subject" : 0 : "Should we use the activator's relationship to the subject instead?"  =
	[
		0 : "No"
		1 : "Yes"
	]
	
	Reciprocal(choices) : "Reciprocal" : 0 : "Should we only pass if both entities have the same relationship with each other? Makes 'Invert Subject' useless."  =
	[
		0 : "No"
		1 : "Yes"
	]
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_classify.vmt") = filter_activator_classify :
	"A filter that filters by the Class_T of the activator."
[
	filterclassify(choices) : "Filter Classify" : 0 : "The class to filter by. If the filter mode is Allow, only entities whose "+
		"class matches the given class will pass the class filter. If the filter mode is Disallow, "+
		"all entities EXCEPT those whose class matches the given class will pass the class filter." =
	[
		0 : "CLASS_NONE"
		1 : "CLASS_PLAYER"
		2 : "CLASS_PLAYER_ALLY (Citizens)"
		3 : "CLASS_PLAYER_ALLY_VITAL (Alyx, Dr. Kleiner, GameEndAlly vorts, etc.)"
		4 : "CLASS_ANTLION"
		5 : "CLASS_BARNACLE"
		6 : "CLASS_BULLSEYE (npc_bullseyes)"
		7 : "CLASS_CITIZEN_PASSIVE (pre-criminal citizens)"
		//8 : "CLASS_CITIZEN_REBEL (Unused)"
		9 : "CLASS_COMBINE (Soldiers, turrets, etc.)"
		10 : "CLASS_COMBINE_GUNSHIP (Gunships, helicopters, dropships)"
		//11 : "CLASS_CONSCRIPT (Unused)"
		12 : "CLASS_HEADCRAB"
		13 : "CLASS_MANHACK"
		14 : "CLASS_METROPOLICE"
		//15 : "CLASS_MILITARY (Unused)"
		16 : "CLASS_SCANNER"
		17 : "CLASS_STALKER"
		18 : "CLASS_VORTIGAUNT (Non-vital vortigaunts only)"
		19 : "CLASS_ZOMBIE"
		20 : "CLASS_PROTOSNIPER (npc_snipers)"
		21 : "CLASS_MISSILE"
		22 : "CLASS_FLARE"
		23 : "CLASS_EARTH_FAUNA (crows, seagulls, etc.)"
		24 : "CLASS_HACKED_ROLLERMINE"
		25 : "CLASS_COMBINE_HUNTER"
	]
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_involume.vmt") = filter_activator_involume :
	"A filter that tests whether the activator is within a volume."
[
	target(target_destination) : "Volume" : : "The volume to be tested with. This filter passes if the activator is within this volume. Intended to be a brush entity. (e.g. a trigger)"
	
	tester(target_destination) : "Volume Tester" : "!activator" : "Who should be in the volume for the filter to pass?"
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_generic.vmt") = filter_activator_surfacedata :
	"A filter that tests the activator's surface data."
[
	filtersurfaceprop(choices) : "Surface" : : "The surface to test with." =
	[
		"metal" : "Metal"
		"metalgrate" : "Metal Grate"
		"metalvent" : "Metal Vent"
	]
	
	SurfaceType(choices) : "Type" : 1 : "What to actually filter by."  =
	[
		0 : "Surface Prop"
		1 : "Game Material"
	]
]

//-------------------------------------------------------------------------
//-------------------------------------------------------------------------

@BaseClass base(BaseFilter) = BaseRedirectFilter
[
	damagefilter(filterclass) : "Target Filter" : "" : "The filter to pass to. You can also use the 'SetField' input."
	input SetField(target_destination) : "Sets the filter to pass to."
]

@FilterClass base(BaseRedirectFilter) iconsprite("editor/filter_redirect.vmt") = filter_redirect_inflictor :
	"A filter that passes the inflictor of damage (e.g. the crossbow bolt instead of the crossbow user) to a separate filter."
[
]

@FilterClass base(BaseRedirectFilter) iconsprite("editor/filter_redirect.vmt") = filter_redirect_weapon :
	"A filter that passes the activator's weapon OR the weapon causing damage to a separate filter, depending on what this filter is filtering."
[
]

@FilterClass base(BaseRedirectFilter) iconsprite("editor/filter_redirect.vmt") = filter_redirect_owner :
	"A filter that passes the activator's owner entity to a separate filter."
[
]

@FilterClass base(BaseRedirectFilter) iconsprite("editor/filter_damage_transfer.vmt") = filter_damage_transfer :
	"Whenever an entity using this as a damage filter takes damage, that damage is transferred to another entity. The entity using this filter will not take the damage unless a secondary filter is specified and passed or caller damage is allowed. All damage information including force, type, attacker, etc. should be retained during the transfer and it obeys the target entity's own damage filters."
[
	target(target_destination) : "Transfer Target" : "" : "The name of the entity/entities that will receive the damage. Please note that this complies with their own damage filters."
	input SetTarget(target_destination) : "Sets the transfer target."
	
	AdjustDamagePosition(choices) : "Adjust Damage Position" : 0 : "Adjusts the damage position to be relative to the target entity." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	MaxEntities(integer) : "Max Entities" : 1 : "The maximum number of entities matching the criteria who can be damaged. 0 = no limit. (0 is actually changed to 2048 internally, but don't worry about that)"
	
	CallerDamageAllowed(choices) : "Caller Damage Allowed" : 0 : "Sets whether the caller using this filter is allowed to take the transferred damage as well." =
	[
		0 : "No"
		1 : "Yes"
	]

	damagefilter(filterclass) : "Secondary Filter" : "" : "A secondary filter that can be used for certain things. See the Secondary Filter Mode for different ways you can use this. This is optional."
	SecondaryFilterMode(choices) : "Secondary Filter Mode" : 0 : "How should the secondary filter be used?" =
	[
		0 : "Must pass to damage caller (if damage is allowed)"
		1 : "Must pass to transfer damage to targets"
		2 : "Each transfer target must pass"
	]
	
	input SetField(target_destination) : "Sets the secondary filter."
]

@FilterClass base(BaseRedirectFilter) iconsprite("editor/filter_blood_control.vmt") = filter_blood_control :
	"A filter that controls the blood an entity emits. Must be used as a damage filter to work properly."
[
	BloodDisabled(choices) : "Blood Disabled" : 0 : "Sets whether blood shouldn't be produced by damage. Overrides the secondary filter, if any." =
	[
		0 : "No"
		1 : "Yes"
	]

	damagefilter(filterclass) : "Secondary Filter" : "" : "An optional secondary filter that can be used for either whose damage could produce blood or as a real damage filter for whether any damage should be taken at all."
	SecondaryFilterMode(choices) : "Secondary filter is damage filter" : 0 : "Sets whether the secondary filter should be treated as a redirected damage filter (must pass to take actual damage) instead of just permitting blood." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	input SetField(target_destination) : "Sets the secondary filter."
	
	input DisableBlood(void) : "Disables blood."
	input EnableBlood(void) : "Enables blood if it was previously disabled."
]

@FilterClass base(BaseRedirectFilter) iconsprite("editor/filter_damage_mod.vmt") = filter_damage_mod :
	"A filter that modifies damage taken by an entity."
[
	SetDamageMultiplier(float) : "Damage Multiplier" : "1.0" : "Multiplies the damage by this scale."
	SetDamageAddend(float) : "Damage Addend" : "0" : "Adds to or subtracts the damage by this number. This is done after the damage is multiplied by the damage scale."
	SetDamageBitsAdded(integer) : "Damage Bits Added" : 0 : "Adds bits to the damage type. See a damage type keyvalue in an entity like filter_damage_type to get their bit representation."
	SetDamageBitsRemoved(integer) : "Damage Bits Removed" : 0 : "Removes bits from the damage type. See a damage type keyvalue in an entity like filter_damage_type to get their bit representation."

	NewAttacker(target_destination) : "New Attacker" : : "If specified, the damage will be credited to this entity instead of the original attacker."
	NewInflictor(target_destination) : "New Inflictor" : : "If specified, the damage's inflictor will be changed to this entity instead of the original inflictor."
	NewWeapon(target_destination) : "New Weapon" : : "If specified, the damage's weapon will be changed to this entity instead of the original weapon."

	damagefilter(filterclass) : "Secondary Filter" : "" : "An optional secondary filter that can be used for either whose damage could be modified or as a real damage filter for whether any damage should be taken at all."
	SecondaryFilterMode(choices) : "Secondary Filter Mode" : 0 : "Sets whether the secondary filter should be treated as a redirected damage filter (must pass to take actual damage) instead of just permitting modification." =
	[
		0 : "Must pass to damage caller (and therefore mod damage)"
		1 : "Must pass to modify damage (others use the original damage)"
		2 : "Attackers must pass to modify damage"
	]
	
	input SetDamageMultiplier(float) : "Sets the damage multiplier."
	input SetDamageAddend(float) : "Sets the damage addend."
	input SetDamageBitsAdded(integer) : "Sets the damage types added."
	input SetDamageBitsRemoved(integer) : "Sets the damage types removed."
	
	input SetNewAttacker(target_destination) : "Sets the new attacker."
	input SetNewInflictor(target_destination) : "Sets the new inflictor."
	input SetNewWeapon(target_destination) : "Sets the new weapon."
	
	input SetField(target_destination) : "Sets the secondary filter."
]

@FilterClass base(BaseRedirectFilter) iconsprite("editor/filter_damage_logic.vmt") = filter_damage_logic :
	"A filter that fires outputs based on received damage information."
[
	damagefilter(filterclass) : "Secondary Filter" : "" : "An optional secondary filter that can be used as an actual damage filter, which damage to operate with, etc."
	SecondaryFilterMode(choices) : "Secondary Filter Mode" : 0 : "Sets how the secondary filter should be treated." =
	[
		0 : "Use as a regular damage filter; must pass to fire outputs"
		1 : "Use as a regular damage filter, but fire outputs even if it fails"
		2 : "Use only to permit outputs, failed damage is dealt anyway"
	]
	
	input SetField(target_destination) : "Sets the secondary filter."
	
	// Outputs
	output OutInflictor(ehandle) : "Outputs the damage inflictor."
	output OutAttacker(ehandle) : "Outputs the damage attacker."
	output OutWeapon(ehandle) : "Outputs the damage weapon."
	
	output OutDamage(float) : "Outputs the damage."
	output OutMaxDamage(float) : "Outputs the max damage."
	output OutBaseDamage(float) : "Outputs the base damage."
	
	output OutDamageType(integer) : "Outputs the damage type."
	output OutDamageCustom(integer) : "Outputs the damage custom."
	output OutDamageStats(integer) : "Outputs the damage stats."
	output OutAmmoType(integer) : "Outputs the ammo type."
	
	output OutDamageForce(vector) : "Outputs the damage force."
	output OutDamagePosition(vector) : "Outputs the damage position."
	
	output OutForceFriendlyFire(bool) : "Outputs whether the damage info forces friendly fire."
]

//-------------------------------------------------------------------------
//-------------------------------------------------------------------------

@FilterClass base(BaseFilter) iconsprite("editor/filter_script.vmt") = filter_script :
	"A filter which utilizes hooks in its entity scripts."
[
]

//-------------------------------------------------------------------------
// 
// Special Mapbase Entities
// 
//-------------------------------------------------------------------------

@PointClass base(Targetname) iconsprite("editor/mapbase_manifest.vmt") color(239 163 14) = mapbase_manifest : "Mounts additional manifest files"
[
	// Keys
	target(string) : "Manifest File" : : "The manifest file to load. Keep in mind ''maps/%mapname%_manifest.txt'' is always loaded automatically without this entity."
	
	spawnflags(Flags) =
	[
		1 : "[1] Start Activated" : 1
	]
	
	// Inputs
	input Activate(void) : "Loads the manifest file if it hasn't been loaded already."
]

// Was mapbase_convar_mod
@PointClass base(Targetname) iconsprite("editor/convar_mod.vmt") color(239 163 14) = game_convar_mod : "Mods cvars"
[
	// Keys
	target(string) : "ConVars" : "" : "The convars to modify. Multiple cvars can be modded with ';', e.g. 'host_timescale 0.5; npc_alyx_interact_manhacks 1'"
	
	UseServer(choices) : "Command from Server" : 0 : "Mods convars directly from the server instead of acting as if the convars were typed into the local player's console, similar to using point_servercommand as opposed to point_clientcommand. Required to function in MP games." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	spawnflags(Flags) =
	[
		1 : "[1] Start Activated" : 1
	]
	
	// Inputs
	input Activate(void) : "Begins modding the cvars."
	input Deactivate(void) : "Stops modding the cvars."
]

//-------------------------------------------------------------------------
//
// Point Entities
//
//-------------------------------------------------------------------------

@PointClass base(Targetname, Parentname, EnableDisable) = point_anglesensor :
	"An entity that detects if another entity points in a given direction for a period of time."
[
	target(target_destination) : "Target Entity Name" : : "Name of the entity whose angles will be sensed."
	lookatname(target_destination) : "Look At Entity" : : "The entity we want to check to see if the Target Entity is looking at."
	duration(float) : "Duration" : : "The amount of time the Target Entity must look at the 'Look at Entity' to trigger this entity, in seconds."
	tolerance(integer) : "Tolerance" : : "The tolerance, in degrees, in the checking to determine when the Target Entity is looking at the Look At Entity."

	spawnflags(Flags) =
	[
		1 : "[1] Use target entity's angles (NOT position)" : 0
	]
	
	// Inputs
	input Toggle(void) : "Toggle the sensor between enabled and disabled."
	input Test(void) : "Check to see if the Target Entity is facing the Look At Entity within the specified tolerance, firing either the OnFacingLookat or OnNotFacingLookat output based on the result."
	
	// Outputs
	output TargetDir(vector) : "Fired when the forward direction of the Target Entity changes. Passes the new forward direction as a parameter."
	output OnFacingLookat(void) : "Fired when the Target Entity points at the Look At Entity for more than the specified Duration, or in response to a Test input."
	output OnNotFacingLookat(void) : "Fires in response to a Test input when the Target Entity is not pointing at the Look At Entity."
	output FacingPercentage(float) : "Normalized value (0..1) where 1 is facing directly at target and 0 is at or beyond the angle of tolerance."
]

@PointClass base(Targetname) = point_angularvelocitysensor :
	"An entity that detects if another entity's angular velocity meets or exceeds a threshold value."
[
	target(target_destination) : "Target Entity Name" : : "Name of the entity whose angular velocity will be sensed."
	threshold(float) : "Threshold Velocity" : 0 : "The threshold angular velocity to compare against, in degrees per second."
	fireinterval(float) : "Fire Interval" : "0.2" : "Angular velocity must cross the threshold for at least this long to fire."

	axis(vecline) : "Axis"

	usehelper(choices) : "Use Axis Helper" : 0 : "Use axis helper to determine rotation values (clockwise/counter-clockwise)." =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input Test(void) : "Checks to see if the Target Entity's angular velocity meets or exceeds the Threshold Velocity, " +
		"firing either the OnGreaterThanOrEqualTo or OnLessThan output based on the result."

	input TestWithInterval(void) : "Checks to see if the Target Entity's angular velocity meets or exceeds the Threshold Velocity. Once the Fire Interval expires, " +
		"fires the appropriate test result output if the result is stable throughout the Fire Interval."
	
	// Outputs
	output AngularVelocity(float) : "Fired when the Target's Angular Velocity changes, passing the new magnitude of the angular velocity."
	output OnGreaterThan(void) : "Fired when the Target Entity goes from slower than the threshold angular velocity to faster than the threshold angular velocity."
	output OnGreaterThanOrEqualTo(void) : "Fired when the Target Entity goes from slower than the threshold angular velocity to faster than the threshold angular velocity."
	output OnLessThan(void) : "Fired when the Target Entity goes from faster than the threshold angular velocity to slower than the threshold angular velocity."
	output OnLessThanOrEqualTo(void) : "Fired when the Target Entity goes from faster than the threshold angular velocity to slower than the threshold angular velocity."
	output OnEqualTo(void) : "Fired when the Target Entity reaches the threshold angular velocity from a different velocity."
]

@PointClass base(Targetname) = point_velocitysensor :
	"An entity that detects and outputs an entity's velocity."
[
	target(target_destination) : "Target Entity Name" : : "Name of the entity whose velocity will be sensed."
	axis(vecline) : "Measurement Axis"
	enabled(choices) : "Start Enabled" : 1 : "Whether or not to start enabled and active." =
	[
		0 : "No"
		1 : "Yes"
	]

	// Outputs
	output Velocity(float) : "Fired when the Target's Velocity changes, passing the new magnitude of the velocity."

	input Enable(void) : "Enable the sensor."
	input Disable(void) : "Disable the sensor."
]

@PointClass base(Targetname, Parentname, EnableDisable, Angles) = point_proximity_sensor :
	"An entity that detects another entity's proximity to a target position."
[
	target(target_destination) : "Target Entity Name" : : "Name of the entity whose angles will be sensed."

	spawnflags(Flags) =
	[
		1 : "[1] Test the distance as measured along the axis specified by our direction." : 0
	]
	
	// Inputs
	input Toggle(void) : "Toggle the sensor between enabled and disabled."
	input SetTargetEntity(target_destination) : "Sets the entity whose angles will be sensed."
	
	// Outputs
	output Distance(float) : "Distance of the target entity away from this entity."
]


@PointClass base(Targetname, Parentname, Angles) = point_teleport : 
	"An entity that teleports a target entity to this position and angles. "+
	"If 'Teleport Home' spawn flag is set, teleports the target entity to its spawn position instead." +
	"If object is physically simulated, simulation is turned off when teleported."
[
	target(target_destination) : "Entity To Teleport" : : "Name of the entity that will be teleported."
	spawnflags(flags) =
	[
		1 : "[1] Teleport Home" : 0
		2 : "[2] Into Duck (episodic)" : 0
	]

	// Inputs
	input Teleport(void) : "Teleport the target entity."
	input TeleportEntity(target_destination) : "Teleport the output parameter box entity."
	input TeleportToCurrentPos(void) : "Teleport to the current position."
]

@PointClass base(Targetname, Parentname, DamageTypes) sphere(DamageRadius) = point_hurt :
	"An entity that does damage to all entities in a radius around itself, with a specified delay." +
	"If 'Target Entity' is specified, the damage is only done to that entity."
[
	DamageTarget(target_destination) : "Target Entity" : "" : "If specified, only this entity will take damage. Otherwise, all entities within the Radius will take damage."
	
	DamageRadius(float) : "Radius" : 256 : "All entities within this radius of this entity will take damage. If a 'Target Entity' is specified, only that entity will take damage."
	Damage(integer) : "Damage" : 5 : "Damage done to all affected entities each time this entity fires."
	DamageDelay(float) : "Delay" : 1 : "Delay between refires, in seconds."

	// Inputs
	input Hurt(void) : "Force a single fire, damaging either the Target Entity or all entities within the radius."
	input TurnOn(void) : "Enable this entity. It will start damaging entities everytime it fires, and refire based upon the specified Delay."
	input TurnOff(void) : "Disable this entity. It will stop damaging entities."
	input Toggle(void) : "Toggle this entity between On/Off state."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = point_playermoveconstraint : 
	"An entity that constrains players to a radius around itself, slowing them down the closer they get to the edge of the radius."
[
	radius(float) : "Radius" : 256 : "Radius to constrain players to."
	width(float) : "Constraint Width" : "75.0" : "Width of the constraint edge. This is the distance in which to start slowing players down as they approach the edge of the radius."
	speedfactor(float) : "Speed Factor" : "0.15" : "Factor applied to the player's max speed as they approach the radius edge."

	// Inputs
	input TurnOn(void) : "Start constraining any players within the radius."
	input TurnOff(void) : "Stop constraining any players previously constrained."

	// Outputs
	output OnConstraintBroken(void) : "Fired when a player breaks through the constraint."
]

//-------------------------------------------------------------------------
//
//	Physics entities
//
//-------------------------------------------------------------------------

@SolidClass base(BreakableBrush,Targetname, Origin, RenderFields, Shadow) = func_physbox : 
	"A brush entity that's physically simulated."
[
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
	spawnflags(flags) =
	[
		4096  : "[4096] Start Asleep" : 0
		8192  : "[8192] Ignore +USE for Pickup" : 0
		16384 : "[16384] Debris - Don't collide with the player or other debris" : 0
		32768 : "[32768] Motion Disabled" : 0
		65536 : "[65536] Use Preferred Carry Angles" : 0
		131072: "[131072] Enable motion on Physcannon grab" : 0
		262144: "[262144] Not affected by rotor wash" : 0
		524288: "[524288] Generate output on +USE " : 1
		1048576 : "[1048576] Physgun can ALWAYS pick up. No matter what." : 0
		2097152 : "[2097152] Physgun is NOT allowed to pick this up." : 0 
		4194304 : "[4194304] Physgun is NOT allowed to punt this object." : 0
		8388608: "[8388608] Prevent motion enable on player bump" : 0
		16777216: "[16777216] Radius pickup (easier to pickup)" : 0
	]
	
	Damagetype(choices) : "Impact Damage Type" : 0 =
	[
		0: "Blunt"
		1: "Sharp"
	]
	
	massScale(float) : "Mass Scale" : "0" : "A scale multiplier for the object's mass."
	overridescript(string) : "Override Parameters" : "" : "A list of physics key/value pairs that are usually in a physics prop .qc file. Format is 'key,value,key,value,etc'."
	damagetoenablemotion(integer) : "Health Level to Override Motion" : 0 : "If specified, this object will start motion disabled. Once its health has dropped below this specified amount, it will enable motion."
	forcetoenablemotion(float) : "Physics Impact Force to Override Motion" : 0 : "If specified, this object will start motion disabled. Any impact that imparts a force greater than this value on the physbox will enable motion."
	health(integer) : "Strength" : 0 : "Number of points of damage to take before breaking.  0 means don't break."
	preferredcarryangles(vector) : "Preferred Player-carry Angles" : "0 0 0" : "If the 'Use Preferred Carry Angles' spawnflag is set, this angle is the angle which the object should orient to when the player picks it up, with the physgun or +USE."
	notsolid(choices) : "Not solid to world" : 0 =
	[
		0: "Solid to World"
		1: "Passes through World"
	]
	
	// Inputs
	input Wake(void) : "Wake up this physics object, if it is sleeping."
	input Sleep(void) : "Put this physics object to sleep. It will wake if given the Wake input, or if force is applied to it. Note that physics objects go to sleep automatically after coming to rest for a while, so you don't really need to use this."
	input EnableMotion(void) : "Enable physics motion/collision response."
	input DisableMotion(void) : "Disable physics motion/collision response."
	input EnableMotionKeepVelocity(void) : "Enable physics motion/collision response (Keeps velocity)."
	input DisableMotionKeepVelocity(void) : "Disable physics motion/collision response (Keeps velocity)."
	input ForceDrop(void) : "If this object is being carried by a player, with the physgun or +USE, force it to be dropped."
	input SetDebris(bool) : "Sets whether this brush is debris."
	
	// Outputs
	output OnDamaged(void) : "Fired when this entity is damaged."
	output OnAwakened(void) : "Fired when this entity becomes awake (collision/force is applied)."
	output OnMotionEnabled(void) : "Fired when motion is enabled due to damage/physcannon/force."
	output OnPhysGunPickup(void) : "Fired when a player picks this object up, either with the physgun or +USE."
	output OnPhysGunPunt(void) : "Fired when a player punts this object with the physgun."
	output OnPhysGunOnlyPickup(void) : "Fired when a player picks this object up WITH THE PHYSGUN. +USE pickups do not fire this output."
	output OnPhysGunDrop(void) : "Fired when a player drops this object."
	output OnPlayerUse(void) : "Fired when the player tries to +USE the physbox. This output will fire only if the Generate output on +USE spawnflag is set."
]

@BaseClass base(Targetname) = TwoObjectPhysics
[
	spawnflags(flags) =
	[
		1: "[1] No Collision until break" : 0
		// 2 is defined independently by subclasses, do not reuse
		4: "[4] Start inactive" : 0
		8: "[8] Change mass to keep stable attachment to world" : 0
		16: "[16] Do not connect entities until turned on" : 0
	]
	attach1(target_destination) : "Entity 1" : ""
	attach2(target_destination) : "Entity 2" : ""
	constraintsystem(target_destination) : "Constraint System Manager" : "" : "The name of a phys_constraintsystem that this constraint should be a part of. All constraints on a set of entities should be placed in the same system, or they will fight each other during simulation."

	forcelimit(float) : "Force Limit to Break (lbs)" : "0" : "The amount of force an impact must apply to the constraint to break it. A way of calculating this is to set it to the mass of an object that would break this constraint if it were resting on the constrainted objects."
	torquelimit(float) : "Torque Limit to Break (lbs * distance)" : "0" : "The amount of torque required to break the constraint. A way of calculating this is to multiply any reference mass by the resting distance (from the center of mass of the object) needed to break the constraint."
	breaksound(sound) : "Play Sound on Break" : "" : "A sound played when the constraint is broken."
	teleportfollowdistance(float) : "Follow teleport distance" : "0" : "If one object teleports more than this many units away it will cause the other constrained object to teleport to an appropriate relative position."
	
	// Inputs
	input Break(void) : "Force the constraint to break."
	input TurnOn(void) : "Enable the constraint.  Do this when the objects don't exist when the constraint spawns - or when you have deactivated the constraint.  Broken constraints can NOT be turned on.  They have been deleted."
	input TurnOff(void) : "Disable this constraint." 

	// Outputs
	output OnBreak(void) : "Fired when the constraint breaks."
]
	
@PointClass base(Targetname) = phys_constraintsystem : 
	"An entity used to manage a group of interacting constraints and keep them stable. " +
	"All constraints on a set of entities should be placed in the same system, or they will fight each other during simulation."
[
	additionaliterations(integer) : "Additional System Iterations" : 0 : "Adding iterations makes the interactions among constraints in a system tighter.  It will not compensate for errors due to collision, but will help in cases where objects of disparate mass are constrained to each other."
]

@PointClass base(Targetname,Angles) = phys_keepupright : "A controller that tries to keep an entity facing a particular direction."
[
	spawnflags(flags) =
	[
		1: "[1] Start inactive" : 0
	]

	attach1(target_destination) : "Target Entity" : "" : "The entity to align to the desired angles."
	angularlimit(float) : "Angular Limit" : "15" : "The maximum angular velocity that this controller can compensate for, in degrees per second."

	// Inputs
	input TurnOn(void) : "Enable the controller."
	input TurnOff(void) : "Disable the controller." 
]

@PointClass base(Targetname, Angles, Studiomodel) sphere(expradius) studioprop() = physics_cannister : 
	"A physically simulated gas cannister that can have its cap shot off, at which point gas will start escaping and cause the cannister to fly around. If it takes enough damage, it will explode."
[
	model(studio) : "World model" : "models/props_c17/canister01a.mdl"
	spawnflags(flags) = 
	[
		1 : "[1] Start Asleep" : 0
		2 : "[2] Explodes" : 1
	]

	expdamage(string) : "Explosion Damage" : "128.0" : "The amount of damage done by the explosion created when the cannister blows up."
	expradius(string) : "Explosion Radius" : "256.0" : "The radius of the explosion to create when the cannister blows up."
	health(integer) : "Health" : 25 : "The amount of damage the cannister takes before exploding."

	thrust(string) : "Thrust" : "3000.0" : "When the cap has been blown off, and the escaping gas is thrusting the cannister about, this is the amount of thrust generated."
	fuel(string) : "Fuel Seconds" : "12.0" : "The amount of time that gas leaks from the cannister before being considered empty."
	rendercolor(color255) : "Smoke Color (R G B)" : "255 255 255"
	renderamt(integer) : "Smoke Alpha (0 - 255)" : 128
	gassound(sound) : "Thruster Sound" : "PhysicsCannister.ThrusterLoop" : "The sound played when the gas is escaping from the cannister."

	// Inputs
	input Activate(void) : "Start gas escaping from the cannister."
	input Deactivate(void) : "Stop gas escaping from the cannister."
	input Explode(void) : "Force the cannister to explode."
	input Wake(void) : "Wakes up the cannister, if it is sleeping."

	// Outputs
	output OnActivate(void) : "Fired when gas starts to escape from the cannister."
	output OnAwakened(void) : "Fired when this entity becomes awake (collision/force is applied)."
]

@PointClass base(Targetname, Parentname) size(-4 -4 -4, 4 4 4) = info_constraint_anchor : 
	"An entity used to attach constraints to a local position on an entity. Usually constraints will attach to the center of mass of an object. "+
	"Attach the desired constraint to this entity, and then parent this entity to the entity you want the constraint to apply to."
[
	massScale(float) : "Amount to scale the mass of this body in the constraint solver" : "1"
]

@PointClass size(-4 -4 -4, 4 4 4) = info_mass_center :
	"An entity that overrides the mass center of the target physics prop, or func_physbox, by moving it to the info_mass_center's location."
[
	target(target_destination) : "Target object" : ""  : "The entity whose mass center will be overridden."
]

@PointClass halfgridsnap base(Targetname) = phys_spring : 
	"A physically simulated spring. "+
	"'Length' is what's known as the 'natural spring length'. This is how long the spring would "+
	"be if it was at rest (nothing hanging on it or attached). When you attach something to the "+
	"spring, it will stretch longer than its 'natural length'. The amount of stretch is "+
	"determined by the 'Sprint Constant'. The larger the spring constant the less stretch the spring."
[
	spawnflags(flags) =
	[
		1 : "[1] Force only on stretch" : 0
	]

	attach1(target_destination) : "Entity 1" : ""
	attach2(target_destination) : "Entity 2" : ""

	springaxis(vecline) : "Spring Axis" : "" : "Use the helper. Drag it out to match the virtual spring."
	length(string) : "Spring Length" : "0" : "How long the spring would be if it was at rest (nothing hanging on it or attached). 0 means the length of the brush."
	constant(string) : "Spring Constant" : "50" : "Stiffness of the spring.  The larger the number the less the spring will stretch."
	damping(string) : "Damping Constant" : "2.0" : "How much energy the spring loses.  The larger the number, the less bouncy the spring."
	relativedamping(string) : "Relative Damping Constant" : "0.1" : "The amount of energy the spring loses proportional to the relative velocity of the two objects the spring is attached to."
	// UNDONE: add max tension and what event to fire when it breaks
	breaklength(string) : "Break on Length" : "0" : "If the spring's length ever exceeds this length, the spring breaks."

	// Inputs
	input SetSpringConstant(float) : "Set the Spring Constant."
	input SetSpringLength(float) : "Set the Spring Length."
	input SetSpringDamping(float) : "Set the Spring Damping."
]

@PointClass halfgridsnap size(-8 -8 -8, 8 8 8) base(TwoObjectPhysics) = phys_hinge : 
	"A physically simulated hinge. Use the helper to define the axis of rotation."
[
	hingefriction(float) : "Friction" : "0" : "Resistance/friction in the hinge"
	hingeaxis(vecline) : "Hinge Axis"
	SystemLoadScale(float) : "Load Scale" : "1" : "Scale of the load connected to this hinge (1=just the objects directly connected)"
	
	// Inputs
	input SetAngularVelocity(float) : "Set angular velocity around the hinge (motor) in deg/sec"
	

	
	//// Episodic only -- for now.
	
	minSoundThreshold(float) : "Minimum Sound Velocity" : "6" : "Episodic only. When travelling below this many units/sec, will not play any sound."
	maxSoundThreshold(float) : "Full Sound Velocity" : "80" : "Episodic only. When travelling at this speed or above, will play sound at full volume."
	slidesoundfwd(sound) : "Travel sound (forward)" : "" : "Episodic only. Play this sound when travelling forward on helper axis"
	slidesoundback(sound) : "Travel sound (backward)" : "" : "Episodic only. Play this sound when travelling backward on helper axis"
	
	reversalsoundthresholdSmall(float) : "Reversal sound threshold (small)" : "0" : "Episodic only. When accelerating by more than this many units/sec^2 opposite to direction of travel, play the small reversal sound." 
	reversalsoundthresholdMedium(float) : "Reversal sound threshold (medium)" : "0" : "Episodic only. When accelerating by more than this many units/sec^2 opposite to direction of travel, play the medium reversal sound."
	reversalsoundthresholdLarge(float) : "Reversal sound threshold (large)" : "0" : "Episodic only. When accelerating by more than this many units/sec^2 opposite to direction of travel, play the large reversal sound."
	
	reversalsoundSmall(sound) : "Reversal sound (small)" : "" : "Episodic only. Play this sound when making a hard reverse over the small threshold but less than medium"
	reversalsoundMedium(sound) : "Reversal sound (medium)" : "" : "Episodic only. Play this sound when making a hard reverse over the medium threshold but less than large"
	reversalsoundLarge(sound) : "Reversal sound (large)" : "" : "Episodic only. Play this sound when making a hard reverse over the large threshold"
]

@PointClass base(TwoObjectPhysics) iconsprite("editor/phys_ballsocket.vmt") = phys_ballsocket : 
	"A constraint that keeps the position of two objects fixed, relative to the constraint's origin. It does not affect rotation."
[
	spawnflags(flags) =
	[
	]
]

@PointClass base(TwoObjectPhysics) studio("models/editor/axis_helper.mdl") = phys_constraint : 
	"A constraint that keeps the relative position and orientation of two objects fixed."
[
]

@PointClass base(TwoObjectPhysics) studio("models/editor/axis_helper.mdl") = phys_pulleyconstraint : 
	"A constraint that is essentially two length constraints and two points. Imagine it as a virtual rope connected to two objects, each suspended from a pulley above them."+
	"The constraint keeps the sum of the distances between the pulley points and their suspended objects constant."
[
	addlength(float) : "Additional Length" : "0" : "Add (or subtract) this amount to the rest length of the pulley rope."
	gearratio(float) : "Pulley Gear Ratio" : "1" : "Add (or subtract) this amount to the rest length of the pulley rope."
	position2(vecline) : "Pulley Position 2" : : "The position of the pulley for Entity 2. The pulley for Entity 1 is the origin of this constraint entity. Entity 1 is always suspended from pulley point 1, and Entity 2 is always suspended from pulley point 2."
	spawnflags(flags) =
	[
		1: "[1] No Collision until break" : 1
		2: "[2] Keep Rigid" : 0
	]
]

@PointClass halfgridsnap base(TwoObjectPhysics) studio("models/editor/axis_helper.mdl") = phys_slideconstraint : 
	"A constraint that constrains an entity along a line segment."
[
	spawnflags(flags) =
	[
		1: "[1] No Collision until break" : 1
		2: "[2] Limit Endpoints" : 0
	]
	slideaxis(vecline) : "Sliding Axis"
	slidefriction(float) : "Friction" : "0" : "Resistance/friction in the constraint"
	SystemLoadScale(float) : "Load Scale" : "1" : "Scale of the mass load connected to this constraint (1=just the objects directly connected)"
	
	// Inputs
	input SetVelocity(float) : "Set linear velocity along the constraint"
	
	
	//// Episodic only -- for now.
	
	minSoundThreshold(float) : "Minimum Sound Velocity" : "6" : "When travelling below this many units/sec, will not play any sound."
	maxSoundThreshold(float) : "Full Sound Velocity" : "80" : "When travelling at this speed or above, will play sound at full volume."
	slidesoundfwd(sound) : "Travel sound (forward)" : "" : "Play this sound when travelling forward on helper axis"
	slidesoundback(sound) : "Travel sound (backward)" : "" : "Play this sound when travelling backward on helper axis"
	
	reversalsoundthresholdSmall(float) : "Reversal sound threshold (small)" : "0" : "When accelerating by more than this many units/sec^2 opposite to direction of travel, play the small reversal sound." 
	reversalsoundthresholdMedium(float) : "Reversal sound threshold (medium)" : "0" : "When accelerating by more than this many units/sec^2 opposite to direction of travel, play the medium reversal sound."
	reversalsoundthresholdLarge(float) : "Reversal sound threshold (large)" : "0" : "When accelerating by more than this many units/sec^2 opposite to direction of travel, play the large reversal sound."
	
	reversalsoundSmall(sound) : "Reversal sound (small)" : "" : "Play this sound when making a hard reverse over the small threshold but less than medium"
	reversalsoundMedium(sound) : "Reversal sound (medium)" : "" : "Play this sound when making a hard reverse over the medium threshold but less than large"
	reversalsoundLarge(sound) : "Reversal sound (large)" : "" : "Play this sound when making a hard reverse over the large threshold"
]

@PointClass base(TwoObjectPhysics) studio("models/editor/axis_helper.mdl") = phys_lengthconstraint : 
	"A constraint that preserves the distance between two entities. If the 'Keep Rigid' flag is set, think of it as a rod. If not, think off it as a virtual rope."
[
	addlength(float) : "Additional Length" : "0" : "Add (or subtract) this amount to the rest length of the rope."
	minlength(float) : "Minimum Length" : "0" : "If the constraint is not rigid, this is the minimum length it can be."
	attachpoint(vecline) : "Attached object 2 point" : "The position the rope attaches to object 2"
	spawnflags(flags) =
	[
		1: "[1] No Collision until break" : 1
		2: "[2] Keep Rigid" : 0
	]
]

@PointClass base(TwoObjectPhysics) studio("models/editor/axis_helper.mdl") = phys_ragdollconstraint : 
	"A constraint that fixes the position of two entities, relative to this constraint's origin. Also allows for limits on the rotation around each axis, in the space of this constraint."
[
	spawnflags(flags) =
	[
		1: "[1] No Collision until break" : 1
		2: "[2] Only limit rotation (free movement)" : 0
	]

	xmin(float) : "X axis min limit" : "-90" : "-180 min and 180 max = no constraint on this axis."
	xmax(float) : "X axis max limit" : "90" : "-180 min and 180 max = no constraint on this axis."
	ymin(float) : "Y axis min limit" : "0" : "-180 min and 180 max = no constraint on this axis."
	ymax(float) : "Y axis max limit" : "0" : "-180 min and 180 max = no constraint on this axis."
	zmin(float) : "Z axis min limit" : "0" : "-180 min and 180 max = no constraint on this axis."
	zmax(float) : "Z axis max limit" : "0" : "-180 min and 180 max = no constraint on this axis."
	xfriction(float) : "X axis friction" : "0"
	yfriction(float) : "Y axis friction" : "0"
	zfriction(float) : "Z axis friction" : "0"
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) color(0 0 255) = phys_convert : 
	"Turns an arbitrary entity into a physically simulated entity. i.e. brush entities will behave like func_physbox, model entities behave like prop_physics."
[
	spawnflags(flags) =
	[
		1: "[1] Convert Asleep" : 0
		2: "[2] Convert As Debris" : 0
	]
	target(target_destination) : "Entity to convert" : : "Name of the entity that will be converted to a physics object when the ConvertTarget input is fired."
	swapmodel(target_destination) : "Model Swap Entity"
	massoverride(float) : "Mass Override" : "0" : "Sets the mass when the object(s) are converted (0 means auto-calculate)"
	
	SetConversionType(choices) : "Conversion Type" : 0 : "How this phys_convert should convert objects." =
	[
		0 : "Simple (simple_physics_prop, simple_physics_brush)"
		1 : "Conventional (prop_physics, func_physbox)"
	]

	// Outputs
	output OnConvert(void) : "Fires after the conversion has taken place."

	// Inputs
	input ConvertTarget(void) : "Converts this entity's target to a physically simulated object." 
	input SetConversionType(integer) : "Sets this entity's conversion type. 0 = Simple, 1 = Conventional" 
]

@BaseClass base(Targetname) = ForceController
[
	spawnflags(flags) =
	[
		// Thrust is on by default (will turn off in forcetime)
		1: "[1] Start On" : 0
		// Apply linear force (if off, torque only)
		2: "[2] Apply Force" : 1
		// Apply rotational force (torque - if off, linear only)
		4: "[4] Apply Torque" : 1
		// Maintain local relationship with the attached object
		8: "[8] Orient Locally" : 1
		// Impulse is independent of object's mass (impulse is acceleration NOT force)
		16: "[16] Ignore Mass" : 0
	]
	attach1(target_destination) : "Attached Object" : "" : "Object to apply the force to."

	forcetime(string) : "Time of Force (0=inf)" : "0" : "Automatic shut-off after this time has passed (0 = stay on forever or until deactivated)"

	input Activate(void) : "Turn the force on"
	input Deactivate(void) : "Turn the force off"
	input Scale(string) : "Set Force Scale"
]

@PointClass base(ForceController, Angles) = phys_thruster : 
	"An entity used to apply constant acceleration to a physics object. "+
	"The force and torque is calculated using the position and direction of the thruster as an impulse. So moving those off the object's center "+
	"will cause torque as well. Torque can be removed by unchecking the 'apply torque' flag. The position of the thruster can be forced to be "+
	"at the object's center by checking to 'ignore pos' flag."
[
	spawnflags(flags) =
	[
		// Put the thrust at the object center
		32: "[32] Ignore Pos" : 0
	]
	
	force(string) : "Force" : "0" : "Force (will be integrated, units are force kg*in/s^2)"
]

@PointClass halfgridsnap base(ForceController) = phys_torque : 
	"An angular thruster. Use it to apply angular force to an entity."
[
	// Angular acceleration (units are degress/s^2)
	force(string) : "Angular Acceleration" : "0"
	axis(vecline) : "Rotation Axis" : ""
]

@PointClass base(Targetname) halfgridsnap size(-8 -8 -8, 8 8 8) = phys_motor : 
	"An entity that tries to spin a target entity at a particular speed."
[
	speed(string) : "Rotation Speed" : "0" : "Angular speed (units are degress/second)"
	spinup(string) : "Spin up time" : "1" : "spin up time in seconds (also affects the rate at which speed changes happen)"
	inertiafactor(float) : "System Interia Scale" : "1.0" : "Make this larger if the object being driven is constrained to a set of heavier objects."
	axis(vecline) : "Rotation Axis" : ""

	spawnflags(flags) =
	[
		// starts on by default
		1: "[1] Start On" : 1
		// Disable world collisions on hinges
		2: "[2] No world collision" : 0
		// motor also acts as a hinge constraining the object to this axis
		4: "[4] Hinge Object" : 1
		// Maintain local relationship with the attached object (NOT WORKING YET)
//		8: "[8] Orient Locally" : 1
	]
	attach1(target_destination) : "Attached Object" : "" : "Object to apply the force to"

	// Inputs
	input SetSpeed(float) : "Sets target speed"
	input TurnOn(void) : "Turns motor on"
	input TurnOff(void) : "Turns motor off"
]

@PointClass base(Targetname, Parentname, Angles, Studiomodel) studio() = phys_magnet : 
	"An entity that acts like a magnet, attaching metallic physics objects to itself when they touch it."
[
	spawnflags(flags) =
	[
		1 : "[1] Start Asleep" : 0
		2 : "[2] Motion Disabled" : 0
		4 : "[4] Suck On Touch" : 0
		8 : "[8] Allow Attached Rotation" : 0
		16: "[16] Coast jeep pickup hack" : 0
		32: "[32] Prevent player pickup" : 0
	]

	forcelimit(float) : "Force Limit to Break (lbs)" : "0" : "The amount of force necessary to break a stuck object off the magnet. A way of calculating this is to set it to the mass of an object that would break this constraint if it were resting on the magnet."
	torquelimit(float) : "Torque Limit to Break (lbs * distance)" : "0" : "The amount of torque necessary to break a stuck object off the magnet. A way of calculating this is to multiply any reference mass by the resting distance (from the center of mass of the object) needed to break the constraint."

	massScale(float) : "Mass Scale" : "0" : "A scale multiplier for the object's mass."
	overridescript(string) : "Override parameters" : "" : "A list of physics key/value pairs that are usually in a physics prop .qc file. Format is 'key,value,key,value,etc'."
	maxobjects(integer) : "Maximum Attached Objects" : 0 : "The maximum number of physics objects that can be stuck to the magnet at once. 0 = no limit."

	// Inputs
	input TurnOn(void) : "Turn the magnet on."
	input TurnOff(void) : "The the magnet off. This will detach anything current stuck to the magnet."

	// Outputs
	output OnAttach(void) : "Fired when an entity is grabbed by the magnet."
	output OnDetach(void) : "Fired when an entity is released by the magnet."
]


//-------------------------------------------------------------------------
//
// Props
//
//-------------------------------------------------------------------------

@BaseClass = prop_detail_base
[
	model(studio) : "World model"
]

@BaseClass base(Angles, DXLevelChoice) = prop_static_base
[
	model(studio) : "World Model"
	skin(integer) : "Skin" : 0 : "Some models have multiple versions of their textures, called skins. Set this to a number other than 0 to use that skin instead of the default."
	solid(choices) : "Collisions" : 6 =
	[
		0: "Not Solid"
		2: "Use Bounding Box"
		6: "Use VPhysics"
	]
	disableshadows(choices) : "Disable Shadows" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	screenspacefade(choices) : "Screen Space Fade" : 0 : "The method by which the fading distance should be determined. If 'No', the fade distances is the distance from the player's view to the object, in units. If 'Yes', the fade distance is the size of the object onscreen, in pixels." =
	[
		0 : "No"
		1 : "Yes"
	]
	fademindist(float) : "Start Fade Dist/Pixels" : -1 : "Distance at which the prop starts to fade (<0 = use fademaxdist). If 'Screen Space Fade' is selected, this represents the number of pixels wide covered by the prop when it starts to fade."
	fademaxdist(float) : "End Fade Dist/Pixels" : 0 : "Maximum distance at which the prop is visible (0 = don't fade out). If 'Screen Space Fade' is selected, this represents the *minimum* number of pixels wide covered by the prop when it fades."
	fadescale(float) : "Fade Scale" : 1 : "If you specify a fade in the worldspawn, or if the engine is running under dx7 [hl2/ep1/portal] or dx8 [ep2/tf], then the engine will forcibly fade out props even if fademindist/fademaxdist isn't specified." +
												 " This scale factor gives you some control over the fade. Using 0 here turns off the forcible fades." +
												 " Numbers smaller than 1 cause the prop to fade out at further distances, and greater than 1 cause it to fade out at closer distances."
	lightingorigin(target_destination) : "Lighting Origin" : "" : "Select an info_lighting to specify a location to sample lighting from, instead of using this entity's origin."
	disablevertexlighting(choices) : "Disable Vertex lighting" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	disableselfshadowing(choices) : "Disable Self-Shadowing with vertex lighting" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	ignorenormals(choices) : "Ignore surface normal for computing vertex lighting" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
]

@BaseClass = BaseFadeProp
[
	fademindist(float) : "Start Fade Dist" : -1 : "Distance at which the prop starts to fade (<0 = use fademaxdist)."
	fademaxdist(float) : "End Fade Dist" : 0 : "Max fade distance at which the prop is visible (0 = don't fade out)"
	fadescale(float) : "Fade Scale" : 1 : "If you specify a fade in the worldspawn, or if the engine is running under dx7, then the engine will forcibly fade out props even if fademindist/fademaxdist isn't specified." +
												 " This scale factor gives you some control over the fade. Using 0 here turns off the forcible fades." +
												 " Numbers smaller than 1 cause the prop to fade out at further distances, and greater than 1 cause it to fade out at closer distances."
]

@BaseClass base(Parentname, Global, Angles, Studiomodel, BreakableProp, DXLevelChoice, BaseFadeProp, RenderFields) = prop_dynamic_base
[
	solid(choices) : "Collisions" : 6 =
	[
		0: "Not Solid"
		2: "Use Bounding Box"
		6: "Use VPhysics"
	]

	spawnflags(flags) =
	[
		64 : "[64] Use Hitboxes for Renderbox" : 0
		128 : "[128] No VPhysics (must start with collisions disabled)" : 0
		256 : "[256] Start with collision disabled" : 0
	]

	DefaultAnim(string) : "Default Animation" : "" : "The name of the idle animation that this prop will revert to whenever it finishes a random or forced animation."

	RandomAnimation(choices) : "Randomly Animate" : 0 : "If set, this prop will randomly choose and play animations, based upon the times specified in 'Min/Max Random Anim Time'. Inbetween the random animations, it will revert to playing the 'Default Animation'." =
	[
		0: "No"
		1: "Yes"
	]
	MinAnimTime(float) : "Min Random Anim Time" : "5" : "Minimum time between random animations."
	MaxAnimTime(float) : "Max Random Anim Time" : "10" : "Maximum time between random animations."
	SetBodyGroup(integer) : "Body Group" : 0	// NEEDHELP
	
	DisableBoneFollowers(choices) : "Disable Bone Followers" : 0 : "If set, this prop won't generate bone followers, even if they're listed in the model's .qc" =
	[
		0: "No"
		1: "Yes"
	]

	HoldAnimation(choices) : "Hold Animation" : 0 : "If set, the prop will not loop its animation, but hold the last frame." =
	[
		0: "No"
		1: "Yes"
	]
	
	updatechildren(choices) : "Update children" : 0 : "Update touches for any children that are attached to attachment points as this prop animates. "+
		"This allows SetParentAttached triggers or func_brushes to touch properly." =
	[
		0: "No"
		1: "Yes"
	]
	
	// Inputs
	input SetAnimation(string) : "Forces the prop to play an animation. The parameter should be the name of the animation."
	input SetAnimationNoReset(string) : "Force the prop to play an animation unless the prop is already playing the animation. The parameter should be the name of the animation."
	input SetDefaultAnimation(string) : "Sets the Default Animation to the one specified in the parameter."
	input SetPlaybackRate(float) : "Sets the playback rate for the current animation."
	input SetCycle(float) : "Sets the cycle the current animation."
	input SetBodyGroup(integer) : "Sets the visible bodygroup, by index."
	input TurnOn(void) : "Makes the prop visible."
	input TurnOff(void) : "Makes the prop invisible."
	input EnableCollision(void) : "Enables collision on the prop."
	input DisableCollision(void) : "Disables collision on the prop."

	// Outputs
	output OnAnimationBegun(void) : "Fired whenever a new animation has begun playing."
	output OnAnimationDone(void) : "Fired whenever an animation is complete."
]

@PointClass base(prop_detail_base) studioprop() = prop_detail : 
	"Detail Prop"
[
	model(studio) : "World model"
]

@PointClass base(prop_static_base) color(255 255 0) sphere(fademindist) sphere(fademaxdist) studioprop() = prop_static :
	"A prop that doesn't move and doesn't animate."
[
]

@PointClass base(prop_dynamic_base,EnableDisable) sphere(fademindist) sphere(fademaxdist) studioprop() = prop_dynamic :
	"A prop that can be placed in hierarchy and can play animations. It can also be configured to break when it takes enough damage. "+
	"Note that the health of the object will be overridden by the health inside the model, to ensure consistent health game-wide. "+
	"If the model used by the prop is configured to be used as a prop_physics (i.e. it should be physically simulated) then it CANNOT be "+
	"used as a prop_dynamic. Upon level load it will display a warning in the console and remove itself. Use a prop_physics instead."
[
]

@PointClass base(prop_dynamic_base) studioprop() = prop_dynamic_override :
	"A prop that can be placed in hierarchy and can play animations. It can also be configured to break when it takes enough damage.\n"+
	"prop_dynamic_override is a prototyping entity only. It will allow the use of models designed to be used as prop_physics."
[
	health(integer) : "Health" : 0 : "Number of points of damage to take before breaking.  0 means don't break."	
]

@PointClass wirebox(use_mins, use_maxs) base(prop_dynamic_base) studioprop() = prop_interactable :
	"A prop designed to be interacted with like a button. It has all of the properties of prop_dynamic without having to use an accompanying func_door or func_button."
[
	spawnflags(flags) =
	[
		512 : "[512] +USE interactable" : 1
		1024 : "[1024] Touch interactable" : 0
		2048 : "[2048] Disable interaction commands when locked" : 0
		4096 : "[4096] Radius use" : 0
	]

	Locked(choices) : "Start locked" : 0 : "If set, this prop_interactable will start locked, making it uninteractable." =
	[
		0: "No"
		1: "Yes"
	]
	
	SetCooldown(float) : "Cooldown" : "1.0" : "The amount of time after this prop_interactable is used before it can be interacted with again. This is always based on when the prop_interactable was pressed, disregarding any active In Sequence, but an optional Out Sequence will play after the cooldown is over. It is also used when the prop_interactable is locked. Set to -1 to have an infinite cooldown when pressed while unlocked."
	
	PressedSound(sound) : "Pressed Sound" : "" : "The sound to play when the button is successfully pressed."
	LockedSound(sound) : "Locked Sound" : "" : "The sound to play when the button is interacted with while locked."
	InSequence(string) : "In Sequence" : "" : "Optional sequence to play when the button is pressed, representing a button going 'in'."
	OutSequence(string) : "Out Sequence" : "" : "Optional sequence to play after the button was interacted with and the cooldown is finished, representing a button coming back 'out' after an 'in' animation."
	LockedSequence(string) : "Locked Sequence" : "" : "Optional sequence to play when the prop_interactable is interacted with while locked."
	
	use_mins(vector) : "+USE Mins" : "-0 -0 -0" : "Optional box for only permitting +USE interactions within. The prop_interactable should not change its angles while this is used."
	use_maxs(vector) : "+USE Maxs" : "0 0 0" : "Optional box for only permitting +USE interactions within. The prop_interactable should not change its angles while this is used."
	
	// Inputs
	input Lock(void) : "Locks this prop_interactable, making it uninteractable."
	input Unlock(void) : "Unlocks this prop_interactable, making it interactable."
	input Press(void) : "Presses this prop_interactable as if someone interacted with it."
	
	input EnableUseInteraction(void) : "Enables use interaction if it was disabled before."
	input DisableUseInteraction(void) : "Disables use interaction if it was enabled before."
	input EnableTouchInteraction(void) : "Enables touch interaction if it was disabled before."
	input DisableTouchInteraction(void) : "Disables touch interaction if it was enabled before."
	input StartIgnoringCommandsWhenLocked(void) : "Starts ignoring commands when this prop_interactable is locked."
	input StopIgnoringCommandsWhenLocked(void) : "Stops ignoring commands when this prop_interactable is locked."
	input EnableRadiusInteract(void) : "Enables radius use."
	input DisableRadiusInteract(void) : "Disables radius use."

	// Outputs
	output OnPressed(void) : "Fired whenever the prop is interacted with."
	output OnLockedUse(void) : "Fired whenever the button is interacted with while locked."
	output OnIn(void) : "Fired whenever the prop completes its 'In' animation."
	output OnOut(void) : "Fired whenever the prop completes its 'Out' animation."
]

@BaseClass base(Targetname, Global, Angles, Studiomodel, BreakableProp, RenderFields, DXLevelChoice, BaseFadeProp) = BasePropPhysics
[ 
	spawnflags(flags) = 
	[
		1 : "[1] Start Asleep" : 0
		2 : "[2] Don't take physics damage" : 0
		4 : "[4] Debris - Don't collide with the player or other debris" : 0
		8 : "[8] Motion Disabled" : 0
		64 : "[64] Enable motion on Physcannon grab" : 0
		128 : "[128] Not affected by rotor wash" : 0
		256 : "[256] Generate output on +USE " : 1
		512 : "[512] Prevent pickup" : 0
		1024: "[1024] Prevent motion enable on player bump" : 0
		4096: "[4096] Debris with trigger interaction" : 0
		8192: "[8192] Force server-side (Multiplayer only)" : 0
		16384: "[16384] Radius pickup (easier to pickup)" : 0
		1048576: "[1048576] Physgun can ALWAYS pick up. No matter what." : 0
		2097152: "[2097152] No collisions" : 0
		8388608: "[8388608] Zombies can't swat" : 0
	]
	
	minhealthdmg(integer) : "Min Damage to Hurt" : 0 : "The prop will ignore any damage events if the damage is less than this amount."
	shadowcastdist(integer) : "Shadow Cast Distance" : 0 : "Use this to override how far this object casts shadows. 0 = default distance."
	physdamagescale(float) : "Physics Impact Damage Scale" : "0.1" : "Scales damage energy when this object is hit by a physics object. NOTE: 0 means this feature is disabled for backwards compatibility.\nSet to 1.0 for materials as strong as flesh, smaller numbers indicate stronger materials."
	Damagetype(choices) : "Impact damage type" : 0 =
	[
		0: "Blunt"
		1: "Sharp"
	]

	nodamageforces(choices) : "Damaging it Doesn't Push It" : 0 : "Used to determine whether or not damage should cause the brush to move." =
	[
		0: "No"
		1: "Yes"
	]

	inertiaScale(float) : "Scale Factor For Inertia" : "1.0" : "Scales the angular mass of an object. Used to hack angular damage and collision response."
	massScale(float) : "Mass Scale" : "0" : "A scale multiplier for the object's mass."
	overridescript(string) : "Override Parameters" : "" : "A list of physics key/value pairs that are usually in a physics prop .qc file. Format is 'key,value,key,value,etc'."
	damagetoenablemotion(integer) : "Health Level to Override Motion" : 0 : "If specified, this object will start motion disabled. Once its health has dropped below this specified amount, it will enable motion."
	forcetoenablemotion(float) : "Physics Impact Force to Override Motion" : 0 : "If specified, this object will start motion disabled. Any impact that imparts a force greater than this value on the physbox will enable motion."
	
	puntsound(sound) : "Sound to make when punted"

	// Inputs
	input Wake(void) : "Wake up this physics object, if it is sleeping."
	input Sleep(void) : "Put this physics object to sleep. It will wake if given the Wake input, or if force is applied to it. Note that physics objects go to sleep automatically after coming to rest for a while, so you don't really need to use this."
	input EnableMotion(void) : "Enable physics motion/collision response."
	input DisableMotion(void) : "Disable physics motion/collision response."
	input EnableMotionKeepVelocity(void) : "Enable physics motion/collision response (Keeps velocity)."
	input DisableMotionKeepVelocity(void) : "Disable physics motion/collision response (Keeps velocity)."
	input DisableFloating(void) : "Disable fluid/floating simulation to reduce cost."
	input SetBodyGroup(integer) : "Set this prop's body group (from 0 - n)."
	input physdamagescale(float) : "Set the Physics Impact Damage Scale for this character. NOTE: 0 means this feature is disabled for backwards compatibility."
	input EnableDamageForces(void) : "Damaging the entity applies physics forces to it."
	input DisableDamageForces(void) : "Damaging the entity does *not* apply physics forces to it."
	input EnablePuntSound(void) : "Allow this prop to play its own sound when punted"
	input DisablePuntSound(void) : "Prevent this prop from playing its own sound when punted"
	input SetDebris(bool) : "Sets whether this prop is debris."

	// Outputs
	output OnMotionEnabled(void) : "Fired when motion is enabled on this prop, either via 'Health Level to Override Motion' or from the EnableMotion input."
	output OnAwakened(void) : "Fired when this entity becomes awake (collision/force is applied to it while it's asleep)."
	output OnPhysGunPickup(void) : "Fired when the player picks up the prop with the physcannon or +USE."
	output OnPhysGunPunt(void) : "Fired when a player punts this object with the physgun."
	output OnPhysGunOnlyPickup(void) : "Fired when a player picks this object up WITH THE PHYSGUN. +USE pickups do not fire this output."
	output OnPhysGunDrop(void) : "Fired when the player drops the prop with the physcannon or USE."
	output OnPlayerUse(void) : "Fired when the player tries to +USE the prop. This output will fire only if the Generate output on +USE spawnflag is set."
	output OnPlayerPickup(void) : "Fired whenever the player picks up this prop (with the physcannon or with +USE)."
	output OnOutOfWorld(void) : "Fired whenever the prop is out of the allowed world bounds."
]

@PointClass base(BasePropPhysics) studioprop() sphere(fademindist) sphere(fademaxdist) = prop_physics_override :
	"A prop that physically simulates as a single rigid body. It can be constrained to other physics objects using hinges "+
	"or other constraints. It can also be configured to break when it takes enough damage. Props not meant to be used with prop_physics (dynamic or static props) can be used with this and it can also override health or interactions."
[
	health(integer) : "Health" : 0 : "Number of points of damage to take before breaking.  0 means don't break. Use -1 to use default health, which could be 0 depending on the model."
	
	InitialInteractions(choices) : "Interaction Override" : "" : "Overrides this prop's default interactions. If you want to combine them, enter each number with a space or comma in between. (e.g. '1 5 7')" =
	[
		"": "None"
		"0": "0 : When punted: Stick to world (sawblades)"
		"1": "1 : When punted: Break on impact (explosive barrels)"
		"2": "2 : When punted: Paint surfaces (paint cans)"
		"3": "3 : When punted: Impale (harpoons)"
		"4": "4 : When punted: Don't spin"
		"5": "5 : When punted: Spin on Z axis (sawblades, propellers)"
		"6": "6 : When broken: Gas explosion (propane tanks, gas cans)"
		"7": "7 : When punted: No damage on impact"
		"8": "8 : Fire: Flammable"
		"9": "9 : Fire: Explosive resistant (doesn't take damage from nearby explosions, only ignites, used in explosive barrels)"
		"10": "10 : Fire: Ignite on half health (explosive barrels)"
		//"11": "11 : Flare" // This is what prop_flare is for
		"12": "12 : Allow player to hold directly overhead"
	]
	
	preferredcarryangles(angle) : "Preferred Player-carry Angles" : "0" : "The angle which the object should orient to when the player picks it up with the physgun or +USE. Overrides the prop's own QC carry angles if it has any. '0' doesn't override the carry angles."
	
	// Inputs
	input Ignite(void) : "Ignite, burst into flames."
	input IgniteLifetime(float) : "Ignite, with a parameter lifetime."
	input IgniteNumHitboxFires(integer) : "Ignite, with a parameternumber of hitbox fires."
	input IgniteHitboxFireScale(float) : "Ignite, with a parameter hitbox fire scale."
]

@PointClass base(BasePropPhysics) studioprop() sphere(fademindist) sphere(fademaxdist) = prop_physics :
	"A prop that physically simulates as a single rigid body. It can be constrained to other physics objects using hinges "+
	"or other constraints. It can also be configured to break when it takes enough damage. "+
	"Note that the health of the object will be overridden by the health inside the model, to ensure consistent health game-wide. "+
	"If the model used by the prop is configured to be used as a prop_dynamic (i.e. it should not be physically simulated) then it CANNOT be "+
	"used as a prop_physics. Upon level load it will display a warning in the console and remove itself. Use a prop_dynamic instead."
[
	// Inputs
	input Ignite(void) : "Ignite, burst into flames."
	input IgniteLifetime(float) : "Ignite, with a parameter lifetime."
	input IgniteNumHitboxFires(integer) : "Ignite, with a parameternumber of hitbox fires."
	input IgniteHitboxFireScale(float) : "Ignite, with a parameter hitbox fire scale."
]

@PointClass base(prop_physics) studioprop() sphere(fademindist) sphere(fademaxdist) = prop_physics_multiplayer :
	"This class is the same as prop_physics, except the runtime collisions use a more bouncy method that avoids " +
	"the prediction errors normal physics objects get."
[
	physicsmode(choices) : "Physics Mode" : 0 =
	[
		0: "Auto Detect"
		1: "Solid, Server-side"
		2: "Non-Solid, Server-side"
		3: "Non-Solid, Client-side"
	]
]

@PointClass base(BasePropPhysics, RenderFields) studioprop() sphere(radius) = prop_sphere : "Creates a perfect sphere."
[
	radius(float) : "Radius" : 12 : ""
]

@PointClass base(Angles, Targetname, Studiomodel, DXLevelChoice, BaseFadeProp, EnableDisable, RenderFields) sphere(fademindist) sphere(fademaxdist) studioprop() = prop_ragdoll :
	"A prop that physically simulates and can be articulated with internal joints. The joint constraints are part of the physics model."
[
	spawnflags(flags) = 
	[
		4 : "[4] Debris - Don't collide with the player or other debris" : 1
		8192 : "[8192] Allow Dissolve" : 0
		16384 : "[16384] Motion Disabled" : 0
		32768 : "[32768] Allow stretch" : 0
		65536 : "[65536] Start asleep" : 0
		131072 : "[131072] Fixed constraints (make statue)" : 0
	]
	angleOverride(string) : "Override Animation" : "" : "Filled in by the engine via wc_update_entity, do not edit by hand except to clear."

	input StartRagdollBoogie(float) : "Begins ragdoll boogie effect. Parameter override = number of seconds to boogie."
	input Wake(void) : "Wakes up this physics object, if it is sleeping."
	input Sleep(void) : "Puts this physics object to sleep. It will wake if given the Wake input, or if force is applied to it. Note that physics objects go to sleep automatically after coming to rest for a while, so you don't really need to use this."
	input EnableMotion(void) : "Enable physics motion/collision response."
	input DisableMotion(void) : "Disable physics motion/collision response."
	input FadeAndRemove(float) : "Fade out then remove (kill) self. Parameter override = duration of fade"
]

@PointClass base(prop_dynamic_base) studioprop() = prop_dynamic_ornament :
	"A way to attach one studio model to another as an ornament. It will render in the way that player/NPC weapons render."
[
	solid(choices) : "Collisions" : 0 =
	[
		0: "Not Solid"
	]	

	InitialOwner(target_destination) : "Target Entity" : : "Name of the entity that this ornament should attach to, at startup."
	
	// Inputs
	input SetAttached(target_destination) : "Attach the ornament to a different entity. Parameter should be the name of entity to attach to."
	input Detach(void) : "Detach from the Target Entity and become invisible. The ornament can be re-attached with the SetAttached input."
]

@PointClass base(Targetname, Angles, Studiomodel) studioprop() = simple_physics_prop :
	"A simple physics prop with no unique properties. Model-based entities converted by phys_convert are turned into this entity. See prop_physics for more options."
[
	spawnflags(flags) = 
	[
		1 : "[1] Start Asleep" : 0
		4 : "[4] Debris - Don't collide with the player or other debris" : 0
	]
]

@SolidClass base(Targetname) = simple_physics_brush :
	"A simple physics brush with no unique properties. Brush-based entities converted by phys_convert are turned into this entity. See func_physbox for more options."
[
	spawnflags(flags) =
	[
		4096  : "[4096] Start Asleep" : 0
		16384 : "[16384] Debris - Don't collide with the player or other debris" : 0
	]
]

//-------------------------------------------------------------------------
//
// Solid Entities
//
//-------------------------------------------------------------------------

@SolidClass base(Targetname) color(0 255 255) = func_areaportal :
	"A portal brush used to manage visibility in maps. Portals define areas, which are spaces " +
	"that are connected in the map. Both sides of a portal cannot touch the same area, for example, a " +
	"doughnut shaped map would require at least two portals to divide the map into two areas. A linear map " +
	"could be divided into two areas with a single area portal."
[
	target(target_destination) : "Name of Linked Door" : : "(Optional) The name of a door whose open/closed state controls the on/off state of this area portal."
	StartOpen(choices) : "Initial State" : 1 =
	[
		0 : "Closed"
		1 : "Open"
	]

	PortalVersion(integer)	readonly	: "Portal Version"      : 1  : "(Don't change). Differentiates between shipping HL2 maps and maps using new engine features."

	// Inputs
	input Open(void) : "Open the portal. When the portal is open is can be seen through."
	input Close(void) : "Close the portal. When the portal is closed it cannot be seen through."
	input Toggle(void) : "Toggle the open/closed state of the portal."
]

@SolidClass base(func_areaportal) color(0 255 255) = func_areaportal_oneway :	"An areaportal that is only open when viewed from one direction."
[
	origin_(origin) readonly : "Origin" : : "Point from which the areaportal's location is determined (they are a special case and cannot use the normal value). Read-only."
	group(string) : "One-way group" : : "Optimisation: oneway portals in the same group share a single closed/open state. Use this, for example, on walls full of one-way windows."
	onewayfacing(angle) : "Open direction" : "0 0 0" : "The portal will be open when the player is within 90 degrees of this direction."
	avoidpop(choices) : "Avoid latency pop" : 0 : "Enable this if it becomes noticeable that the portal stays closed momentarily after the player walks past it. The portal will open 80 units in advance." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	input DisableOneWay(void) : "Disable the one-way behaviour of the portal."
	input EnableOneWay(void) : "Enable the one-way behaviour of the portal."
	input ToggleOneWay(void) : "Toggle the one-way behaviour of the portal."
	input InvertOneWay(void) : "Flip the one-way direction."
]

@SolidClass base(Targetname) color(0 255 255) = func_occluder :
	"A occluder brush used to manage dynamic visibility in maps. Occluders are used to dynamically " +
	"determine what things are behind them, to prevent trying to draw them at all."
[
	StartActive(choices) : "Initial State" : 1 =
	[
		0 : "Inactive"
		1 : "Active"
	]

	// Inputs
	input Deactivate(void) : "Deactivate the occluder, When inactive, it can be seen through."
	input Activate(void) : "Activate the occluder. When active, it cannot be seen through."
	input Toggle(void) : "Toggle the active/inactive state of the occluder."
]

@SolidClass base(BreakableBrush, Origin, RenderFields, Shadow) = func_breakable : 
	"A brush entity that can be broken from damage, or an input." 
[
	minhealthdmg(integer) : "Min Damage to Hurt" : 0 : "The prop will ignore any damage events if the damage is less than this amount."

	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
	physdamagescale(float) : "Physics Impact Damage Scale" : "1.0" : "Scales damage energy when this object is hit by a physics object. NOTE: 0 means this feature is disabled for backwards compatibility.\nSet to 1.0 for materials as strong as flesh, smaller numbers indicate stronger materials."
]

@SolidClass quadbounds() base(BreakableBrush, RenderFields, Shadow) = func_breakable_surf : 
	"A breakable surface, for partially breakable glass / tile / etc.  All faces but the desired visible one must be marked as NODRAW and that" +
	"face must be 4 sided.  The material applied to the visible face must be set up to be breakable." 
[
	spawnflags(Flags) = 
	[
		1 : "[1] Physics damage decals" : 0
		2 : "[2] Take damage from held objects" : 0
		4 : "[4] Play break sound" : 0
	]
	health(integer) : "Health" : 5 : "The amount of damage the surface takes before breaking."
	fragility(integer) : "Fragility" : 100 : "If the 'Surface Type' is set to Glass, this value sets how fragile the glass pieces are after the surface has been broken."
	surfacetype(choices) : "Surface Type" : 0 = 
	[
		0 : "Glass"
		1 : "Tile"
	]

	// Inputs
	input Shatter(vector) : "Shatter the window. Input a vector. First two coordinates are the X,Y center of the shattering (as values from from 0-1). The third coordinate is the radius of the shatter, in units."
]

@SolidClass base(Targetname, Parentname, RenderFields, Shadow) = func_conveyor : 
	"Conveyor Belt"			// NEEDHELP
[
	movedir(angle) : "Move Direction (Pitch Yaw Roll)" : "0 0 0" : "The direction conveyor moves."
	spawnflags(flags) =
	[
		1 : "[1] No Push" : 0
		2 : "[2] Not Solid" : 0
	]
	speed(string) : "Conveyor Speed" : "100"
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."

	// Inputs
	input ToggleDirection(void) : "ToggleDirection"
	input SetSpeed(integer) : "SetSpeed"
]

@SolidClass base(DXLevelChoice) color(0 180 0) = func_detail : 
	"An entity that turns its brushes into detail brushes. Detail brushes do NOT contribute to visibility in the PVS. World geometry "+
	"is not clipped to detail brushes, so if you have a small detail clump attached to a wall, the wall won't be cut up by the detail brush."+
	"func_detail is great for high-frequency brush geometry that's visual detail only. It is also ideal for reducing map VIS time."
[
]

@SolidClass color(180 180 0) = func_viscluster : 
	"Any leaves touching this brush will have their vis merged together into a single cluster.  Use multiple func_viscluster entities to reduce vis time"
[
]

@SolidClass base(Targetname, Parentname, Origin, RenderFields, Shadow) = func_illusionary : 
	"Legacy support. Use func_brush instead." 
[
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
]

@SolidClass base(Targetname, Parentname) = func_precipitation : 
	"A brush entity that creates rain and snow inside its volume."
[
	renderamt(integer) : "Density (0-100%)" : 5	: "How dense the precipitation should be. This can be changed later with the 'Alpha' input."
	rendercolor(color255) : "Color (R G B)" : "100 100 100"
	preciptype(choices) : "Precipitation Type" : 0 =	
	[
		0 : "Rain"
		1 : "Snow"
		2 : "Ash"
		3 : "Snowfall"
		4 : "Particle Rain"
		5 : "Particle Ash"
		6 : "Particle Rainstorm"
		7 : "Particle Snow"
	]
	
	spawnflags(flags) =
	[
		1 : "[1] Particle types only: Clamp precipitation to brush bounds" : 1
		2 : "[2] Particle types only: Suppress outer particle (recommended if clamping)" : 1
	]
]

@SolidClass base(func_wall) = func_wall_toggle : 
	"A brush entity that can be toggled on/off. When off, the brush will be non-solid and invisible. Does not cast lightmap shadows." 
[
	spawnflags(flags) =
	[
		1 : "[1] Starts Invisible" : 0
	]

	// Inputs
	input  Toggle(void) : "Toggle the brush on/off. When off, the brush will be non-solid and invisible." 
]


//@SolidClass base(Door) = func_water : 
//	"Liquid"			// NEEDHELP
//[
//	spawnflags(flags) =
//	[
//		1 : "[1] Starts Open" : 0
//		256:"[256] Use Only" : 0
//	]
//	movedir(angle) : "Move Direction (Pitch Yaw Roll)" : "0 0 0" : "The direction the water will move when it is told to 'Open'."
//	WaveHeight(string) : "Wave Height" : "3.0"
//]

@SolidClass base(Targetname, Parentname, RenderFields, Global) = func_guntarget :
	"This is a moving target that moves along a path of path_tracks. It can be shot and killed."
[
	speed(integer) : "Speed (units per second)" : 100 : "The speed at which the target moves along its path."
	target(target_destination) : "First stop target" : : "The name of the first path_track entity in the path that this target should follow."
	health(integer) : "Damage to Take" : 0 : "The amount of damage taken before this target is killed."
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
	
	// Inputs
	input Start(void) : "Start the target moving."
	input Stop(void) : "Stop the target from moving."
	input Toggle(void) : "Toggle the target between moving and stopped."
	
	// Outputs
	output OnDeath(void) : "Fires when the target is killed."
]

@PointClass sphere(max_range) sphere(LoudPanicRange) sphere(QuietPanicRange) = func_fish_pool : "Creates a school of interactive fish that swim near this entity."
[
	model(studio) : "World model" : "models/Junkola.mdl"
	skin(integer) : "Skin" : 0 : "Some models have multiple versions of their textures, called skins. Set this to a number other than 0 to make each fish use that skin instead of the default."
	fish_count(integer) : "Fish Count" : 10 : "Number of Fish in this Pool"
	max_range(float) : "Max Range" : 150 : "How far away a Fish can wander (max 255)"
	
	LoudPanicRange(float) : "Loud Panic Range" : 500 : "How far away an event has to be to make the fish in this pool panic."
	QuietPanicRange(float) : "Quiet Panic Range" : 75 : "How far away a quiet event (a footstep) has to be to make the fish in this pool panic."
	
	// Inputs
	input SpawnFish(void) : "Spawns an additonal fish. This ignores the fish count keyvalue."
	input PanicLoudFromPoint(vector) : "Causes a loud panic event at the specified location vector."
	input PanicQuietFromPoint(vector) : "Causes a quiet panic event at the specified location vector."
	input Skin(integer) : "Changes the fish skin to the specified number."
	
	// Outputs
	output OnSpawnFish(ehandle) : "Fires when a fish is spawned, passing the fish as the activator."
]


//-------------------------------------------------------------------------
//
// Trains and Tracks
//
//-------------------------------------------------------------------------

@BaseClass = PlatSounds 
[
	movesnd(choices) : "Move Sound" : 0 : "The sound played whenever the platform starts moving." = 
	[
		0: "No Sound"
		1: "big elev 1"
		2: "big elev 2"
		3: "tech elev 1"
		4: "tech elev 2"
		5: "tech elev 3"
		6: "freight elev 1"
		7: "freight elev 2"
		8: "heavy elev"
		9: "rack elev"
		10: "rail elev"
		11: "squeek elev"
		12: "odd elev 1"
		13: "odd elev 2"
	]
	stopsnd(choices) : "Stop Sound" : 0 : "The sound played when the platform stops moving." = 
	[
		0: "No Sound"
		1: "big elev stop1"
		2: "big elev stop2"
		3: "freight elev stop"
		4: "heavy elev stop"
		5: "rack stop"
		6: "rail stop"
		7: "squeek stop"
		8: "quick stop"
	]
	volume(string) : "Sound Volume 0.0 - 1.0" : "0.85"
]

@BaseClass base(Targetname, Parentname, RenderFields, Global, PlatSounds) = Trackchange
[
	height(integer) : "Travel Altitude" : 0 : "The vertical height above the track that the train moves. Negative values moves the train below."
	spawnflags(flags) =
	[
		1: "[1] Auto Activate train" : 0
		2: "[2] Relink track" : 0
		8: "[8] Start at Bottom" : 0
		16: "[16] Rotate Only" : 0
		64: "[64] X Axis" : 0
		128: "[128] Y Axis" : 0
	]
	rotation(integer) : "Spin amount" : 0 : "The amount this platform should rotate as it moves, in degrees."
	train(target_destination) : "Train to Switch"			// NEEDHELP
	toptrack(target_destination) : "Top Track"				// NEEDHELP
	bottomtrack(target_destination) : "Bottom Track"		// NEEDHELP
	speed(integer) : "Move/Rotate Speed" : 0				// NEEDHELP
]

@BaseClass base(Targetname, Parentname, Origin, RenderFields, Global, Shadow) = BaseTrain
[
	spawnflags(flags) =
	[
		1 : "[1] No Pitch (X-rot)" : 0
		2 : "[2] No User Control" : 0
		8 : "[8] Passable" : 0
		16 : "[16] Fixed Orientation" : 0
		128 : "[128] Rideable Train (HL1 Train)" : 0
		256 : "[256] Use max speed for pitch shifting move sound" : 0
		512 : "[512] Is unblockable by player" : 0
	]
	
	target(target_destination) : "First Stop Target" : "" : "The name of the first path_track in the train's path. The train " +
		"will spawn at this path_track. It will also turn to face direction indicated by the 'Orientation Type' setting."
	
	startspeed(integer) : "Max Speed (units / second)" : 100 : "The maximum speed that this train can move. "+
		"Any speeds applied to this train, such as by path_tracks or SetSpeed inputs, will be clipped to this maximum value."
	
	speed(integer) : "Initial Speed (units / second)" : 0 : "The speed that the train will move at after it spawns, 0 = stopped."
	
	velocitytype(choices) : "Change Velocity" : 0 : "The method through which this train changes its velocity as it moves along the path." =
	[
		0 : "Instantaneously"
		1 : "Linear blend"
		2 : "Ease in/ease out"
	]
	
	orientationtype(choices) : "Change angles" : 1 : "The method through which this train changes its orientation as it moves along the path." =
	[
		0 : "Never (fixed orientation)"
		1 : "Near path_tracks"
		2 : "Linear blend"
		3 : "Ease in/ease out"
	]
	
	wheels(integer) : "Distance Between the Wheels" : 50 : "Used for turning and stopping."
	height(integer) : "Height above track" : 4 : "The height above the track that this train moves."
	bank(string) : "Bank Angle on Turns" : "0"			// NEEDHELP
	
	dmg(integer) : "Damage on Crush" : 0 : "The amount of damage this train does to entities that block it."
	
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."

	MoveSound(sound) : "Move Sound" : "" : "A sound that is played (and looped) while the train is moving."
	MovePingSound(sound) : "Move Ping Sound" : "" : "A sound that is played more frequently as the train speeds up."
	StartSound(sound) : "Start Sound" : "" : "A sound played when the train starts moving."
	StopSound(sound) : "Stop Sound" : "" : "A sound played when the train stops moving."
	volume(integer) : "Volume (10 = loudest)" : 10
	MoveSoundMinPitch(integer) : "Min pitch (1-255, > 100 = higher)" : 60 : "The sound pitch value that the train will approach as it comes to a stop."
	MoveSoundMaxPitch(integer) : "Max pitch (1-255, > 100 = higher)" : 200 : "The sound pitch value that the train will approach as it approaches its "+
		"max speed (or 1000 units/second if the 'Use max speed for pitch shifting move sound' flag is not set)."
	MoveSoundMinTime(float) : "Min move sound interval" : 0 : "Minimum interval at which to play the move ping sound."
	MoveSoundMaxTime(float) : "Max move sound interval" : 0 : "Maximum interval at which to play the move ping sound."

	// Inputs
	input SetSpeed(float) : "Set the speed of the train, as a ratio of max speed [0, 1]"
	input SetSpeedDir(float) : "Set the speed of the train, as a ratio of max speed. Negative values reverse the direction [-1, 1]"
	input SetSpeedReal(float) : "Set the speed of the train. Must be a positive value from 0 to max speed."
	input Stop(void) : "Stop the train."
	input StartForward(void) : "Start the train moving forward."
	input StartBackward(void) : "Start the train moving backward."
	input Resume(void) : "Resume the train moving in the current direction after it was stopped via the 'Stop' or 'Toggle' input."
	input Reverse(void) : "Reverse the direction of the train."
	input Toggle(void) : "Toggle the train between start and stop."
]

@SolidClass base(Trackchange) = func_trackautochange : 
	"An entity that works as a rotating/moving platform that will carry a train to a new track. "+
	"It must be larger in X-Y planar area than the train, since it must contain the train within "+
	"these dimensions in order to operate when the train is near it."
[
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
	
	// Inputs
	input Trigger(void) : "Trigger the track change."
]

@SolidClass base(Trackchange) = func_trackchange : 
	"An entity that works as a rotating/moving platform that will carry a train to a new track. "+
	"It must be larger in X-Y planar area than the train, since it must contain the train within "+
	"these dimensions in order to operate when the train is near it."
[
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
]

@SolidClass base(BaseTrain) = func_tracktrain :
	"A moving platform that the player can ride. It follows a path of path_track entities.\n" +
	"NOTE: Build your train so that the front of the train is facing down the X axis. " +
	"When it spawns it will automatically rotate to face the next path_track on the path."
[

	// Outputs
	output OnStart(void) : "Fired when the train starts moving in either direction."
	output OnNext(string) : "Fires when this train picks a new point to move towards (and just after OnStart)."
	
	ManualSpeedChanges(choices) : "Manual Train Speed" : 0 : "Train Speed is controlled through IO, handles accel, decel times." =
	[
		0 : "Off"
		1 : "On"
	]
	
	ManualAccelSpeed(float) : "Manual Accel Speed" : 0 : "Units per second to accelerate to target speed."
	ManualDecelSpeed(float) : "Manual Decel Speed" : 0 : "Units per second to decelerate to target speed."
	
	input SetSpeedDirAccel(float) : "Accel/Decel to the specified speed, as a ratio of max speed. Negative values reverse the direction [-1, 1]"
	input TeleportToPathTrack(target_destination) : "Teleport train to the designated path track."
	input SetSpeedForwardModifier(float) : "Applies the given modifier to all forward speeds. [0, 1]"
]

@SolidClass base(BaseTrain) = func_tanktrain :
	"A moving train that follows a path of path_track entities, shoots at the player, and can be killed.\n" + 
	"NOTE: Build your train so that the front of the train is facing down the X axis. " +
	"When it spawns it will automatically rotate to face the next path_track on the path."
[
	health(integer) : "Health" : 100
	
	// Outputs
	output OnDeath(void) : "Fired when the tank is killed."
]

@SolidClass base(Parentname,Global) = func_traincontrols :
	"When used by the player, this entity overrides the player's controls to let them drive a train."
[
	target(target_destination) : "Train Name" : : "The target train to control when the player uses these controls."
]

@PointClass base(Targetname) iconsprite("editor/tanktrain_aitarget.vmt") = tanktrain_aitarget : 
	"An entity that changes the target of a tanktrain_ai entity."
[
	target(target_destination) : "Tank AI Entity" : : "The tanktrain_ai entity to change the target of."
	newtarget(target_destination) : "New Target Entity" : : "The entity to tell the tanktrain_ai to target."
]

@PointClass base(Targetname) iconsprite("editor/tanktrain_ai.vmt") = tanktrain_ai : 
	"Train chase AI"			// NEEDHELP
[
	target(target_destination) : "Train Name"
	startsound(sound) : "Start Moving Sound" : "vehicles/diesel_start1.wav"
	enginesound(sound) : "Engine Loop Sound" : "vehicles/diesel_turbo_loop1.wav"
	movementsound(sound) : "Vehicle Movement Sound" : "vehicles/tank_treads_loop1.wav"
]

@PointClass base(Targetname, Parentname, Angles) cylinder(255 255 255, targetname, target, radius, targetname, targetname, radius) color(255 192 0) size(16 16 16) = path_track : 
	"An entity used to build paths for other entities to follow. Each path_track is a node on the path, each holding the name of the next path_track in the path."
[
	spawnflags(Flags) =
	[
		1:  "[1] Disabled" : 0
		2:  "[2] Fire once" : 0
		4:  "[4] Branch Reverse" : 0
		8:  "[8] Disable train" : 0
		16: "[16] Teleport to THIS path track" : 0
		32: "[32] Part of an uphill path" : 0
		64: "[64] Part of a downhill path" : 0
	]
	
	target(target_destination) : "Next Stop Target" : : "The next path_track in the path."
	altpath(target_destination) : "Branch Path" : : "An alternative path_track to be the next node in the path. Useful for making branching paths. Use the ToggleAlternatePath / EnableAlternatePath inputs to make the alternative path active."
	speed(float) : "New Train Speed" : 0 : "When the train reaches this path_track, it will set its speed to this speed. "+
		"This speed must be a positive value that is less than the train's max speed. A value of 0 will cause no change in the train's speed."
	radius(float) : "Path radius" : 0 : "Used by NPCs who follow track paths (attack chopper/gunship). This tells them the maximum distance they're allowed to be from the path at this node."

	orientationtype(choices) : "Orientation Type" : 1 : "The way that the path follower faces as it moves through this path track." =
	[
		0 : "No change"
		1 : "Face direction of motion"
		2 : "Face this path_track's angles"
	]

	// Inputs
	input ToggleAlternatePath(void) : "Cause the track to toggle to/from its alternate path."
	input EnableAlternatePath(void) : "Enable the alternate path of the track."
	input DisableAlternatePath(void) : "Disable the alternate path of the track."

	input TogglePath(void) : "Cause the track to toggle on/off/"
	input EnablePath(void) : "Enable the track."
	input DisablePath(void) : "Disable the track."

	// Outputs
	output OnPass(void) : "Fired when any entity following this path passes this path_track node."
	output OnTeleport(void)  : "Fired when any entity following this path teleports directly to this path_track node."
]


//-------------------------------------------------------------------------
//
// Test Entities
//
//-------------------------------------------------------------------------
@PointClass base(Angles) size(-16 -16 -16, 16 16 16) color(255 255 255) = test_traceline : 
	"A debugging tool for testing tracelines."
[
]


//-------------------------------------------------------------------------
//
// Triggers
//
//-------------------------------------------------------------------------

@SolidClass base(Targetname) = trigger_autosave : 
	"A trigger volume that autosaves when the player touches it."
[
	master(target_destination) : "Master" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."
	NewLevelUnit(choices) : "Force New Level Unit" : 0 : "If set, the save will discard any savedata from previous levels, for the purpose of keeping savegame filesizes down. Can only be safely used if there is no way for the player to return to previous levels." =
	[
		0 : "No"
		1 : "Yes"
	]
	DangerousTimer(float) : "Dangerous Timer" : 0 : "The number of seconds the player must survive before this autosave takes effect."
	
	MinimumHitPoints(integer): "Minumum Hit Points" : 0 : "Don't save dangerous when player has less than this many hitpoints."
]

@SolidClass base(EnableDisable) = trigger_changelevel : 
	"An entity that triggers a level change.\n" +
	"Place an info_landmark in both maps that marks the 'same' location in each map.\n"+
	"TIPS & TRICKS: To fire events in the next level, use the OnLevelChange output to turn on "+
	"an env_global in the current level.  Create a logic_auto in the next level that checks "+
	"for the state set by the env_global.\n\n"+
	"To control which entities go through the level transition, create one or more trigger_transitions and "+
	"give them the same name as the landmark. Any entities within the trigger_transition(s) will go to the next map."
[
	targetname(target_source) : "Name"
	map(string) : "New Map Name"
	landmark(target_destination) : "Landmark Name"
	spawnflags(flags) =
	[
		2: "[2] Disable Touch" : 0
		4: "[4] To Previous Chapter" : 0
	]
	
	// Inputs
	input ChangeLevel(void) : "Cause the level change. Use this when triggering the level change with a button, etc."
	
	// Outputs
	output OnChangeLevel(void) : "Fired when the level changes."
]

@SolidClass base(Trigger) = trigger_gravity : 
	"A trigger volume that changes the gravity on any entity that touches it."
[
	gravity(integer) : "Gravity (0-1)" : 1
]

@SolidClass base(Trigger) = trigger_playermovement : 
	"An entity that can be used to disable player's automatic ducking/unducking when jumping."
[
	spawnflags(flags) = 
	[
		128: "[128] Disable auto player movement" : 1
		2048: "[2048] Auto-duck while in trigger" : 0
		4096: "[4096] Auto-walk while in trigger" : 0
		8192: "[8192] Disable jump while in trigger" : 0
	]
]


// NEEDHELP
@SolidClass base(Trigger) = trigger_soundscape : 
	"Soundscape trigger. " +
	"It is not necessary to create outputs for this trigger. It automatically will trigger the " +
	"soundscape referred to by its 'Soundscape' property."
[
	soundscape(target_source) : "Soundscape" 
]

@SolidClass base(Trigger, Targetname, DamageTypes) = trigger_hurt :
	"A trigger volume that damages entities that touch it."
[
	//master(target_destination) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."
	damage(integer) : "Damage" : 10 : "The amount of damage done to entities that touch this trigger. The damage is done every half-second. See also 'Damage Model' for extra details on how damage can be dealt."
	damagecap(integer) : "Damage Cap" : 20 : "Maximum damage dealt per second. This field is only used if you select the Doubling w/Forgiveness damage model, via the spawnflag."

	damagemodel(choices) : "Damage Model" : 0 : "How damage is dealt. Normal always does the specified amount of damage each half second. Doubling starts with the specified amount and doubles it each time it hurts the toucher. Forgiveness means that if the toucher gets out of the trigger the damage will reset to the specified value. Good for making triggers that are deadly over time without having to cause massive damage on each touch." =
	[
		0 : "Normal"
		1 : "Doubling w/forgiveness"
	]
	
	nodmgforce(choices) : "Zero Damage Force" : 0 : "Should the damaged entity receive no physics force from this trigger." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	hurtrate(float) : "Hurt Rate" : "0.5" : "Touchers will be hurt every X seconds while in this trigger_hurt."
	
	// Inputs
	input SetDamage(float) : "Set a new amount of damage for this trigger."
	
	// Outputs
	output OnHurt(void) : "Fired whenever this trigger hurts something other than a player."
	output OnHurtPlayer(void) : "Fired whenever this trigger hurts a player."
]

@SolidClass base(Trigger, Targetname) = trigger_remove : 
	"A trigger volume that removes any entities that touch it. Be careful, removing some entities can cause instability. "+
	"This is not the same as killing entities. i.e. NPCs removed in this manner will not fire their OnKilled outputs."
[
	// Outputs
	output OnRemove(void) : "Fired whenever an entity is removed."
]

@SolidClass base(Trigger) = trigger_multiple :
	"A trigger volume that can be triggered multiple times."
[
	wait(integer) : "Delay Before Reset" : 1 : "Amount of time, in seconds, after the trigger_multiple has triggered before it can be triggered again. If set to -1, it will never trigger again (in which case you should just use a trigger_once)."

	// Touch test stuff is now on all trigger entities.
	 
	// Outputs
	output OnTrigger(void) : "Fired whenever the trigger is activated."
]

@SolidClass base(TriggerOnce) = trigger_once :
	"A trigger volume that removes itself after it is triggered once."
[
	// Outputs
	output OnTrigger(void) : "Fired whenever the trigger is activated."
]

@SolidClass base(Trigger) = trigger_look :
	"An entity used to trigger something when the player looks at something. It fires 'OnTrigger' when the player "+
	"looks at a target entity for the given amount of time, while within the trigger volume. If the player leaves "+
	"the trigger or looks away from the target entity the clock resets. If the 'Use Velocity instead of facing' spawnflag " +
	"is checked, the trigger uses the player's velocity instead of the player's view, so it determines whenever the player "+
	"is moving toward the target entity. Useful for triggering when players are driving a vehicle at something."+
	"NOTE: Only designed for single-player game. "
[
	spawnflags(flags) = 
	[ 
		128: "[128] Fire Once" : 1 
		256: "[256] Use Velocity instead of facing" : 0
	]
	
	target(target_destination) : "Look Target" : : "The name of the entity to be looked at."
	LookTime(string) : "LookTime" : "0.5" : "The time, in seconds, that the player must look the target before firing the output. Resets if player leaves trigger, or looks outside the Field of View threshold."
	FieldOfView(string) : "FieldOfView" : "0.9" : "How close the player has to be looking at the target. 1.0 = straight ahead\n 0.0 = +/- 90 degrees\n -1.0 = all directions)."
	Timeout(float) : "Timeout" : "0" : "The time, in seconds, to wait after player enters the trigger before firing the OnTimeout output, 0 = never."
	
	UseLOS(choices) : "Require LOS" : 0 : "If enabled, the player must have full LOS to the target entity in order to count as ''looking''." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	LookEntityCaller(choices) : "Use look entity as caller" : 0 : "When firing OnTrigger, use the triggered look entity as the output's caller. Useful for when multiple look targets exist." =
	[
		0 : "No"
		1 : "Yes"
	]

	// Output
	output OnTrigger(void) : "Fired when the trigger is activated."
	output OnTimeout(void) : "Fired after the timeout interval expires if the player never looked at the target."
]

@SolidClass base(Trigger) = trigger_push : 
	"A trigger volume that pushes entities that touch it."
[
	pushdir(angle) : "Push Direction (Pitch Yaw Roll)" : "0 0 0" : "Angles indicating the direction to push touched entities."

	spawnflags(flags) = 
	[ 
		128: "[128] Once Only" : 0
		256: "[256] Affects Ladders (Half-Life 2)" : 0 
	]

	speed(integer) : "Speed of Push" : 40 : "The speed at which to push entities away, in units / second."
	alternateticksfix(float) : "Scale force for alternate ticks" : "0" : "If nonzero, scale the force by this amount when running with alternate ticks. This fixes problems with an overly large force due to the longer frametime on when running with sv_alternateticks 1."
	
	// Inputs
	input SetSpeed(float) : "Set the speed at which to push entities away."
	input SetPushDir(vector) : "Set the angles indicating the direction to push touched entities."
]

@SolidClass base(Trigger, Angles) = trigger_wind : 
	"A trigger volume that pushes physics objects that touch it."
[
	Speed(integer) : "Speed" : 200   : "The baseline for how hard the wind blows."
	SpeedNoise(integer) : "Speed Noise" : 0 : "Noise added to wind speed +/-"
	DirectionNoise(integer) : "Direction Noise" : 10 : "Noise added to wind direction."
	HoldTime(integer) : "Hold Time" : 0 : "Baseline for how long to wait before changing wind."
	HoldNoise(integer) : "Hold Noise" : 0 : "Noise added to how long to wait before changing wind."

	// Inputs
	input SetSpeed(integer) : "Set the baseline for how hard the wind blows."
]

@SolidClass base(Targetname, Origin, Angles) = trigger_impact : 
	"A trigger volume that can be told to push all physics objects that are inside of it in the direction specified by this trigger's angles.\n"+
	"Also outputs the force at the time of impact for anyone else that wants to use it."
[
	Magnitude(float) : "Magnitude" : 200    : "The strength of the impact. Negative values reverse the direction."
	noise(float) : "Noise" : "0.1" : "The amount of directional noise (0-1). 0 = no noise, 1 = random direction."
	viewkick(float) : "Viewkick" : "0.05" : "The amount to kick player's view if the player is in the trigger.  Proportional to magnitude (0-1)."

	// Inputs
	input Impact(float) : "Fire the impact, pushing all entities within the volume."
	input SetMagnitude(float) : "Set the magnitude of the impact."

	// Outputs
	output ImpactForce(string) : "Fired after an impact. The parameter passed along is the force of the impact that was generated."
]

@SolidClass base(Trigger) = trigger_proximity :
	"Measures the distance of the player within the trigger volume from a given point (and within " +
	"a given radius). The NearestPlayerDistance output will be 0 when the player is at the center point, " +
	"and 1 when the player is at the radius."
[
	measuretarget(target_destination) : "Point to Measure From" : : "The name of a target entity who's origin is the point to measure the player's distance from."
	radius(string) : "Radius to measure within" : 256 : "The radius to which the distance should be mapped. If the player is outside the radius he will be ignored."
	
	// Outputs
	output NearestEntityDistance(integer) : "Fired continuously when entities are touching the trigger volume. The output parameter is the distance from the "+
						"Point to Measure From to the nearest entity that passed the trigger filters. The distance is mapped to the radius distance, "+
						"so it will be 0 when the entity is on the point, and 1 when the entity is at the edge of the radius."
]

@SolidClass base(Trigger) = trigger_teleport : 
	"A trigger volume that teleports entities that touch it. Entities are teleported to the Remote Destination, and have their angles "+
	"set to that of the Remote Destination's. If a Local Destination Landmark is specified, teleported entities are offset from the target "+
	"by their initial offset from the landmark, and their angles are left alone."
[
	target(target_destination) : "Remote Destination" : : "The entity specifying the point to which entities should be teleported."
	landmark(target_destination) : "Local Destination Landmark" : : "If specified, then teleported entities are offset from the target by their initial offset from the landmark."
	spawnflags(flags) =
	[
		32: "[32] Preserve angles even when a local landmark is not specified" : 0
		
		// Reckless...
		64: "[64] Everything (not including physics debris)" : 0
		512: "[512] Only clients *not* in vehicles" : 0
		1024: "[1024] Physics debris" : 0
		2048: "[2048] Only NPCs in vehicles (respects player ally flag)" : 0
		4096: "[4096] Disallow Bots" : 0
	]
]

@SolidClass base(Trigger) = trigger_teleport_relative : 
	"A trigger volume that teleports entities that touch it to their current position relative to the given offset. "+
	"Their angles stay the same, but velocity is reset. "+
	"Use trigger_teleport for more complicated teleporting operations."
[
	teleportoffset(vector) : "Teleport Offset" : "0 0 0" : "The offset."
]

@SolidClass base(Targetname) = trigger_transition : 
	"A volume that's used to control which entities go through the level transition. Create one or more trigger_transitions and "+
	"give them the same name as the changelevel landmark. Any entities within the trigger_transition(s) will go to the next map."+
	"See trigger_changelevel for more info."
[
]

@SolidClass base(TriggerOnce) = trigger_serverragdoll : 
	"A volume that forces any NPC inside it to create a server side ragdoll instead of a client one."
[
]

@SolidClass base(TriggerOnce) = trigger_fall : 
	"A trigger that causes the player to die the moment they touch the ground as long as they are inside of this volume."
[
	StayLethal(choices) : "Stay Lethal" : 0 : "Causes players who touch this trigger to be marked for death by fall damage even after they leave the volume." =
	[
		0 : "No"
		1 : "Yes"
	]
]





//-------------------------------------------------------------------------
//
// AI
//
//-------------------------------------------------------------------------

@PointClass base(Targetname,ResponseContext,EnableDisable) = ai_speechfilter : 
	"An entity that can be used to control the idle speech patterns of a set of NPCs."
[
	subject(target_destination) : "Subject(s)" : "" : "This is the NPC(s) whose speech we're filtering. May be a targetname or a classname."	

	IdleModifier(float) : "Idle modifier." : "1.0" : "Multiplier to the percentage chance that our NPC(s) will idle speak. Set to 0 to prevent all idle speech."
	NeverSayHello(choices) : "Greet Player?" : 0 : "If set to Yes, our NPC(s) won't greet the player when they first meet him." =
	[
		0 : "Yes"
		1 : "No"
	]

	input SetIdleModifier(float) : "Allows designers to change the idle modifier at runtime"
]

//-------------------------------------------------------------------------
// Water LOD control
//-------------------------------------------------------------------------

@PointClass base(Targetname) iconsprite("editor/waterlodcontrol.vmt") = water_lod_control : 
	"An entity used to control the LOD behavior of any water in the map. If your map has water, this entity is required."
[
	cheapwaterstartdistance(float) : "Start Transition to Cheap Water" : 1000 : "This is the distance from the camera that water will start transitioning to cheap water, in units."
	cheapwaterenddistance(float) : "End Transition to Cheap Water" : 2000 : "This is the distance from the camera that water will finish transitioning to cheap water, in units."

	// Inputs
	input SetCheapWaterStartDistance(float) : "Set the distance that water starts transitioning to cheap water."
	input SetCheapWaterEndDistance(float) : "Set the distance that water finishes transitioning to cheap water."
]


//-------------------------------------------------------------------------
// Used to allow entities to use point_cameras for their materials
//-------------------------------------------------------------------------

@PointClass base(Targetname) = info_camera_link :
	"An entity that can use point_cameras to render images for materials used by entities. "+
	"To author the material, use the special identifier _rt_Camera " +
	"for the $baseTexture (or whatever texture you want, like envmap, etc.) in the .vmt " +
	"then connect the 'target' field to the entity which uses that material, and the 'PointCamera' " +
	"field to the point_camera you want to have appear on that entity's material"
[
	target(target_destination) : "Entity Whose Material Uses _rt_camera"
	PointCamera(target_destination) : "Camera Name" : : "The name of a point_camera entity in the map that the material should be rendered from."
	
	// Inputs
	input SetCamera(target_destination) : "Set the camera to use. The parameter should be the name of a point_camera entity in the map."
]


//-------------------------------------------------------------------------
// Used to listen to events called from code
//-------------------------------------------------------------------------

@PointClass base(Targetname) = logic_eventlistener :
	"An entity that can listen to events fired from code and fire " +
	"an output when it happens."
[
	EventName(string) : "Event Name" : "" : "The name of the event that you want to listen for."
	
	StartDisabled(choices) : "Start Disabled" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	
	//TeamNum(choices) : "Team Number" : -1 : "If set, will only fire its output if the event is generated from someone of the specified team." =
	//[
	//	-1 : "Don't care"
	//	1 : "Team 1"
	//	2 : "Team 2 (ORANGE)"
	//	3 : "Team 3 (BLUE)"
	//]
		
	// Inputs
	input Enable(void) : "Enables this entity."
	input Disable(void) : "Disables this entity."
	input Toggle(void) : "Toggles this entity."
	
	// Outputs
	output OnEventFired(void)  : "Fires when the event has been detected."
]

@PointClass base(logic_eventlistener) = point_event :
	"An entity that can listen to events fired from code and fire " +
	"an output when it happens."
[
	EventName(string) : "Event Name" : "" : "The names of the events that you want to listen for. Separated by colon. (e.g. player_hurt:game_init)"
	
	KeyName01(string) : "Key Name 01" : "" : "A keyvalue name to search for in detected events. If an event contains this key, then this entity will fire its respective OutValue output with the value."
	KeyName02(string) : "Key Name 02" : "" : "A keyvalue name to search for in detected events. If an event contains this key, then this entity will fire its respective OutValue output with the value."
	KeyName03(string) : "Key Name 03" : "" : "A keyvalue name to search for in detected events. If an event contains this key, then this entity will fire its respective OutValue output with the value."
	KeyName04(string) : "Key Name 04" : "" : "A keyvalue name to search for in detected events. If an event contains this key, then this entity will fire its respective OutValue output with the value."
	KeyName05(string) : "Key Name 05" : "" : "A keyvalue name to search for in detected events. If an event contains this key, then this entity will fire its respective OutValue output with the value."
	KeyName06(string) : "Key Name 06" : "" : "A keyvalue name to search for in detected events. If an event contains this key, then this entity will fire its respective OutValue output with the value."
	KeyName07(string) : "Key Name 07" : "" : "A keyvalue name to search for in detected events. If an event contains this key, then this entity will fire its respective OutValue output with the value."
	KeyName08(string) : "Key Name 08" : "" : "A keyvalue name to search for in detected events. If an event contains this key, then this entity will fire its respective OutValue output with the value."
	
	StartDisabled(choices) : "Start Disabled" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	
	//TeamNum(choices) : "Team Number" : -1 : "If set, will only fire its output if the event is generated from someone of the specified team." =
	//[
	//	-1 : "Don't care"
	//	1 : "Team 1"
	//	2 : "Team 2 (ORANGE)"
	//	3 : "Team 3 (BLUE)"
	//]
		
	// Inputs
	input SetAllEvents(string) : "Sets all events using the keyvalue's : format. Pass nothing to clear all events."
	input AddEvent(string) : "Adds an event to this entity."
	
	// Outputs
	output OutEventName(string)  : "Outputs the detected event's name in case this entity is listening for multiple events."
	output OutValue01(string)  : "Passes the value found in its respective keyname when an event is fired."
	output OutValue02(string)  : "Passes the value found in its respective keyname when an event is fired."
	output OutValue03(string)  : "Passes the value found in its respective keyname when an event is fired."
	output OutValue04(string)  : "Passes the value found in its respective keyname when an event is fired."
	output OutValue05(string)  : "Passes the value found in its respective keyname when an event is fired."
	output OutValue06(string)  : "Passes the value found in its respective keyname when an event is fired."
	output OutValue07(string)  : "Passes the value found in its respective keyname when an event is fired."
	output OutValue08(string)  : "Passes the value found in its respective keyname when an event is fired."
]


//-------------------------------------------------------------------------
// Used to allow entities to mimic the motions of other entities
//-------------------------------------------------------------------------

@PointClass base(Targetname) = logic_measure_movement :
	"An entity that can measure the movement of an entity relative to another entity " +
	"and apply that movement to a third entity."
[
	MeasureTarget(target_destination) : "Entity to Measure" : "" : "Entity whose movement you want to measure."
	MeasureReference(target_destination) : "Measure Reference" : "" : "The movement of Entity to Measure will be measured relative to this entity."
	Target(target_destination) : "Entity to Move" : "" : "This entity will be moved to mimic the motions of Entity to Measure."
	TargetReference(target_destination) : "Movement Reference" : "" : "The Entity to Move will move relative to this entity."
	TargetScale(float) : "Movement scale" : "1" : "A scale to *divide* the measured movements by before applying those movements to the Entity to Move. 1 = target entity moves as much as the measured entity, 2 = target entity moves half as far as the measured entity, and 0.5 = target entity moves twice as far as the measured entity."
	ShouldOutputPosition(choices) : "Fire position outputs" : 0 : "Allows OutPosition and OutAngles to be fired with the resulting position while this entity is active. Does not apply to the GetPosition input." =
	[
		0 : "No"
		1 : "Yes"
	]
	MeasureType(choices) : "Measurement Type" : 0 =
	[
		0 : "Position"
		1 : "Eye position"
		2 : "Attachment point"
		//3 : "Aim position"
	]
	
	spawnflags(Flags) = 
	[
		1 : "[1] Ignore X" : 0
		2 : "[2] Ignore Y" : 0
		4 : "[4] Ignore Z" : 0
		8 : "[8] Use 'Ignore' flags for origin instead of angles" : 0
		16 : "[16] Use new teleportation rules (smoother movement)" : 1
		32 : "[32] Don't change target's angles" : 0
	]
	
	MeasureAttachment(string) : "Measurement Attachment" : "" : "Only useful for the ''Attachment point'' measurement type. This attachment should be on the Entity to Measure and measurements will correspond to its position and angles."
	
	// Inputs
	input SetMeasureTarget(target_destination) : "Set the Entity to Measure, whose movement should be measured."
	input SetMeasureReference(target_destination) : "Set the Measure Reference entity."
	input SetTarget(target_destination) : "Set the Entity to Move, which will be moved to mimic the measured entity."
	input SetTargetReference(target_destination) : "Set the Movement Reference entity."
	input SetTargetScale(float) : "Set the scale to divide the measured movements by."
	input SetMeasureType(integer) : "Sets the measurement type."
	input SetMeasureAttachment(string) : "Sets the measurement attachment."
	input ShouldOutputPosition(bool) : "Sets whether we are allowed to fire position outputs while this entity is active."
	input GetPosition(void) : "Initiates a single measurement with the current settings, only firing OutPosition and OutAngles without moving anything. (it doesn't need a target to be available)\n"+
								"This input ignores the 'Fire position outputs' keyvalue and instead repurposes it to modify who the outputs' activator should be.\n"+
								"If 'Fire position outputs' is enabled, the target will be used as the activator if it is available.\n"+
								"If 'Fire position outputs' is disabled, the activator that fired GetPosition will be used instead."
	input Enable(void) : "Enable the logic_measure_movement."
	input Disable(void) : "Disable the logic_measure_movement."
	
	// Outputs
	output OutPosition(vector)  : "Outputs the resulting position when allowed."
	output OutAngles(vector)  : "Outputs the resulting angles when allowed."
]

@PointClass base(logic_measure_movement) = logic_mirror_movement :
	"An entity that can measure the direction of an entity relative to another entity " +
	"and apply the position the entity is looking at to a third entity."
[
	MeasureTarget(target_destination) : "Entity to Measure" : "" : "Entity whose movement you want to measure. (Remote target)"
	MeasureReference(target_destination) : "Measure Reference" : "" : "The movement of Entity to Measure will be mirrored relative to this entity. (Mirror relative)"
	Target(target_destination) : "Entity to Move" : "" : "This entity will be mirrored across the motions of Entity to Measure. (Movement target)"
	TargetReference(target_destination) : "Movement Reference" : "" : "The Entity to Move will be mirrored relative to this entity. (Mirror target)"
]

@PointClass base(logic_measure_movement, Angles) sphere(TraceDistance) = logic_measure_direction :
	"An entity that can measure the direction of an entity relative to another entity " +
	"and apply the position the entity is looking at to a third entity."
[
	MeasureTarget(target_destination) : "Entity to Measure" : "" : "Entity whose direction you want to measure."
	MeasureReference(target_destination) : "Measure Reference" : "" : "The direction of Entity to Measure will be measured from this entity."
	Target(target_destination) : "Entity to Move" : "" : "This entity will be moved in the direction of the Entity to Measure."
	TargetReference(target_destination) : "Movement Reference" : "" : "The Entity to Move will move relative to this entity."
	TargetScale(float) : "Trace scale" : "1" : "A scale to *divide* the distance between the Entity to Measure and the trace's endpoint by before applying those movements to the Entity to Move. 1 = target entity moves to the end of the trace, 2 = target entity moves to the middle of the trace (half as far), and 0.5 = target entity moves twice as far as the trace."
	MeasureType(choices) : "Measurement Type" : 0 : "How should the direction be measured?" =
	[
		0 : "Angles"
		1 : "Eye angles"
		2 : "Attachment point angles"
		//3 : "Aim angles"
	]
	
	TraceDistance(float) : "Trace distance" : "8192" : "The maximum distance that the trace can go. 0 = no limit."
	Mask(choices) : "Trace Mask" : 1174421507 : "How the measurement tracing should act in regards to what it should collide with." =
	[
		33570827 : "MASK_SOLID (Anything solid)"
		33636363 : "MASK_PLAYERSOLID (Anything solid + player clip)"
		33701899 : "MASK_NPCSOLID (Anything solid + NPC clip)"
		16432 : "MASK_WATER (Water volumes)"
		16513 : "MASK_OPAQUE (Anything opaque, e.g. windows)"
		16449 : "MASK_BLOCKLOS (Anything that blocks line of sight)"
		1174421507 : "MASK_SHOT (Anything that would be hit by a bullet)"
	]
	
	CollisionGroup(choices) : "Collision Group" : 0 : "The collision group the measurement tracing should use." =
	[
		0 : "None"
	]
	
	damagefilter(filterclass) : "Trace Filter" : "" : "A filter to use for tracing."
	HitIfPassed(choices) : "Trace Filter behavior" : 0 : "What the filter should actually be used for." =
	[
		0 : "If pass, don't hit"
		1 : "If pass, hit"
	]
	
	TraceTargetReference(choices) : "Additional trace from movement reference" : 0 : "Initiates another trace from the Movement Reference using the existing properties and adjusts the position to its end point. Only use this if the Movement Reference is different from the Measure Reference." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	// Inputs
	input SetMeasureTarget(target_destination) : "Set the Entity to Measure, whose movement should be measured."
	input SetMeasureReference(target_destination) : "Set the Measure Reference entity."
	input SetTarget(target_destination) : "Set the Entity to Move, which will be moved to mimic the measured entity."
	input SetTargetReference(target_destination) : "Set the Movement Reference entity."
	input SetTargetScale(float) : "Set the scale to divide the measured movements by."
	input SetMeasureType(integer) : "Sets the measurement type."
	input SetMeasureAttachment(string) : "Sets the measurement attachment."
	input Enable(void) : "Enable the logic_measure_direction."
	input Disable(void) : "Disable the logic_measure_direction."
	input SetTraceFilter(target_destination) : "Sets the entity to use as the trace filter. Pass in an empty string to clear the trace filter."
]


//-------------------------------------------------------------------------
// Misc
//-------------------------------------------------------------------------

@PointClass base(BaseNPC, Parentname) studio() = npc_furniture : 
	"An entity used for non-NPCs that need to synchronise their animation with an NPC in a scripted_sequence. Usually a piece"+
	"of furniture or door that an NPC needs to manipulate within a scripted_sequence."
[
	model(studio) : "Model"
	input DisablePlayerCollision(void) : "Disable collisions against the player."
	input EnablePlayerCollision(void) : "Enable collisions against the player."
]

@PointClass base(Targetname) iconsprite("editor/env_credits.vmt") = env_credits : 
	"An entity to control the rolling credits."
[
	CreditsFile(string) : "Custom Credits File" : : "Allows a custom credits file to be loaded instead of the default 'scripts/credits.txt'."

	// Inputs
	input RollCredits(void) : "Start the intro credits rolling."
	input RollOutroCredits(void) : "Start the outro credits rolling."
	input ShowLogo(void) : "Show the HL2 logo."
	
	// Outputs
	output OnCreditsDone(void)  : "Fired when the credits having finished rolling."
]

@PointClass base(Parentname, Targetname) size(-8 -8 -8, 8 8 8 ) = material_modify_control : 
	"An entity that can be used to directly control material vars. To use it, you need to read the .vmt of the material you "+
	"intend to change. Parent this entity to a brush model entity who's material you want to control."
[
	materialName(string) : "Material to modify."
	materialVar(string) : "Material variable to modify."

	// Inputs
	input SetMaterialVar(string) : "Fire to modify a material variable. The argument is the value to set the variable to."
	input SetMaterialVarToCurrentTime(void) : "This sets the material variable to the current time on the server."
	input StartAnimSequence(string) : "Force an animated material with the MaterialModifyAnimated proxy to play a set of animation frames. Format is: <Frame Start> <Frame End> <Frame Rate> <Loop>\nSetting <Frame End> to -1 uses the last frame of the texture. <Loop> should be 1 or 0."
	input StartFloatLerp(string) : "Force a material with the MaterialModifyAnimated proxy to lerp a material var between two floating point values. Format is: <Start Value> <End Value> <Transition Time> <Loop>\n<Loop> should be 1 or 0."
] 

//-------------------------------------------------------------------------
// Devshot camera
//	- Used by the -makedevshots system, which automatically takes screenshots
//	  at the position of every devshot camera in the level.
//-------------------------------------------------------------------------

@PointClass base(Angles) studioprop("models/editor/camera.mdl") = point_devshot_camera : 
	"An entity used by the -makedevshots system, which automatically takes screenshots at the position of every devshot camera in the level."
[
	cameraname(target_destination) : "Camera Name" : "" : "Used as the name of the directory to store screenshots from this camera. Must be unique within the level."
	FOV(integer) : "Camera FOV" : 75 : "FOV of this camera."
]


// These are I/O/KV on the player itself. They're exposed through logic_playerproxy as it now passes unknown inputs and KV to the player.
@BaseClass base(CombatCharacterFields) = PlayerProxyPlayer
[
	// Inputs
	input SetBodyGroup(integer) : "HACK: Sets this player's body group (from 0 - n). You'd better know what you are doing!"
	input Ignite(void) : "Ignite, burst into flames"
	input IgniteLifetime(float) : "Ignite, with a parameter lifetime."
	input IgniteNumHitboxFires(integer) : "Ignite, with a parameter number of hitbox fires."
	input IgniteHitboxFireScale(float) : "Ignite, with a parameter hitbox fire scale."
	
	input GiveWeapon(string) : "Gives the player a weapon of the specified class name."
	input DropWeapon(string) : "Causes the player to drop its current weapon in front of it."
	
	input AddArmor(integer) : "Adds to the player's current armor value. Total armor cannot exceed 100 unless a different value is set in logic_playerproxy."
	input RemoveArmor(integer) : "Removes from the player's current armor value."
	input SetArmor(integer) : "Sets the player's current armor value. Cannot exceed 100 unless a different value is set in logic_playerproxy."
	
	input AddAuxPower(float) : "Adds to the player's current aux power. Total power cannot exceed 100."
	input RemoveAuxPower(float) : "Removes from the player's current aux power. Total power cannot exceed 100."
	input SetAuxPower(float) : "Sets the player's current aux power. Total power cannot exceed 100."
	
	input TurnFlashlightOn(void) : "Turns the player's flashlight on."
	input TurnFlashlightOff(void) : "Turns the player's flashlight off."
	
	input SquadForceSummon(void) : "Forces the player's squad to be resummoned."
	input SquadForceGoTo(vector) : "Forces the player's squad to go to the specified point."
	
	input EnableGeigerCounter(void) : "Allows the player's geiger counter to respond to radiation if it was prevented before."
	input DisableGeigerCounter(void) : "Prevents the player's geiger counter from responding to radiation."
	
	input ShowSquadHUD(void) : "Shows the player's squad status HUD if it was hidden before."
	input HideSquadHUD(void) : "Hides the player's squad status HUD."
	
	input SetHUDVisibility(bool) : "Sets whether the HUD should be disabled. Also disables most forms of weapon switching."
	input SetSuppressAttacks(bool) : "Sets whether attacks should be suppressed."
]

@PointClass base(Targetname, DamageFilter, PlayerProxyPlayer) iconsprite("editor/logic_playerproxy.vmt") = logic_playerproxy :
	"An entity that is used to relay inputs/ouputs to the player and back to the world."
[
	SetMaxInputArmor(integer) : "Max Input Armor" : 100 : "Sets the maximum armor a player can receive from the AddArmor, RemoveArmor, and SetArmor inputs. This does NOT override how much armor a player can receive overall!"
	
	SetSuitZoomFOV(integer) : "Suit Zoom FOV" : 25 : "Sets the FOV value the player's suit zoom function should use."
	
	ResponseContext(string) : "Response Contexts" : "" : "Response system context(s) for the player. Format should be: 'key:value,key2:value2,etc'. Using inputs like AddContext on this player proxy will not carry it over to the player and should be done on the '!player' entity instead."
	
	HideSquadHUD(choices) : "Hide squad HUD" : 0 : "Hides the player's squad status HUD above the ammo display." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	HandsVM(studio) : "Hands Viewmodel" : : "Custom hands viewmodel. Requires weapon viewmodels that support them."
	HandsVMSkin(string) : "Hands Viewmodel Skin" : : "Skin for the custom hands viewmodel."
	HandsVMBody(string) : "Hands Viewmodel Bodygroup" : : "Bodygroup value for the custom hands viewmodel."

	// Outputs
	output OnFlashlightOn(float) 			: "Fired when the player turns on his flashlight. This output has the value of how much energy the player had when this happened [0..1]."
	output OnFlashlightOff(float) 			: "Fired when the player turns off his flashlight. This output has the value of how much energy the player had when this happened [0..1]."
	input RequestPlayerHealth(void) 		: "Requests the current player's health from the proxy. This will fire the PlayerHealth output with the value."
	input RequestPlayerArmor(void) 			: "Requests the current player's armor from the proxy. This will fire the PlayerArmor output with the value."
	input RequestPlayerAuxPower(void) 		: "Requests the current player's auxiliary power from the proxy. This will fire the PlayerAuxPower output with the value."
	input RequestPlayerFlashBattery(void) 	: "Requests the current player's current flashlight battery from the proxy. This will fire the PlayerFlashBattery output with the value.\n\nNOTE: If legacy flashlight is enabled (aux power flashlight), this will return the player's current auxiliary power."
	output PlayerHealth(integer)			: "The player's current health value, fired in response to RequestPlayerHealth."
	output PlayerArmor(integer)		: "The player's current armor value, fired in response to RequestPlayerArmor."
	output PlayerAuxPower(float)		: "The player's current auxiliary power value, fired in response to RequestPlayerArmor."
	output PlayerFlashBattery(float)		: "The player's current flashlight battery percentage, fired in response to RequestPlayerFlashBattery."
	output PlayerMissedAR2AltFire(void)		: "Player fired an AR2 combine ball that didn't kill any enemies."

	input SetFlashlightSlowDrain(void)		: "Puts the player's flashlight in slow-power-drain mode (for Episodic darkness)"
	input SetFlashlightNormalDrain(void)		: "Puts the player's flashlight to default power drain"

	input SetPlayerHealth(integer)			: "Sets the player's health to this value."
	
	input RequestAmmoState(void)			: "Request the ammo state of the player. It will fire PlayerHasAmmo or PlayerHasNoAmmo outputs."
	output PlayerHasAmmo(void) 				: "Fired by request if the player has any ammo."
	output PlayerHasNoAmmo(void) 			: "Fired by request if the player doesn't have any ammo."
	
	input GetAmmoOnWeapon(string)			: "Requests the amount of ammo on the specified weapon, if the player has it. Fires OnGetAmmo with the amount. This has a few quirks:\n\nFires with secondary ammo if the classname starts with '@' at the beginning. (e.g. @weapon_smg1)\nUses the player's active weapon if the parameter is null. Use '@' to get secondary ammo on the active weapon.\nDoes not fire if the player does not have the specified weapon."
	output OnGetAmmo(integer) 				: "Fires in response to GetAmmoOnWeapon with the weapon's ammo amount."
	
	output OnSquadMemberKilled(void) 				: "Fires when a member of the player's squad dies. Fires with this member as the activator."
	
	output PlayerDied(void) 				: "Fires when the player dies."
	output PlayerDamaged(void) 				: "Fires when the player is damaged."

	input LowerWeapon(void)					: "Lowers the players weapon."
	
	input EnableCappedPhysicsDamage(void) :	 "Cause player to take less damage from physics objects, and never more than 30 points from any individual strike."
	input DisableCappedPhysicsDamage(void) : "Undo effects of EnableCappedPhysicsDamage"
	input SetLocatorTargetEntity(target_destination) : "Set the entity that the HUD locator should track. (Usually a vehicle)"
	
	input SetMaxInputArmor(integer)			: "Sets the maximum armor value that could be set by armor inputs."
	input SetSuitZoomFOV(integer)				: "Sets the FOV used by suit zoom."
	
	output OnPlayerSpawn(void) 				: "Fired when the player spawns or respawns, using the spawn point as the caller."
]

@PointClass base(Targetname) iconsprite("editor/logic_playerinfo.vmt") = logic_playerinfo : 
	"An entity that gets basic info about a player, or finds a player by their basic info." 
[
	input GetPlayerInfo(target_destination) : "Gets player info from the specified entity. If no entity is passed, this will get the local player."
	input GetPlayerByID(string) : "Gets a player by their steam ID. Supports wildcards."
	input GetPlayerByName(string) : "Gets a player by their Steam name. Supports wildcards."
	
	output OutUserID(string) : "Outputs a player's user ID."
	output OutPlayerName(string) : "Outputs a player's Steam name."
	output OutPlayerEntity(ehandle) : "Outputs a player's entity."
]

@PointClass base(Targetname, Parentname) size(-8 -8 -8, 8 8 8 ) = env_spritetrail : 
	"A magical trail you can parent to anything you heart desires."
[
	lifetime(float) : "Lifetime" : "0.5"
	startwidth(float) : "Start Width" : "8.0"
	endwidth(float) : "End Width" : "1.0"
	spritename(string) : "Sprite Name" : "sprites/bluelaser1.vmt"

	renderamt(integer) : "FX Amount (0 - 255)" : 255 : "The FX amount is used by the selected Render Mode."
	rendercolor(color255) : "FX Color (R G B)" : "255 255 255" : "The FX color is used by the selected Render Mode."

	rendermode(choices) : "Render Mode" : 5 =
	[
		0: "Normal"
		4: "Solid"
		5: "Additive"
	]
]

// 
// ASW-based Projected Texture
// 
@PointClass base(Targetname, Parentname, Angles) studio("models/editor/cone_projected_helper.mdl") frustum(lightfov,nearz,farz,lightcolor,-1) = env_projectedtexture : 
	"Projected texture entity."
[
	spawnflags(flags) =
	[
		1  : "[1] Enabled"				: 1
		2  : "[2] Always Update (moving light)"	: 0
	]

	target(target_destination)	: "Target" : : "The entity will rotate to point at this target. Make sure you check the 'Always Update' flag if you set this."	
	
	dontfollowtarget(Choices) : "Don't Follow Target" : 0 : "Prevents this entity from trying to point at its target, if it has one. Intended for when you want to use 'Light Only Target' without the entity trying to point to it." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	lightfov(float)				: "FOV" : "90.0" : "The field of view cone/pyramid at which the texture is projected. Can also be interpreted as 'size'."
	lighthorfov(float)				: "Horizontal FOV" : "0" : "The horizontal FOV value. This allows the projected texture to use rectangular dimensions. Leave this at 0 if you want to keep this the same as the regular FOV value."
	nearz(float)				: "NearZ" : "4.0" : "Objects closer than this will not receive the light from the projection. (Warning: Hard falloff, model lighting inconsistent)"
	farz(float)					: "FarZ" : "750.0" : "Objects beyond this distance will not receive the light from the projection. The projection fades out as it approaches this distance."	
	
	enableshadows(Choices) : "Enable Shadows" : 1 : "Enables/disables shadows from this projected texture." =
	[
		0 : "No"
		1 : "Yes"
	]
	shadowquality(Choices) : "Shadow Quality" : 1 : "Quality of shadows." =
	[
		0 : "Low"
		1 : "High"
	]
	shadowatten(float)			: "Shadow Atten" : "0.0" : "The attenuation of the shadows, or how much the shadows should fade into the light of the projected texture, if at all. The player's flashlight uses 0.35 by default, although higher values may be needed for a visible effect."
	shadowfilter(float)			: "Shadow Filter Size" : "0.5" : "The amount to filter the shadows. This blurs shadows to make them appear less pixelated, but higher values may have more visible noise."
	
	lightonlytarget(Choices) : "Light Only Target" : 0 : "Limit flashlight effect to only effect target entity." =
	[
		0 : "No"
		1 : "Yes"
	]
	lightworld(Choices) : "Light World" : 1 : "Control whether flashlight effects static world geometry." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	brightnessscale(float)		: "Brightness Scale" : "1.0" : "The light color's brightness scale."	

	lightcolor(color255)		: "Light Color" : "255 255 255 200" : "The color of the projected texture. Format is RGB-Intensity, like a light entity. Intensity can only range from 0 to 255, so use the Brightness Scale keyvalue to make the projected texture brighter than 255."
	colortransitiontime(float)	: "Color Transition Time" : "0" : "Amount of time it takes for a color or brightness change to occur. 0 = instant"
	constant_attn(string)	: "Constant" : "0" : "The light's constant attenuation, giving the light no falloff. (This value is internally corrected with x*0.5)"
	linear_attn(string)	: "Linear" : "1" : "The light's linear attenuation, giving the light linear decline. This is the most common attenuation for projected textures. (This value is internally corrected with x*100)"
	quadratic_attn(string)	: "Quadratic" : "0" : "The light's quadratic attenuation, giving the light exponentially decreasing falloff. (This value is internally corrected with x*10000)"
	
	cameraspace(Choices)		: "Camera Space" : 0 : "Angles are interpreted as being relative to camera." =
	[
		0 : "No"
		1 : "Yes"
	]

	texturename(material) : "Texture Name" : "effects/flashlight001" : "The texture which should be used. Please note that env_projectedtexture uses .vtf files directly and does not use .vmt files. The material browser is only available here to assist with finding textures since materials typically have the same name as their textures."
	textureframe(integer) : "Texture Frame" : 0 : "Sets the frame of the projected texture. Only relevant if the texture is animated/has multiple frames."
	
	alwaysdraw(Choices)		: "Always Draw" : 0 : "Always draws the projected texture, regardless of whether the player can see its frustum. Use this for projected textures that can be seen on monitors or in the skybox." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	ProjectedTextureVersion(integer)	readonly	: "Projected Texture Version"      : 1  : "(Don't change). Differentiates between projected textures built before/outside of Mapbase and projected textures using new features."

	// Inputs
	input TurnOn(void)		: "Turns on the texture"
	input TurnOff(void)		: "Turns off the texture"
	input AlwaysUpdateOn(void)	: "Turns on per frame updating (for moving lights)"
	input AlwaysUpdateOff(void)	: "Turns off per frame updating (for moving lights)"
	input FOV(float)		: "Sets the FOV."
	input VerFOV(float)		: "Sets the vertical FOV."
	input HorFOV(float)		: "Sets the horizontal FOV."
	input SpotlightTexture(string)		: "Sets the spotlight texture"
	input SetSpotlightFrame(string)		: "Sets the spotlight texture frame"
	input EnableShadows(bool)		: "Set the if shadows are enabled"
	input LightColor(color255)		: "Change the light color"
	input SetBrightness(float)		: "Sets brightness."
	input SetColorTransitionTime(float)		: "Sets the color transition time."
	input SetConstant(float)		: "Sets the constant attenuation."
	input SetLinear(float)		: "Sets the linear attenuation."
	input SetQuadratic(float)		: "Sets the quadratic attenuation."
	input SetShadowAtten(float)		: "Sets the shadow attenuation."
	input SetFilter(float)		: "Sets the shadow filter."
	input SetNearZ(float)		: "Sets NearZ."
	input SetFarZ(float)		: "Sets FarZ."
	input AlwaysDrawOn(void)	: "Turns off BBox culling (for skybox or monitor lights)"
	input AlwaysDrawOff(void)	: "Turns on BBox culling if it was off before"
	input StopFollowingTarget(void)	: "Causes this entity to stop following the target, if it has one"
	input StartFollowingTarget(void)	: "Causes this entity to start following the target if it was set to not follow it before"
]

@PointClass base(Targetname, Angles, EnableDisable) iconsprite("editor/env_global_light.vmt") = env_global_light : 
	"An orthographic projected texture that follows the player. Sorry, I don't have the original FGD documentation here."
[
	distance(float)				: "Distance" : "10000" : "Height above the player where the projection originates from."
	fov(float)					: "FOV" : "5.0" : "This is the field of view that the sunlight casts in. Use lower values to simulate a more distant sun and sharper shadows."
	nearz(float)				: "NearZ" : "512" : "Distance from the player where the near Z plane is. Anything closer to the projection origin"
	northoffset(float)			: "North Offset" : "200" : "This offsets the from the player position where the sun is attached. (???)"	
	
	eastoffset(float)			: "X Offset" : "0" : "X/East offset the from the player position."	
	forwardoffset(float)		: "Y Offset" : "0" : "Y/Forward offset the from the player position."	
	
	orthosize(float)			: "Ortho Size" : "1000.0" : "The env_global_light's 'size', or how much ground it covers."
	
	enableshadows(Choices) : "Enable Shadows" : 1 : "Enables shadows. If shadows are disabled, light may appear to go through objects. Disabling shadows may be ideal for lower-detail environments due to being less expensive." =
	[
		0 : "No"
		1 : "Yes"
	]

	lightcolor(color255)		: "Light Color" : "255 255 255 200" : "RGBA color of the sunlight. Intensity can only range from 0 to 255, so use the Brightness Scale keyvalue to make the sunlight brighter than 255."
	colortransitiontime(float)	: "Color Transition Time" : "0" : "Amount of time it takes for a color or brightness change to occur. 0 = instant"
	
	brightnessscale(float)		: "Brightness Scale" : "1.0" : "The light color's brightness scale."	

	texturename(material) : "Texture Name" : "effects/flashlight001"
	textureframe(integer) : "Texture Frame" : 0 : "Sets the frame of the env_global_light. Only relevant if the texture is animated/has multiple frames."

	// Inputs
	input SetFOV(float)		: "Set the field of view the sun casts."
	input SetTexture(string)		: "Set the texture cookie of the sunlight."
	input EnableShadows(bool)		: "Set whether shadow maps are enabled"
	input LightColor(color255)		: "Set the light color."
	input SetBrightness(float)		: "Sets brightness."
	input SetColorTransitionTime(float)		: "Sets the color transition time."
	input SetAngles(string) : "Set the sun direction."
	input SetDistance(float) : "Set the distance of the sun."
	input SetNearZDistance(float) : "Set the near z distance."
	input SetNorthOffset(float) : "Sets the north offset."
	input SetXOffset(float) : "Sets the X offset."
	input SetYOffset(float) : "Sets the Y offset."
	input SetOrthoSize(float) : "Sets the light's size."
]


@SolidClass base(func_brush) = func_reflective_glass :
	"Used to produce perfectly reflective glass that renders world + entities. " +
	"Typically, you want your glass brush to have nodraw on all non-reflective surfaces " +
	"and you want to use a shader like lightmappedreflective in your material applied " +
	"to the non-nodraw surfaces. See hl2/materials/glass/reflectiveglass001.vmt for an example. " +
	"NOTE: currently, you cannot use reflective glass in scenes with water, and you can only " +
	"have 1 reflective glass in your view frustum ( + pvs ) at a time."
[
	ReflectRenderTarget(choices) : "Reflection render target" : "_rt_WaterReflection" : "Makes this mirror target a specific RT texture for its reflection instead of just _rt_WaterReflection. You can manually type in any RT texture name if you know what you're doing or leave this blank to disable reflection entirely." =
	[
		"_rt_WaterReflection" : "_rt_WaterReflection (default)"
		"_rt_WaterRefraction" : "_rt_WaterRefraction (requires no nearby refract mirrors)"
		"_rt_Camera" : "_rt_Camera (requires no active point_camera)"
		"0" : "None (disables reflection)"
	]
	
	RefractRenderTarget(choices) : "Refraction render target" : "_rt_WaterRefraction" : "Makes this mirror target a specific RT texture for its refraction instead of just _rt_WaterRefraction. You can manually type in any RT texture name if you know what you're doing or leave this blank to disable refraction entirely." =
	[
		"_rt_WaterRefraction" : "_rt_WaterRefraction (default)"
		"_rt_WaterReflection" : "_rt_WaterReflection (requires no nearby reflect mirrors)"
		"_rt_Camera" : "_rt_Camera (requires no active point_camera)"
		"0" : "None (disables refraction)"
	]
	
	// Inputs
	input SetReflectRenderTarget(string) : "Sets the reflection render target."
	input SetRefractRenderTarget(string) : "Sets the refraction render target."
]

@SolidClass base(func_brush) = func_fake_worldportal :
	"Used to produce perfectly reflective glass that renders world + entities. " +
	"Typically, you want your glass brush to have nodraw on all non-reflective surfaces " +
	"and you want to use a shader like lightmappedreflective in your material applied " +
	"to the non-nodraw surfaces. See hl2/materials/glass/reflectiveglass001.vmt for an example. " +
	"NOTE: currently, you cannot use reflective glass in scenes with water, and you can only " +
	"have 1 reflective glass in your view frustum ( + pvs ) at a time."
[
	target(target_destination) : "Target Plane" : "" : "Target entity to render from."
	PlaneAngles(angle) : "Plane Direction (Pitch Yaw Roll)" : "0 0 0" : "Angles indicating the direction to look in. (added onto target entity's angles)"
	
	SkyMode(choices) : "Sky Mode" : 2 : "How to draw the sky through this view." =
	[
		2 : "Draw sky texture"
		1 : "Draw 3D skybox"
	]
	
	scale(integer) : "View scale" : 0 : "Scales the view, similar to sky_camera scale."
	
	RenderTarget(choices) : "Render target" : "" : "Makes this fake world portal target a specific RT texture instead of just _rt_WaterReflection. You can manually type in any RT texture name if you know what you're doing." =
	[
		"" : "_rt_WaterReflection (default)"
		"_rt_Camera" : "_rt_Camera (requires no active point_camera)"
		"_rt_WaterRefraction" : "_rt_WaterRefraction (requires no nearby refract mirrors)"
	]
	
	FogController(target_destination) : "Fog Controller" : "" : "Makes this fake world portal use the properties of a specific env_fog_controller when rendering the scene. If no fog controller is specified, the scene will use the local player's fog parameters."
	
	// Inputs
	input SetTargetPlane(target_destination) : "Sets the target plane."
	input SetTargetPlaneAngle(vector) : "Sets the target plane direction."
	input SetSkyMode(integer) : "Sets the sky mode. NOTE: 2 = draw sky texture, 1 = draw 3D skybox!"
	input SetRenderTarget(string) : "Sets the render target."
	input SetFogController(target_destination) : "Sets the fog controller."
	input SetScale(float) : "Sets the view scale."
]

@PointClass base(Targetname) = env_particle_performance_monitor : 
	"An entity for turning on and off measuring and display of particle throughput."
[
	// Inputs
	input TurnOnDisplay(void) : "Turn on display of particle simulation benchmark"
	input TurnOffDisplay(void) : "Turn off display of particle simulation benchmark"
	input StartMeasuring(void) : "Start measuring particle simulation speed"
	input StopMeasuring(void) : "Stop measuring particle simulation speed"
]

@PointClass base(BaseNPC, Targetname, Parentname,Studiomodel) studioprop() = npc_puppet : "Puppet entity that mimics the animations of a target NPC."
[
	animationtarget(target_source) : "Animation target" : ""
	attachmentname(string) : "Target attachment point name" : ""

	input SetAnimationTarget(target_destination) : "Set the animation target to use. An empty string will disable the puppet."
]

@PointClass base(Origin, Targetname, EnableDisable) size(-2 -2 -2, 2 2 2) color(0 255 0) = point_gamestats_counter : "Generic game statistics counter."
[
	Name(string) 		: "Name of statistic counter"

	input SetName(string)  : "Changes name of statistic counter"
	input Increment(float) : "Increments named statistic counter by specified value"
]

@PointClass base(Angles) size( -8 -8 -8, 8 8 8 ) instance() = func_instance : 
	"An entity for placing an instance of a map file.  You may translate and rotate this entity. " +
	"You can use the replace keys to do parameter changes on the instance contents.  In a $ at the " +
	"beginning of a variable name.  Then just use the $variable name inside of the instance contents on any "+
	"value portion of a key/value pair."
[
	targetname(target_source) : "Fix Up Name" : : "The name that all entities will be fixed up with based upon the fix up style."
	file(instance_file) : "VMF Filename" : : "This indicates a map file relative to the map's file name"
	fixup_style(Choices) : "Entity Name Fix Up" : 0 : "Fixup style for instanced entity names.  Uses the 'Fix Up Name' field." =
	[
		0 : "Prefix"
		1 : "Postfix"
		2 : "None"
	]
	
	remap_vecline(choices) : "Remap Vector Lines" : 0 : "Remaps vecline keyvalues to the instance's origin. vecline is a type of vector which displays a line back to the entity's origin. This is often used on entities like phys_hinge for displaying an axis." =
	[
		0 : "No"
		1 : "Yes"
	]

	replace01(instance_variable) : "Replace" : : "This is a replacement parameter.  It goes in the form of $variable value.  All entities inside of that instance that have $variable somewhere will be replaced with the value contents.  Example: $color 255 0 0"
	replace02(instance_variable) : "Replace" : : "This is a replacement parameter.  It goes in the form of $variable value.  All entities inside of that instance that have $variable somewhere will be replaced with the value contents.  Example: $color 255 0 0"
	replace03(instance_variable) : "Replace" : : "This is a replacement parameter.  It goes in the form of $variable value.  All entities inside of that instance that have $variable somewhere will be replaced with the value contents.  Example: $color 255 0 0"
	replace04(instance_variable) : "Replace" : : "This is a replacement parameter.  It goes in the form of $variable value.  All entities inside of that instance that have $variable somewhere will be replaced with the value contents.  Example: $color 255 0 0"
	replace05(instance_variable) : "Replace" : : "This is a replacement parameter.  It goes in the form of $variable value.  All entities inside of that instance that have $variable somewhere will be replaced with the value contents.  Example: $color 255 0 0"
	replace06(instance_variable) : "Replace" : : "This is a replacement parameter.  It goes in the form of $variable value.  All entities inside of that instance that have $variable somewhere will be replaced with the value contents.  Example: $color 255 0 0"
	replace07(instance_variable) : "Replace" : : "This is a replacement parameter.  It goes in the form of $variable value.  All entities inside of that instance that have $variable somewhere will be replaced with the value contents.  Example: $color 255 0 0"
	replace08(instance_variable) : "Replace" : : "This is a replacement parameter.  It goes in the form of $variable value.  All entities inside of that instance that have $variable somewhere will be replaced with the value contents.  Example: $color 255 0 0"
	replace09(instance_variable) : "Replace" : : "This is a replacement parameter.  It goes in the form of $variable value.  All entities inside of that instance that have $variable somewhere will be replaced with the value contents.  Example: $color 255 0 0"
	replace10(instance_variable) : "Replace" : : "This is a replacement parameter.  It goes in the form of $variable value.  All entities inside of that instance that have $variable somewhere will be replaced with the value contents.  Example: $color 255 0 0"
]

@PointClass iconsprite("editor/func_instance_parms.vmt") = func_instance_parms : 
	"Place one copy of this entity inside of an instance.  Whenever you add a $parameter for the instance, get the properties " +
	"of this entity.  It will auto-populate it with the variables and allow you to indicate the variable type."
[
	parm1(instance_parm) : "Parm" : : "This is a parameter.  It goes in the form of $variable type."
	parm2(instance_parm) : "Parm" : : "This is a parameter.  It goes in the form of $variable type."
	parm3(instance_parm) : "Parm" : : "This is a parameter.  It goes in the form of $variable type."
	parm4(instance_parm) : "Parm" : : "This is a parameter.  It goes in the form of $variable type."
	parm5(instance_parm) : "Parm" : : "This is a parameter.  It goes in the form of $variable type."
	parm6(instance_parm) : "Parm" : : "This is a parameter.  It goes in the form of $variable type."
	parm7(instance_parm) : "Parm" : : "This is a parameter.  It goes in the form of $variable type."
	parm8(instance_parm) : "Parm" : : "This is a parameter.  It goes in the form of $variable type."
	parm9(instance_parm) : "Parm" : : "This is a parameter.  It goes in the form of $variable type."
	parm10(instance_parm) : "Parm" : : "This is a parameter.  It goes in the form of $variable type."
]

@PointClass iconsprite("editor/func_instance_parms.vmt") = func_instance_io_proxy : 
	"Place one copy of this entity inside of an instance.  Sending messages to entities inside the instance from the Proxy's OnProxyRelay output " +
	"will allow you to trigger these entities from outside the instance by sending messages to the func_instance.  " +
	"Send the ProxyRelay message from entities inside the instance to the proxy and you will be able to use these events to send messages to other entities " +
	"outside the instance from the func_instance. NOTE: The instance, the proxy, and all entities involved should be named descriptively."
[
	targetname(target_source) : "Name" : : "The name that other entities refer to this entity by."

	input ProxyRelay(string) : "This message will get relayed and will be available from the instance."

	output OnProxyRelay(void) : "A message from outside can trigger this to cause something to happen in the instance."
]

@SolidClass base(Trigger) = trigger_apply_impulse : 
	"A trigger that adds impulse to touching entities."
[
	impulse_dir(angle) : "Impulse Direction (Pitch Yaw Roll)" : "0 0 0" : "Angles indicating the direction to push touching entities."
	force(float) : "Impulse Force" : "300" : ""

	input ApplyImpulse(void)  : "Apply impulse to touching entities"
]

@PointClass base(Targetname) sphere(hint_range) iconsprite("editor/env_instructor_hint.vmt") = env_instructor_hint : "An entity that allows for creation and control of instructor lessons by map logic"
[
	hint_replace_key(string) : "Replace Key" : : "Hints with the same Replace Key will replace each other when displayed at the same time. Use different values for each hint if you would like to have multiple hints displaying at once."
	hint_target(target_destination) : "Target Entity" : : "The entity to show this hint on top of. The entity used must exist on the client, info_target_instructor_hint can be parented to server only entities for this purpose."
	hint_static(Choices) : "Positioning" : 0 : "Either show at the position of the Target Entity. Or show the hint directly on the hud at a fixed position." =
	[
		0 : "Follow the Target Entity"
		1 : "Show on the hud"
	]
	
	hint_allow_nodraw_target(Choices) : "Allow invisible target" : 1 : "Do we allow the hint to follow entites with nodraw set?" =
	[
		0 : "End immediately on nodraw"
		1 : "Yes"
	]
	
	hint_caption(string) : "Caption" : : "The text of your hint."
	hint_activator_caption(string) : "Activator Caption" : : "The text of your hint shown to only the activating player."
	hint_color(color255) : "Caption Color" : "255 255 255" : "The color of the caption text"
	hint_forcecaption(Choices) : "Force caption" : 0 : "Do we show the caption text even if the hint is occluded by a wall?" =
	[
		0 : "No"
		1 : "Show when occluded"
	]
	
	hint_icon_onscreen(Choices) : "Onscreen Icon" : "icon_tip" : "The icon to use when the hint is within the player's view." =
	[
		"icon_bulb" : "icon_bulb"
		"icon_caution" : "icon_caution"
		"icon_alert" : "icon_alert"
		"icon_alert_red" : "icon_alert_red"
		"icon_tip" : "icon_tip"
		"icon_skull" : "icon_skull"
		"icon_no" : "icon_no"
		"icon_run" : "icon_run"
		"icon_interact" : "icon_interact"
		"icon_button" : "icon_button"
		"icon_door" : "icon_door"
		"icon_arrow_plain" : "icon_arrow_plain"
		"icon_arrow_plain_white_dn" : "icon_arrow_plain_white_dn"
		"icon_arrow_plain_white_up" : "icon_arrow_plain_white_up"
		"icon_arrow_up" : "icon_arrow_up"
		"icon_arrow_right" : "icon_arrow_right"
		"icon_fire" : "icon_fire"
		"icon_present" : "icon_present"
		"use_binding" : "show key bindings"
		
		"icon_health" : "(HL2) icon_health"
		"icon_battery" : "(HL2) icon_battery"
		"icon_frag" : "(HL2) icon_frag"
		"icon_cmbball" : "(HL2) icon_cmbball"
		"icon_hl2" : "(HL2) icon_hl2"
		"icon_gravgun" : "(HL2) icon_gravgun"
		"icon_bugbait" : "(HL2) icon_bugbait"
		"icon_rocket" : "(HL2) icon_rocket"
		"icon_combine" : "(HL2) icon_combine"
		"icon_lambda" : "(HL2) icon_lambda"
		"icon_squad" : "(HL2) icon_squad"
		"icon_squad_medic" : "(HL2) icon_squad_medic"
		"icon_ammo" : "(HL2) icon_ammo"
		"icon_flashlight" : "(HL2) icon_flashlight"
		"icon_slam" : "(HL2) icon_slam"
		"icon_pistol" : "(HL2) icon_pistol"
	]
	
	hint_icon_offscreen(Choices) : "Offscreen Icon" : "icon_tip" : "The icon to use when the hint is outside the player's view." =
	[
		"icon_bulb" : "icon_bulb"
		"icon_caution" : "icon_caution"
		"icon_alert" : "icon_alert"
		"icon_alert_red" : "icon_alert_red"
		"icon_tip" : "icon_tip"
		"icon_skull" : "icon_skull"
		"icon_no" : "icon_no"
		"icon_run" : "icon_run"
		"icon_interact" : "icon_interact"
		"icon_button" : "icon_button"
		"icon_door" : "icon_door"
		"icon_arrow_plain" : "icon_arrow_plain"
		"icon_arrow_plain_white_dn" : "icon_arrow_plain_white_dn"
		"icon_arrow_plain_white_up" : "icon_arrow_plain_white_up"
		"icon_arrow_up" : "icon_arrow_up"
		"icon_arrow_right" : "icon_arrow_right"
		"icon_fire" : "icon_fire"
		"icon_present" : "icon_present"
		
		"icon_health" : "(HL2) icon_health"
		"icon_battery" : "(HL2) icon_battery"
		"icon_frag" : "(HL2) icon_frag"
		"icon_cmbball" : "(HL2) icon_cmbball"
		"icon_hl2" : "(HL2) icon_hl2"
		"icon_gravgun" : "(HL2) icon_gravgun"
		"icon_bugbait" : "(HL2) icon_bugbait"
		"icon_rocket" : "(HL2) icon_rocket"
		"icon_combine" : "(HL2) icon_combine"
		"icon_lambda" : "(HL2) icon_lambda"
		"icon_squad" : "(HL2) icon_squad"
		"icon_squad_medic" : "(HL2) icon_squad_medic"
		"icon_ammo" : "(HL2) icon_ammo"
		"icon_flashlight" : "(HL2) icon_flashlight"
		"icon_slam" : "(HL2) icon_slam"
		"icon_pistol" : "(HL2) icon_pistol"
	]
	
	hint_nooffscreen(Choices) : "Show offscreen" : 0 : "When the hint is offscreen, do we show an icon and arrow?" =
	[
		0 : "Show"
		1 : "Don't show"		
	]
	
	hint_binding(string) : "Bound Command" : : "If using 'show key bindings' for the onscreen icon, this field should be the command we want to show bindings for"
	hint_icon_offset(float) : "Icon Height Offset" : 0 : "A height offset from the target entity's origin to display the hint"
	hint_pulseoption(Choices) : "Size Pulsing" : 0 : "The icon size can pulsate" =
	[
		0 : "No Pulse"
		1 : "Slow Pulse"
		2 : "Fast Pulse"
		3 : "Urgent Pulse"
	]
	
	hint_alphaoption(Choices) : "Alpha Pulsing" : 0 : "The icon alpha can pulsate" =
	[
		0 : "No Pulse"
		1 : "Slow Pulse"
		2 : "Fast Pulse"
		3 : "Urgent Pulse"
	]
	
	hint_shakeoption(Choices) : "Shaking" : 0 : "The icon can shake" =
	[
		0 : "No Shaking"
		1 : "Narrow Shake"
		2 : "Wide Shake"
	]

	hint_local_player_only(choices) : "Only Local Player" : 0 : "The hint will only be shown to the local player." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	hint_timeout(integer) : "Timeout" : 0 : "The automatic timeout for the hint. 0 will persist until stopped with EndHint."
	hint_range(float) : "Display Range" : 0 : "The visible range of the hint."	
	
	hint_start_sound(sound) : "Sound" : "Instructor.LessonStart" : "The sound to play when the hint is first displayed."
	
	hint_target_pos(choices) : "Icon Target Position" : 0 : "Controls where the hint should appear on the icon target." =
	[
		0 : "Eye position"
		1 : "Origin"
		2 : "World Space Center"
	]
	
	input ShowHint(string) : "Start showing the hint. If an entity name is passed as a parameter, the hint is shown only to that entity."	
	input EndHint(void) : "Stop showing the hint if it hasn't already timed out."
	
	input SetCaption(string) : "Sets the hint's caption. Does not update hints in progress."
]

@PointClass base(Targetname,Parentname) = info_target_instructor_hint : "A generic target that gets replicated to the client for hud hint targeting"
[

]

@PointClass base(Targetname,EnableDisable) = point_glow : "Mapbase off-shoot of tf_glow"
[
	target(target_destination) : "Target" : : "One target only."
	GlowColor(color255) : "Glow Color" : "255 0 0 255" : "<r> <g> <b> <a> 0-255"
	
	input SetGlowColor(color255) : "<r> <g> <b> <a> 0-255"
	input Toggle(void) : "Toggles this entity."
]

@PointClass base(Targetname) iconsprite("editor/postprocess_controller.vmt") color(255 255 255) = postprocess_controller : 
    "An entity that controls the postprocess settings in the map."
[
    // Inputs
    input SetFadeTime(float) : "Set the fade time between post process settings."
    input SetLocalContrastStrength(float) : "Set the local contrast strength."
    input SetLocalContrastEdgeStrength(float) : "Set the local contrast strength at the edge of the screen (controlled by vignette)."
    input SetVignetteStart(float) : "Set the vignette start distance (from screen center)."
    input SetVignetteEnd(float) : "Set the vignette end distance."
    input SetVignetteBlurStrength(float) : "Set the strength of the desaturated blur on the vignette."
    input SetFadeToBlackStrength(float) : "Set the fadeout strength."
    input SetDepthBlurFocalDistance(float) : "Set the focal distance of the depth blur effect (in the range [0,1])."
    input SetDepthBlurStrength(float) : "Set the depth blur effect strength."
    input SetScreenBlurStrength(float) : "Set the screen blur effect strength."
    input SetFilmGrainStrength(float) : "Set the film grain effect strength."

    fadetime(float) : "Fade time" : "2"
    localcontraststrength(float) : "Local contrast strength [-1..x]" : "0"
    localcontrastedgestrength(float) : "Local contrast edge strength [0..1]" : "0"
    vignettestart(float) : "Vignette start distance [0..1]" : "0.8"
    vignetteend(float) : "Vignette end distance [0..x]" : "1.1"
    vignetteblurstrength(float) : "Vignette blur strength [0..1]" : "0"
    fadetoblackstrength(float) : "Fade to black strength [0..1]" : "0"
    depthblurfocaldistance(float) : "Depth-blur focal plane distance [0..1]" : "0"
    depthblurstrength(float) : "Depth-blur effect strength [0..x]" : "0"
    screenblurstrength(float) : "Full-screen blur strength [0..1]" : "0"
    filmgrainstrength(float) : "Film grain strength [0..x]" : "0"

    spawnflags(flags) =
    [
        1 : "[1] Master (Has priority if multiple postprocess_controllers exist)" : 0
    ]
]

@PointClass base(Targetname) sphere(near_blur) sphere(near_focus) sphere(far_blur) sphere(far_focus) sphere(focus_range) iconsprite("editor/env_dof_controller.vmt") = env_dof_controller : 
    "An entity that controls the depth of field settings for the player. Depth of field simulates camera blur of out-of-focus regions of the scene."
[
    enabled(choices) : "Enabled" : 0 : "Whether the effect should be active" =
	[
		0 : "No"
		1 : "Yes"
	]

    near_blur(float) : "Near blur depth" : 20 : "Distance that the blurriness is at its peak near the viewpoint."
    near_focus(float) : "Near focus depth" : 100 : "Distance that the focus is in full effect near the viewpoint."
    near_radius(float) : "Near blur radius" : 0 : "Radius (in pixels) to blur the surrounding pixels."

    far_blur(float) : "Far blur depth" : 1000 : "Distance where blurriness is at its peak far from the viewpoint."
    far_focus(float) : "Far focus depth" : 250 : "Distance that the focus is in full effect far from the viewpoint."
    far_radius(float) : "Far blur radius" : 10 : "Radius (in pixels) to blur the surrounding pixels."
    focus_target(target_source) : "Focus target" : "" : "Entity to use as a focal point."
    focus_range(float) : "Focus target range" : "200" : "Distance behind the focal plane to remain in focus."

    // Inputs
    input SetNearBlurDepth(float) : "Set the distance in front of the focus region at which the scene will be completely blurred using the near blur radius. Must be smaller than NearFocusDepth."
    input SetNearFocusDepth(float) : "The area between the near focus and far focus distances is perfectly in focus. Must be smaller than FarFocusDepth."
    input SetFarFocusDepth(float) : "The area between the near focus and far focus distances is perfectly in focus. Must be smaller than FarBlurDepth."
    input SetFarBlurDepth(float) : "Set the distance beyond the focus region at which the scene will be completely blurred using the far blur radius. Must be larger than FarFocusDepth."
    input SetNearBlurRadius(float) : "Set the blur radius (in pixels) to use at the near blur distance. Set to 0 to disable near blur."
    input SetFarBlurRadius(float) : "Set the blur radius (in pixels) to use at the far blur distance. Set to 0 to disable far blur."
    input SetFocusTarget(string) : "Set the focal target for the effect."
    input SetFocusTargetRange(float) : "Set the distance behind the focal point that will remain in focus."
]

@SolidClass base( Targetname, EnableDisable ) = fog_volume : "An entity to control the fog in the map."
[
	FogName(target_destination) : "Fog Name" : : "The name of the fog entity associated with this volume."
	PostProcessName(target_destination) : "Postprocess Name" : : "The name of the postprocess entity associated with this volume."
	ColorCorrectionName(target_destination) : "ColorCorrection Name" : : "The name of the color_correction entity associated with this volume."
]
